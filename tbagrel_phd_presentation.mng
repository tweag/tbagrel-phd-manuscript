\documentclass[aspectratio=169]{beamer}
\usepackage{hyperref}
\usetheme{metropolis}
\hypersetup{
  hypertexnames=false,
  pdftitle   = {Formalization and Implementation of Safe Destination Passing in Pure Functional Programming Settings},
  pdfauthor  = {Thomas Bagrel},
  pdfsubject = {PhD Presentation},
  pdfcreator = {Thomas Bagrel},
  % ...
}

\usepackage{etoolbox}
\usepackage{calc}
\usepackage{xargs}
\usepackage{xpatch}
\usepackage{xkeyval}
\usepackage{xstring}
\usepackage{xifthen}
\usepackage{xparse}
\usepackage{expl3}
\usepackage{environ}
\usepackage{mathtools, amsfonts, amssymb, amsthm}
\usepackage{chngcntr}
\usepackage{csquotes}

% \usepackage[utf8]{inputenc}
% \usepackage[T1]{fontenc}
\usefonttheme{serif}
\usepackage{fontspec}
% \usepackage{unicode-math}

\usepackage[activate={true, nocompatibility}, stretch=10, shrink=10]{microtype}
\usepackage[svgnames]{xcolor}
\usepackage{graphicx}
\usepackage{polyglossia}
\setmainlanguage{english}
\setotherlanguage{french}
\SetLanguageKeys{english}{indentfirst=true}
\SetLanguageKeys{french}{indentfirst=true}
\usepackage{float}
\renewcommand{\topfraction}{.67}
\renewcommand{\bottomfraction}{.0}
\renewcommand{\textfraction}{.33}
\renewcommand{\floatpagefraction}{.67}
\renewcommand{\dbltopfraction}{.67}
% \renewcommand{\dblbottomfraction}{.0}
% \renewcommand{\dbltextfraction}{.33}
\renewcommand{\dblfloatpagefraction}{.67}
\setcounter{topnumber}{9}
\setcounter{bottomnumber}{9}
\setcounter{totalnumber}{20}
\setcounter{dbltopnumber}{9}


\usepackage{caption}
\usepackage{subcaption}
\usepackage{refcount}
\makeatletter
\providecommand\english@loaded{}
\providecommand\frensh@loaded{}
\makeatother
\usepackage{url}
\usepackage{lastpage}
\usepackage{setspace}
\usepackage{enumitem}\let\newlist\relax\let\renewlist\relax
\usepackage{fancybox}
\usepackage{tabularx}
\usepackage[defaultlines=3,all]{nowidow}
% \usepackage{fancyhdr}

%% For rendering of JFLA article
% \usepackage{tipa}
\usepackage{minted}\usemintedstyle{tango}
\usepackage{stmaryrd}
\usepackage{hhline}
\usepackage[tikz]{bclogo}
\usepackage[normalem]{ulem}
\usepackage{newunicodechar}
\usepackage{adjustbox}

%% For schemas
\usepackage{tikzit}
\usetikzlibrary{calc}
\usetikzlibrary{tikzmark}
\input{tikzstyle.tikzstyles}
%\tikzset{every picture/.style={line width=10pt}}
\newcommand{\figcomment}[1]{\textcolor{gray}{#1}}
\newcommand{\smallspc}{\hspace{-0.5em}}
\definecolor{sczcolor}{RGB}{0,0,0}
\definecolor{sczfcolor}{RGB}{128, 128, 128}
\definecolor{scicolor}{RGB}{199, 22, 6}
\definecolor{scifcolor}{RGB}{251, 164, 157}
\definecolor{sciicolor}{RGB}{60, 103, 163}
\definecolor{sciifcolor}{RGB}{148, 163, 184}
\definecolor{sciiicolor}{RGB}{97, 5, 94}
\definecolor{emerald}{rgb}{0.31, 0.78, 0.47}
\definecolor{firebrick}{rgb}{0.7, 0.13, 0.13}
\newcommand{\scz}[1]{\textcolor{sczcolor}{#1}}
\newcommand{\sczf}[1]{\textcolor{sczfcolor}{#1}}
\newcommand{\sci}[1]{\textcolor{scicolor}{#1}}
\newcommand{\scif}[1]{\textcolor{scifcolor}{#1}}
\newcommand{\scii}[1]{\textcolor{sciicolor}{#1}}
\newcommand{\sciif}[1]{\textcolor{sciifcolor}{#1}}
\newcommand{\sciii}[1]{\textcolor{sciiicolor}{#1}}

%% For OTT rendering
\newunicodechar{⥶}{\ensuremath{\raisebox{0.2em}{$\scriptstyle<$}\hspace*{-0.65em}\raisebox{-0.12em}{$\scriptscriptstyle\leftarrow$}}}
\newcommand{\pleq}{[[⥶]]_{\scriptscriptstyle{\pmb{\mathtt{p}}}}}
\newcommand{\aleq}{[[⥶]]_{\scriptscriptstyle{\pmb{\mathtt{a}}}}}
\usepackage[supertabular]{ottalt}
\inputott{destination_calculus_ott.tex}
\usepackage{ottstyling}
% Hide "Index for ranges" from the metavars displayed tabular
% \patchcmd{\ottmetavars}{$ \ottmv{k} $ & \ottcom{Index for ranges} \\}{}{}{}

% \patchcmd{\ottdruleTyXXectxsXXOpenAmpar}{%
% \ottpremise{  \Delta_{{\mathrm{1}}} ,~ \Delta_{{\mathrm{2}}}  \,\pmb{\dashv}\, \ottnt{C} \pmb{:}  \ottstype{(}  \ottstype{U} \,\ottstype{\ltimes}\, \ottstype{T'}  \ottstype{)}  \ottstype{\rightarrowtail} \ottstype{U_{{\mathrm{0}}}} }%
% \ottpremise{ \Delta_{{\mathrm{2}}} ,~  \ottshname{\destminus^{\scriptscriptstyle\text{-}1} } \Delta_{{\mathrm{3}}}    \!\!\pmb{\phantom{a}^{\scriptscriptstyle \mathrm{v} }\!\!\vdash}\,  \ottnt{v_{{\mathrm{2}}}}  \pmb{:}  \ottstype{U}}%
% }{\ottpremise{  \Delta_{{\mathrm{1}}} ,~ \Delta_{{\mathrm{2}}}  \,\pmb{\dashv}\, \ottnt{C} \pmb{:}  \ottstype{(}  \ottstype{U} \,\ottstype{\ltimes}\, \ottstype{T'}  \ottstype{)}  \ottstype{\rightarrowtail} \ottstype{U_{{\mathrm{0}}}}
% \qquad
% \Delta_{{\mathrm{2}}} ,~  \ottshname{\destminus^{\scriptscriptstyle\text{-}1} } \Delta_{{\mathrm{3}}}    \!\!\pmb{\phantom{a}^{\scriptscriptstyle \mathrm{v} }\!\!\vdash}\,  \ottnt{v_{{\mathrm{2}}}}  \pmb{:}  \ottstype{U}}
% }{}{}

% \patchcmd{\ottdruleTyXXvalXXAmpar}{%
% \ottpremise{   \ottsmode{1}  \hspace{-0.15ex}  \ottsmode{\uparrow}    \ottsmode{\hspace{-0.1ex}\cdot\hspace{-0.1ex} }  \Delta_{{\mathrm{1}}} ,~ \Delta_{{\mathrm{3}}}   \!\!\pmb{\phantom{a}^{\scriptscriptstyle \mathrm{v} }\!\!\vdash}\,  \ottnt{v_{{\mathrm{1}}}}  \pmb{:}  \ottstype{T}}%
% \ottpremise{ \Delta_{{\mathrm{2}}} ,~  \ottshname{\destminus^{\scriptscriptstyle\text{-}1} } \Delta_{{\mathrm{3}}}    \!\!\pmb{\phantom{a}^{\scriptscriptstyle \mathrm{v} }\!\!\vdash}\,  \ottnt{v_{{\mathrm{2}}}}  \pmb{:}  \ottstype{U}}%
% }{
% \ottpremise{   \ottsmode{1}  \hspace{-0.15ex}  \ottsmode{\uparrow}    \ottsmode{\hspace{-0.1ex}\cdot\hspace{-0.1ex} }  \Delta_{{\mathrm{1}}} ,~ \Delta_{{\mathrm{3}}}   \!\!\pmb{\phantom{a}^{\scriptscriptstyle \mathrm{v} }\!\!\vdash}\,  \ottnt{v_{{\mathrm{1}}}}  \pmb{:}  \ottstype{T}
% \qquad
% \Delta_{{\mathrm{2}}} ,~  \ottshname{\destminus^{\scriptscriptstyle\text{-}1} } \Delta_{{\mathrm{3}}}    \!\!\pmb{\phantom{a}^{\scriptscriptstyle \mathrm{v} }\!\!\vdash}\,  \ottnt{v_{{\mathrm{2}}}}  \pmb{:}  \ottstype{U}}%
% }{}{}

% \patchcmd{\ottdruleTyXXtermXXPatS}{%
% \ottpremise{ \Gamma_{{\mathrm{2}}} ,~  \ottmv{x_{{\mathrm{1}}}} :\!_{\! \ottsmode{m} } \ottstype{T_{{\mathrm{1}}}}    \,\pmb{\vdash}\,  \ottnt{u_{{\mathrm{1}}}}  \pmb{:}  \ottstype{U}}%
% \ottpremise{ \Gamma_{{\mathrm{2}}} ,~  \ottmv{x_{{\mathrm{2}}}} :\!_{\! \ottsmode{m} } \ottstype{T_{{\mathrm{2}}}}    \,\pmb{\vdash}\,  \ottnt{u_{{\mathrm{2}}}}  \pmb{:}  \ottstype{U}}%
% }{\ottpremise{ \Gamma_{{\mathrm{2}}} ,~  \ottmv{x_{{\mathrm{1}}}} :\!_{\! \ottsmode{m} } \ottstype{T_{{\mathrm{1}}}}    \,\pmb{\vdash}\,  \ottnt{u_{{\mathrm{1}}}}  \pmb{:}  \ottstype{U}%
% \qquad
% \Gamma_{{\mathrm{2}}} ,~  \ottmv{x_{{\mathrm{2}}}} :\!_{\! \ottsmode{m} } \ottstype{T_{{\mathrm{2}}}}    \,\pmb{\vdash}\,  \ottnt{u_{{\mathrm{2}}}}  \pmb{:}  \ottstype{U}}
% }{}{}

% \patchcmd{\ottdruleTyXXectxsXXPatS}{%
% \ottpremise{\Delta_{{\mathrm{2}}}  +   \ottmv{x_{{\mathrm{1}}}} :\!_{\! \ottsmode{m} } \ottstype{T_{{\mathrm{1}}}}   \,\pmb{\vdash}\,  \ottnt{u_{{\mathrm{1}}}}  \pmb{:}  \ottstype{U}}%
% \ottpremise{\Delta_{{\mathrm{2}}}  +   \ottmv{x_{{\mathrm{2}}}} :\!_{\! \ottsmode{m} } \ottstype{T_{{\mathrm{2}}}}   \,\pmb{\vdash}\,  \ottnt{u_{{\mathrm{2}}}}  \pmb{:}  \ottstype{U}}%
% }{
%   \ottpremise{\Delta_{{\mathrm{2}}}  +   \ottmv{x_{{\mathrm{1}}}} :\!_{\! \ottsmode{m} } \ottstype{T_{{\mathrm{1}}}}   \,\pmb{\vdash}\,  \ottnt{u_{{\mathrm{1}}}}  \pmb{:}  \ottstype{U}
% \qquad
%   \Delta_{{\mathrm{2}}}  +   \ottmv{x_{{\mathrm{2}}}} :\!_{\! \ottsmode{m} } \ottstype{T_{{\mathrm{2}}}}   \,\pmb{\vdash}\,  \ottnt{u_{{\mathrm{2}}}}  \pmb{:}  \ottstype{U}}
% }{}{}

% %% Bibliography settings
% \usepackage[
%   backend=biber,
%   natbib=true,
%   bibstyle=authoryear,
%   citestyle=authoryear-comp,
%   sorting=ynt]{biblatex}
% \addbibresource{bibliography.bib}

%% General document setup
\setmainlanguage{english}

% \makeatletter

% \newrobustcmd*{\parentexttrack}[1]{%
%   \begingroup
%   \blx@blxinit
%   \blx@setsfcodes
%   \blx@bibopenparen#1\blx@bibcloseparen
%   \endgroup}

% \AtEveryCite{%
%   \let\parentext=\parentexttrack%
%   \let\bibopenparen=\bibopenbracket%
%   \let\bibcloseparen=\bibclosebracket}

% \makeatother

% \let\cite\parencite
% \let\citet\textcite

% \setmainfont{Tinos}[
%   Path=./fonts/,
%   Extension=.ttf,
%   UprightFont=*-Regular,
%   BoldFont=*-Bold,
%   ItalicFont=*-Italic,
%   BoldItalicFont=*-BoldItalic,
%   Scale=1.033]
\setmainfont{FiraSans}[
  Path=./fonts/,
  Extension=.ttf,
  UprightFont=*-Light,
  BoldFont=*-Medium,
  ItalicFont=*-LightItalic,
  BoldItalicFont=*-MediumItalic,
  Scale=0.887]
% \setmainfont{CMUSerif}[
%   Path=./fonts/,
%   Extension=.otf,
%   UprightFont=*-Roman,
%   BoldFont=*-Bold,
%   ItalicFont=*-Italic,
%   BoldItalicFont=*-BoldItalic,
%   Scale=1.0]
\setsansfont{iosevka-term-ss07}[
  Path=fonts/,
  Extension=.ttf,
  UprightFont=*-regular,
  BoldFont=*-semibold,
  ItalicFont=*-italic,
  BoldItalicFont=*-semibolditalic,
  Scale=0.887]
\setmonofont{iosevka-term-ss07}[
  Path=fonts/,
  Extension=.ttf,
  UprightFont=*-regular,
  BoldFont=*-semibold,
  ItalicFont=*-italic,
  BoldItalicFont=*-semibolditalic,
  Scale=0.887]
% \setmonofont{Iosevka-Term-SS07}[
%   Path=fonts/,
%   Extension=.ttf,
%   UprightFont=*-Regular,
%   BoldFont=*-Semibold,
%   ItalicFont=*-Italic,
%   BoldItalicFont=*-SemiboldItalic,
%   Scale=0.92]
\setmathrm{iosevka-term-ss07}[
  Path=fonts/,
  Extension=.ttf,
  UprightFont=*-regular,
  BoldFont=*-semibold,
  ItalicFont=*-italic,
  BoldItalicFont=*-semibolditalic,
  Scale=0.887]
\newfontfamily\mymathbffont{iosevka-term-ss07-semibold}[Path=fonts/,
  Extension=.ttf,Scale=0.887]
\newcommand{\mymathbf}[1]{\text{\mymathbffont #1}}
\let\mathbf\mymathbf
% \setmathsf{Tinos}[
%   Path=fonts/,
%   Extension=.ttf,
%   UprightFont=*-Italic,
%   BoldFont=*-BoldItalic,
%   ItalicFont=*-Italic,
%   BoldItalicFont=*-BoldItalic,
%   Scale=1.033]
\setmathsf{CMUSerif}[
  Path=./fonts/,
  Extension=.otf,
  UprightFont=*-Italic,
  BoldFont=*-BoldItalic,
  ItalicFont=*-Italic,
  BoldItalicFont=*-BoldItalic,
  Scale=1.0]
% \setmonofont{Fira-Code-Nerd-Font-Complete}[
%   Extension=.otf,
%   UprightFont=*-Regular,
%   BoldFont=*-Medium,
%   Scale=0.887]

\setlength{\parskip}{0.25\baselineskip}
\setlist[itemize]{topsep=0ex,itemsep=-0.5ex}

\definecolor{mintedframe}{RGB}{100,100,100}
\setminted{
    linenos,                       % Enable line numbering
    xleftmargin=12pt,              % Set left margin to 0
    frame=leftline,                  % Use a frame around the code
    framesep=7.5pt,                 % Space between frame and code
    rulecolor=mintedframe,
    numbersep=7.5pt,                % Space between line numbers and code
    numberblanklines=true,
}

\renewcommand{\theFancyVerbLine}{
\ttfamily
\textcolor{mintedframe}{
\scriptsize{
\arabic{FancyVerbLine}}}}

% %% New listing float
% \newfloat{listing}{tbp}{lop}[chapter]
% \floatname{listing}{Listing}
% \renewcommand{\thelisting}{\thechapter.\arabic{listing}} % chapter-based numbering

% % Step 3 (optional): Reset counter per chapter (for books/theses)
% \counterwithin{listing}{chapter}

% %% Editing marks
% \usepackage[colorinlistoftodos,prependcaption,textsize=tiny]{todonotes}
% % TOGGLE ME to turn off all the commentary:
% \InputIfFileExists{no-editing-marks}{
%   \def\noeditingmarks{}
% }
% % ^^ Need for pgfsyspdfmark apparently?
% \ifx\noeditingmarks\undefined
%     % Adapting to acmart's small margins
%     \setlength{\marginparsep}{0.3em}
%     \setlength{\marginparwidth}{1.4cm}

%     \newcommand{\Red}[1]{{\color{red}{#1}}}
%     \newcommand{\newaudit}[1]{{\color{blue}{#1}}}
%     \newcommand{\note}[1]{{\color{blue}{\begin{itemize} \item {#1} \end{itemize}}}}
%     \newenvironment{alt}{\color{red}}{}

%     \newcommandx{\unsure}[2][1=]{\todo[linecolor=orange,backgroundcolor=orange!25,bordercolor=orange,#1]{#2}}
%     \newcommandx{\info}[2][1=]{\todo[linecolor=green,backgroundcolor=green!25,bordercolor=green,#1]{#2}}
%     \newcommandx{\change}[2][1=]{\todo[linecolor=blue,backgroundcolor=blue!25,bordercolor=blue,#1]{#2}}
%     \newcommandx{\inconsistent}[2][1=]{\todo[linecolor=red,backgroundcolor=red!25,bordercolor=red,#1]{#2}}
%     \newcommandx{\critical}[2][1=]{\todo[linecolor=purple,backgroundcolor=purple!25,bordercolor=purple,#1]{#2}}
%     \newcommand{\improvement}[1]{\todo[linecolor=pink,backgroundcolor=pink!25,bordercolor=pink]{#1}}
%     \newcommandx{\resolved}[2][1=]{\todo[linecolor=OliveGreen,backgroundcolor=OliveGreen!25,bordercolor=OliveGreen,#1]{#2}} % use this to mark a resolved question
% \else
% %    \newcommand{\Red}[1]{#1}
%     \newcommand{\Red}[1]{{\color{red}{#1}}}
%     \newcommand{\newaudit}[1]{#1}
%     \newcommand{\note}[1]{}
%     \newenvironment{alt}{}{}
% %    \renewcommand\todo[2]{}
%     \newcommand{\unsure}[2][1=]{}
%     \newcommand{\info}[2][1=]{}
%     \newcommand{\change}[2]{}
%     \newcommand{\inconsistent}[2]{}
%     \newcommand{\critical}[2]{}
%     \newcommand{\improvement}[1]{}
%     \newcommand{\resolved}[2]{}
% \fi

%\usepackage[hypertexnames=false]{hyperref}
% \usepackage[capitalize, noabbrev]{cleveref}

%% User defined commands

\makeatletter
\newlength\fake@f
\newlength\fake@c
\def\fakesc#1{%
  \begingroup%
  \xdef\fake@name{\csname\curr@fontshape/\f@size\endcsname}%
  \fontsize{\fontdimen8\fake@name}{\baselineskip}\selectfont%
  \uppercase{#1}%
  \endgroup%
}
\makeatother
\newcommand\fauxsc[1]{\fauxschelper#1 \relax\relax}
\def\fauxschelper#1 #2\relax{%
  \fauxschelphelp#1\relax\relax%
  \if\relax#2\relax\else\ \fauxschelper#2\relax\fi%
}
\def\Hscale{.83}\def\Vscale{.79}\def\Cscale{1.00}
\def\fauxschelphelp#1#2\relax{%
  \ifnum`#1>``\ifnum`#1<`\{\scalebox{\Hscale}[\Vscale]{\uppercase{#1}}\else%
    \scalebox{\Cscale}[1]{#1}\fi\else\scalebox{\Cscale}[1]{#1}\fi%
  \ifx\relax#2\relax\else\fauxschelphelp#2\relax\fi}
% \let\textsc\fauxsc

\newcommand{\TODO}[1]{\textnormal{\textcolor{red}{TODO: #1} } }
\newcommand{\sepimp}{\mathrel{-\mkern-6mu*}}
\newcommand{\textopname}[1]{``#1''}
\newcommand{\parr}{\rotatebox[origin=c]{180}{\&}}
\makeatletter
\newcommand{\smallbullet}{} % for safety
\DeclareRobustCommand\smallbullet{%
\mathord{\mathpalette\smallbullet@{0.5}}%
}
\newcommand{\smallbullet@}[2]{%
\vcenter{\hbox{\scalebox{#2}{$\m@th#1\bullet$}}}%
}
\makeatother

\makeatletter
\newcommand{\oset}[3][0ex]{%
\mathrel{\mathop{#3}\limits^{
  \vbox to#1{\kern-2\ex@
  \hbox{$\scriptstyle#2$}\vss}}}}
\makeatother

\def\mycasem#1{\ifthenelse{\equal{#1}{[[¹ν]]}}{}{#1}}
\def\myfunvm#1{\ifthenelse{\equal{#1}{[[¹ν]]}}{\,\,}{#1}}
\def\myfuntm#1{\ifthenelse{\equal{#1}{[[¹ν]]}}{\,}{#1}}
\def\mydestm#1{\ifthenelse{\equal{#1}{[[¹ν]]}}{}{#1}}
\def\mymul#1{\ifthenelse{\equal{#1}{[[¹]]}}{}{#1}}

\let\figtextsize\normalsize
\newcommand{\destcalculus}{\ensuremath{\lambda_d}}
\newcommand{\destcalculusinplace}{\ensuremath{\lambda_{d\,\textsc{ip}}}}
% \newtheorem{lemma}{Lemma}
% \newtheorem{theorem}{Theorem}
\newcommand\btriangleq{\pmb{\triangleq}}
\newcommand\btriangleqrec{\oset{\mathsf{rec}}{\pmb{\triangleq}}}
\newlength{\interdefskip}
\setlength{\interdefskip}{0.1cm}
\newcommand{\newtype}[3][]{#2~\ifthenelse{\equal{#1}{}}{\btriangleq}{\btriangleqrec}~#3\\[\interdefskip]}
\newcommand{\newoperator}[5][]{\phantom{a}\!\!\!\!\!\!\begin{array}[t]{l}%
#2 ~\pmb{:}~ #3 \\
#4 ~\ifthenelse{\equal{#1}{}}{\btriangleq}{\btriangleqrec}~ #5
\end{array}\\[\interdefskip]}
\newcommand{\newoperatorb}[5][]{\phantom{a}\!\!\!\!\!\!\begin{array}[t]{l}%
#2 ~\pmb{:}~ #3 \\
#4 ~\ifthenelse{\equal{#1}{}}{\btriangleq}{\btriangleqrec}~\\\myspace{1}#5
\end{array}\\[\interdefskip]}
\newcommand{\figureratio}{1}
\newcommand{\codehere}[2][t]{\vspace{-0.05cm}\begin{center}\begin{minipage}[#1]{\figureratio\linewidth}{\figtextsize\ensuremath{#2}}\end{minipage}\end{center}\vspace{-0.05cm}}
\NewEnviron{codefig}[2][tbp]{\begin{listing}[#1]
\codehere{\BODY}#2
\end{listing}}
\NewEnviron{ottfig}[2][tbp]{\begin{figure}[#1]
\figtextsize\BODY#2
\end{figure}}
\newcommand{\sidebysidecodehere}[4]{\begin{center}\begin{minipage}[#1]{\figureratio\linewidth}
\noindent\begin{minipage}[#1]{#2\linewidth-0.02\linewidth}{\figtextsize\ensuremath{#3}}\end{minipage}
\hfill
\vrule width 0.5pt % Vertical rule of 1pt width
\hfill
\begin{minipage}[#1]{\linewidth-#2\linewidth-0.02\linewidth}{\figtextsize\ensuremath{#4}}\end{minipage}
\end{minipage}\end{center}
}

\newcommand{\sidebysidecodefig}[6][t]{
\begin{listing}[#1]
\sidebysidecodehere{#3}{#4}{#5}{#6}
#2
\end{listing}
}

\newenvironment{stretchedarray}[2][1]
  {\bgroup\renewcommand*{\arraystretch}{#1}\begin{array}{#2}}
  {\end{array}\egroup}

\newcommand{\mpar}{\text{\,\textramshorns\,}}
\newcommand{\dest}{-\prec}
%\newcommand{\TODO}[1]{{\color{red}\large #1}}
\newcommand{\mnew}[1]{\colorbox{green!50}{#1}}
\newcommand{\muline}[1]{\uline{#1}}
\newcommand{\mold}[1]{\uwave{#1}}
\newunicodechar{⊸}{\ensuremath{\pmb{\multimap}}}
\newunicodechar{→}{\ensuremath{\pmb{\to}}}
\newunicodechar{←}{\ensuremath{\leftarrow}}
\newunicodechar{⇒}{\ensuremath{\pmb{\Rightarrow}}}
\newunicodechar{□}{\ensuremath{{\color{hnamecolor} \square}}}
\newunicodechar{¤}{}
\newunicodechar{;}{\ensuremath{\fatsemi}}
\newunicodechar{∀}{\ensuremath{\pmb{\forall}}}
\newunicodechar{Ⴈ}{1}
\newunicodechar{↑}{\textcolor{modecolor}{$\uparrow$}}
\newunicodechar{⁰}{\textcolor{modecolor}{$^{0}$}}
\newunicodechar{¹}{\textcolor{modecolor}{$^{1}$}}
\newunicodechar{☠}{$\skull$}
\newunicodechar{£}{\texttt{~}}

\newlength{\widthaugment}
\NewEnviron{augmentwidth}[1]
  {\setlength{\widthaugment}{#1}
   \pgfmathsetmacro{\myratio}{\linewidth / (\widthaugment + \linewidth)}
   \scalebox{\myratio}{\begin{minipage}{\linewidth+\widthaugment}\BODY
   \end{minipage}}}

\makeatletter
\AtBeginEnvironment{minted}{\dontdofcolorbox}
\def\dontdofcolorbox{\renewcommand\fcolorbox[4][]{##4}}
\xpatchcmd{\inputminted}{\minted@fvset}{\minted@fvset\dontdofcolorbox}{}{}
\xpatchcmd{\mintinline}{\minted@fvset}{\minted@fvset\dontdofcolorbox}{}{} % see https://tex.stackexchange.com/a/401250/
\makeatother

\renewcommand{\MintedPygmentize}{./pygmentize_local}
\newlength{\currentparskip}
\newenvironment{unbreakable}
{%
  \setlength{\currentparskip}{\parskip}% Save current \parskip
  \setlength{\parskip}{\currentparskip}% Save current \parskip
  \par\vspace{0.5\baselineskip}% Add possible separation
  \noindent\begin{minipage}{\textwidth}%
    \setlength{\parskip}{\currentparskip}% Restore current \parskip
  %\medskip%
}
{%
  \end{minipage}%
  \par\vspace{0.5\baselineskip}% Add possible vertical separation
}

\def\foreverunspace{%
  \ifnum\lastnodetype=11
    \unskip\foreverunspace
  \else
    \ifnum\lastnodetype=12
      \unkern\foreverunspace
    \else
      \ifnum\lastnodetype=13
        \unpenalty\foreverunspace
      \fi
    \fi
  \fi
}

\newcommand{\IfFancyRuleNames}[2]{#1}

\newcommand{\SetPrefix}[1]{\IfFancyRuleNames{\renewcommand{\ottdrulename}[1]{#1}}{}}

\makeatletter

\IfFancyRuleNames{
  \def\CSep{/}
  \def\CHole{id\textsubscript{H}}
  \def\CDest{id\textsubscript{D}}
  \def\CUnit{$\ottstype{1}$I}
  \def\CFun{$\ottstype{\multimap}$I}
  \def\CLeft{$\ottstype{\oplus}$I\textsubscript{1}}
  \def\CRight{$\ottstype{\oplus}$I\textsubscript{2}}
  \def\CProd{$\ottstype{\otimes}$I}
  \def\CExp{$\ottstype{!}$I}
  \def\CBangProm{$\ottstype{!}$P}
  \def\CBangDerel{$\ottstype{!}$D}
  \def\CBangWeak{$\ottstype{!}$W}
  \def\CBangContr{$\ottstype{!}$C}
  \def\CAmpar{$\ottstype{\ltimes}$I}
  \def\CVal{fromVal}
  \def\CVar{id\textsubscript{V}}
  \def\CApp{$\ottstype{\multimap}$E}
  \def\CPatU{$\ottstype{1}$E}
  \def\CPatS{$\ottstype{\oplus}$E}
  \def\CPatP{$\ottstype{\otimes}$E}
  \def\CPatE{$\ottstype{!}$E}
  \def\CUpdA{$\ottstype{\ltimes}$upd}
  \def\CToA{$\ottstype{\ltimes}$to}
  \def\CFromA{$\ottstype{\ltimes}$from}
  \def\CNewA{$\ottstype{\ltimes}$new}
  \def\CFillU{$\ottstype{\lfloor 1\rfloor}$E}
  \def\CFillL{$\ottstype{\lfloor \oplus\rfloor}$E\textsubscript{1}}
  \def\CFillR{$\ottstype{\lfloor \oplus\rfloor}$E\textsubscript{2}}
  \def\CFillP{$\ottstype{\lfloor \otimes\rfloor}$E}
  \def\CFillE{$\ottstype{\lfloor !\rfloor}$E}
  \def\CFillF{$\ottstype{\lfloor \multimap\rfloor}$E}
  \def\CFillComp{$\ottstype{\lfloor}$~$\ottstype{\rfloor}$E\textsubscript{c}}
  \def\CFillLeaf{$\ottstype{\lfloor}$~$\ottstype{\rfloor}$E\textsubscript{l}}
  \def\CId{id}
  \def\COpenAmpar{$\ottstype{\ltimes}$op}
  \def\CAmparOpen{$\ottstype{\ltimes}$op}
  \def\CAmparClose{$\ottstype{\ltimes}$cl}
  \def\CFocus{F}
  \def\CUnfocus{U}
  \def\CRed{C}
  \def\CTyTerm{\destcalculus{}--ty}
  \def\CTySTerm{\destcalculus{}--ty\textsubscript{s}}
  \def\CTyVal{\destcalculus{}--ty\textsubscript{v}}
  \def\CTyEctxs{\destcalculus{}--ty\textsubscript{E}}
  \def\CTyCmd{\destcalculus{}--ty\textsubscript{cmd}}
  \def\CSem{\destcalculus{}--sem}
  \def\CLOne{$\lambda_{L1}$}
  \def\CLTwo{$\lambda_{L2}$}
  \def\CLm{$\lambda_{Lm}$}
  \def\CLdm{$\lambda_{Ldm}$}
  \def\CLOneOrTwo{$\lambda_{L1,2}$}
  \def\CLTwoOrm{$\lambda_{L2,m}$}
  \def\CSemSuff{\hspace*{-0.2ex}--sem}
  \def\CTy{\hspace*{-0.2ex}--ty}
  \def\CILL{ILL}
  \def\rref*#1{\textsc{#1}}
}{
  \renewcommand{\ottdrulename}[1]{\ottalt@replace@cs\ranchor\_-{}#1\\}\renewcommand{\maybecomm}[1]{\bgroup\def\text##1{}#1\egroup}
  \def\CSep{-}
  \def\CHole{Hole}
  \def\CDest{Dest}
  \def\CUnit{Unit}
  \def\CFun{Fun}
  \def\CLeft{Left}
  \def\CRight{Right}
  \def\CProd{Prod}
  \def\CExp{Exp}
  \def\CBangProm{Prom}
  \def\CBangDerel{Derel}
  \def\CBangWeak{Weak}
  \def\CBangContr{Contra}
  \def\CAmpar{Ampar}
  \def\CVal{Val}
  \def\CVar{Var}
  \def\CApp{App}
  \def\CPatU{PatU}
  \def\CPatS{PatS}
  \def\CPatP{PatP}
  \def\CPatE{PatE}
  \def\CUpdA{UpdA}
  \def\CToA{ToA}
  \def\CFromA{FromA}
  \def\CNewA{NewA}
  \def\CFillU{FillU}
  \def\CFillL{FillL}
  \def\CFillR{FillR}
  \def\CFillP{FillP}
  \def\CFillE{FillE}
  \def\CFillF{FillF}
  \def\CFillComp{FillComp}
  \def\CFillLeaf{FillLeaf}
  \def\CId{Id}
  \def\COpenAmpar{OpenAmpar}
  \def\COpen{Open}
  \def\CClose{Close}
  \def\CFocus{Focus}
  \def\CUnfocus{Unfocus}
  \def\CRed{Red}
  \def\CTyTerm{Ty-term}
  \def\CTySTerm{Ty-sterm}
  \def\CTyVal{Ty-val}
  \def\CTyEctxs{Ty-ectxs}
  \def\CTyCmd{Ty-cmd}
}
\makeatother

\makeatletter
\def\uwave{\bgroup \markoverwith{\lower3.5\p@\hbox{\sixly \textcolor{red}{\char58}}}\ULon}
\font\sixly=lasy6 % does not re-load if already loaded, so no memory problem.
\makeatother

\newcommand{\grammsep}{\hspace*{1.8ex}|\hspace*{1.8ex}}
\newcommand{\grammdef}{\mathrel{\raisebox{0.09ex}{$\mathop{:}$\hspace*{-0.1ex}$\mathop{:}$\hspace*{-0.1ex}}\shorteq}}

\setlist[itemize]{label=\blacktriangleright}
\setlist[enumerate]{label=\textbf{(\arabic*)}}

\title{Formalization and Implementation of Safe Destination Passing in Pure Functional Programming Settings}
\date{PhD Defense --- November 14\textsuperscript{th}, 2025}
\author{Thomas \textsc{Bagrel}}
\institute{
\begin{minipage}{\linewidth}
\begin{center}
\raisebox{-0.05cm}{\includegraphics[width=2.2cm]{tweag.png}}\qquad
\includegraphics[width=2.2cm]{Logo_ULorraine-Couleur.png}\qquad
\raisebox{-0.45cm}{\includegraphics[width=1.5cm]{LOGO_CNRS_BLEU.png}}\qquad
\includegraphics[width=2.2cm]{inr_logo_rouge.png}\qquad
\raisebox{-0.45cm}{\includegraphics[width=3cm]{logo_loria_complet_couleur.png}}
\end{center}
\end{minipage}
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Actual presentation content
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Slides de sommaire "déroulant"

\begin{document}
\maketitle

% total sections recorded to .aux (run twice). If you already have this, keep yours.
\newcounter{TBtotalsections}
\makeatletter
\pretocmd{\section}{\stepcounter{TBtotalsections}}{}{}
\AtEndDocument{%
  \immediate\write\@auxout{%
    \string\gdef\string\TBTotalSections{\arabic{TBtotalsections}}%
  }%
}
\providecommand\TBTotalSections{1}
\makeatother

\usebeamercolor{frametitle}
\colorlet{frametitleTealMid}{frametitle.bg!50!teal}

% Top→bottom left-side progress bar, aligned to a marked block (see usage below).
\newcommand{\TBSectionProgressBarLeft}[1]{%
  % #1 = horizontal gap between bar and ToC text (e.g. 6pt)
  \begin{tikzpicture}[remember picture,overlay]
    \def\barw{2pt}
    \def\gap{#1}
    % anchors from tikzmark (defined around your ToC block)
    \coordinate (Top) at ($(pic cs:TBtocTop)+(-\gap,-15pt)$);
    \coordinate (Bot) at ($(pic cs:TBtocBot)+(-\gap,27pt)$);
    % background track
    \draw[line width=\barw, draw=frametitleTealMid!10] (Top) -- (Bot);
    % ratio 0..1, fill from Top toward Bot
    \pgfmathsetmacro{\TBRatio}{min(1, max(0,
      (\insertsectionnumber-0.5) / max(1, \TBTotalSections)
    ))}
    \path (Top) -- (Bot) coordinate[pos=\TBRatio] (FillEnd);
    \draw[line width=\barw, draw=frametitleTealMid] (Top) -- (FillEnd);
  \end{tikzpicture}%
}

% --- colors & fonts (as before) ---
\setbeamercolor{section in toc}{fg=frametitleTealMid}
\setbeamercolor{section in toc shaded}{parent=normal text, fg=frametitleTealMid!40}
\setbeamerfont{section in toc shaded}{size=\Large,series=\mdseries}
\setbeamerfont{section in toc}{size=\LARGE,series=\bfseries}

% Replace Metropolis’ default sectionpage
\metroset{sectionpage=none}

% Put this in your preamble (after loading beamer/theme)
\makeatletter

% Helper deciding which article label to show
\newcommand{\TB@sectionlabel}{%
  \ifnum\inserttocsectionnumber<6
    {\normalsize (1\textsuperscript{st} article)}%
  \else
    {\normalsize (2\textsuperscript{nd} article)}%
  \fi
}

% Normal entries
\setbeamertemplate{section in toc}{%
  \leavevmode
  \usebeamerfont{section in toc}%
  \usebeamercolor[fg]{section in toc}%
  \inserttocsection%
  \hfill \TB@sectionlabel\par%
}

% Shaded entries (used by sectionstyle=show/shaded)
\setbeamertemplate{section in toc shaded}{%
  \leavevmode
  \usebeamerfont{section in toc shaded}%
  \usebeamercolor[fg]{section in toc shaded}%
  \inserttocsection%
  \hfill \TB@sectionlabel\par%
}

\makeatother

\AtBeginSection[]{
  \begin{frame}[plain]
    \vfill
    \centering
    \begin{minipage}{0.9\textwidth}
      \tikzmark{TBtocTop}
      % compute neighbors
      \newcount\PrevSec \PrevSec=\numexpr\insertsectionnumber-1\relax
      \newcount\NextSec \NextSec=\numexpr\insertsectionnumber+1\relax

      % 1) previous sections (greyed, above) — only if any
      \ifnum\PrevSec>0
        \tableofcontents[
          sections={1-\the\PrevSec},
          sectionstyle=show/shaded,
          subsectionstyle=hide
        ]
      \fi

      % 2) current section (centered, normal color)
      \tableofcontents[
        sections={\insertsectionnumber-\insertsectionnumber},
        sectionstyle=show/hide,
        subsectionstyle=hide
      ]

      % 3) next sections (greyed, below) — open-ended range to the end
      \tableofcontents[
        sections={\the\NextSec-},
        sectionstyle=show/shaded,
        subsectionstyle=hide
      ]

      \hbox{}\tikzmark{TBtocBot}
    \end{minipage}
    \TBSectionProgressBarLeft{20pt}
    \vfill
  \end{frame}
}

\setbeamertemplate{footline}{%
  \leavevmode
  \hbox to \paperwidth{%
    \hfill
    \usebeamerfont{page number in head/foot}%
    \usebeamercolor[fg]{page number in head/foot}%
    % --- conditional numbering logic ---
    \ifnum\value{framenumber}<49
      \insertframenumber{} / 48%
    \else
      Annex~\number\numexpr\value{framenumber}-48\relax%
    \fi
    \hspace*{2ex}%
  }%
  \vskip7pt%
}

\begin{frame}{Programming languages}

\begin{itemize}
  \item Imperative languages: instructions step-by-step\\
  \phantom{aa}\textbf{how?} | mutability | untracked side-effects
  \item Functional languages: compose expressions\\
  \phantom{aa}\textbf{what?} | immutability | purity | first-class functions
\end{itemize}

% Dire que l'impératif prescript une suite de modifications mémoire, là où le fonctionnel décrit plutôt des constructions par compositions.
\end{frame}

\begin{frame}[fragile]{Functional languages -- why?}

Modeled after mathematical principles\pause

\begin{itemize}
  \item[\textcolor{teal}{$\pmb{\to}$}] Easier to reason about behavior
  \pause\item[\textcolor{teal}{$\pmb{\to}$}] Better safety guarantees
\end{itemize}
\pause
Memory managed automatically: unpredictable overhead / hard to tune

\end{frame}

% \section{Getting familiar with functional languages}

\begin{frame}[fragile]{Functional data structures}

Data structures are heap-allocated; made of \textbf{linked} heap objects:
  \begin{itemize}
    \item a pointer to the \textbf{info table} (static struct describing the constructor)
    \item for each field, a pointer to this field's value (except for primitive types)
  \end{itemize}

\begin{center}
\begin{minipage}{0.23\linewidth}\begin{center} {\Large \mintinline{haskellc}/[1, 2]/}\\\textit{\small a.k.a.}\\{\Large \mintinline{haskellc}/¤(:) 1 (¤(:) 2 [])/}\end{center}\end{minipage} \scalebox{1.6}{\qquad $\rightsquigarrow$ \quad \adjustbox{valign=c}{\tikzfig{schemas/pres-constructor-heap-obj}}}
\end{center}

\vspace*{-0.5cm}

{\small\itshape
\mintinline{haskellc}/(:)/ is list ``cons'' constructor\\[-0.1cm]
\mintinline{haskellc}/[]/ is list ``nil'' constructor\\[-0.1cm]
\mintinline{haskellc}/¤I#/ is constructor for boxed integers\\[-0.1cm]
\mintinline{haskellc}/1#/ is the primitive/unboxed integer ``one''
}

\end{frame}

\begin{frame}[fragile]{Building order in functional languages -- current}

Data structures: immutable, thus built from the leaves up to the root.

\begin{itemize}
  \item The value of a field must be an existing, fully constructed structure
\end{itemize}

\begin{center}
\pause\scalebox{1.1}{\adjustbox{valign=c}{\tikzfig{schemas/pres-constructor-heap-obj-0}}\pause$\to$\adjustbox{valign=c}{\tikzfig{schemas/pres-constructor-heap-obj-1}}\pause$\to$\adjustbox{valign=c}{\tikzfig{schemas/pres-constructor-heap-obj-2}}\pause$\to$\adjustbox{valign=c}{\tikzfig{schemas/pres-constructor-heap-obj-3}}}
\end{center}

\onslide<5->{
\begin{itemize}
  \item Forces us to build structures in an order that might not be the most natural one.
\end{itemize}
}

\end{frame}

\begin{frame}[fragile]{Building order in functional languages -- goal}
What about lifting this limitation?

\begin{itemize}
  \item Allowing pieces of data structures to be connected like Lego bricks in \textbf{any order}
  \\ {\small \textit{pioneered by ``A Functional Representation of Data Structures with a Hole'', Minamide (1998)}}
\end{itemize}

\begin{center}
\hspace*{-0.5cm}\scalebox{1.1}{\pause\adjustbox{valign=c}{\tikzfig{schemas/pres-constructor-heap-obj-dps-0}}\pause$\to$\adjustbox{valign=c}{\tikzfig{schemas/pres-constructor-heap-obj-dps-1}}$\pause\to$\adjustbox{valign=c}{\tikzfig{schemas/pres-constructor-heap-obj-dps-2}}\pause$\to$\adjustbox{valign=c}{\tikzfig{schemas/pres-constructor-heap-obj-dps-3}}\pause$\to$\adjustbox{valign=c}{\tikzfig{schemas/pres-constructor-heap-obj-3}}}
\end{center}

\vspace*{0.5cm}

{\small\itshape
\textcolor{hnamecolor}{$\displaystyle\square$} denotes a ``hole'' in the structure (an uninitialized memory cell)
}

\end{frame}

\begin{frame}{Challenges}

Unitialized memory/\textbf{holes}:
\begin{itemize}
  \item implies future \textbf{mutability}
  \item no read safety (risk of segfault)
\end{itemize}

Need proper functional abstraction to manipulate incomplete structures.

\end{frame}

\section{Destination passing}

\begin{frame}[fragile]{Here comes destination passing style (DPS)}
Coming from old C days:

\begin{minipage}[t]{0.6\linewidth}
\textcolor{firebrick}{\textbf{Traditional style}}

\begin{minted}{c}
MyStruct * fooTrad() {
  MyStruct *res = malloc(sizeof(MyStruct));
  res->f1 = 1; res->f2 = 2;
  return res;
}
\end{minted}
\end{minipage} \hfill \begin{minipage}[t]{0.39\linewidth}
\textcolor{emerald}{\textbf{DPS style}}

\begin{minted}{c}
void fooDps(MyStruct *dest) {
  dest->f1 = 1; dest->f2 = 2;
}
\end{minted}
\end{minipage}

\pause
\medskip

Caller is responsible for allocation in destination-passing-style function \mintinline{c}/fooDps/. More flexible:
\begin{itemize}
  \item can allocate several slots at once
  \item can allocate on the stack (no \mintinline{c}/malloc/)
\end{itemize}

\end{frame}

\begin{frame}[fragile]{Functional DPS API -- Types (1/2)}

% Transition: en C on sait déjà faire ça, c'est assez commun, mais c'est assez nouveau en FP

\begin{minipage}{0.63\linewidth}
\mintinline{haskellc}/Dest/ination: first-class typed wrapper for a\\\phantom{\mintinline{haskellc}/Dest/ination:} raw pointer to a \textbf{hole}

\begin{itemize}
  \item {\small \textit{breaks from Minamide's approach}}
  \item only way to refer to and act on a hole\\(of an incomplete structure)
\end{itemize}

\medskip

\onslide<2->{\mintinline{haskellc}/Ampar/: first-class opaque wrapper for an\\\phantom{\mintinline{haskellc}/Ampar/:} \textbf{incomplete structure} and its destinations
\begin{itemize}
  \item prevents reading incomplete structure and its holes
  \item only way to refer to and act on an incomplete structure
\end{itemize}
}\end{minipage} \hfill \begin{minipage}{0.36\linewidth}
\hspace*{-1cm}\scalebox{1.2}{\adjustbox{valign=c}{\tikzfig{schemas/pres-incomplete}}}
\end{minipage}

% NOTE: Dire que le boxing des dests n'est pas spécialement requis, c'est un peu spécifique à Haskell

\end{frame}

\begin{frame}[fragile]{Functional DPS API -- Types (2/2)}
Every operation is done through \mintinline{haskellc}/Ampar/ and \mintinline{haskellc}/Dest/ types.

\medskip

\mintinline{haskellc}/data Ampar s t = ¤Ampar s t/ \quad {\small \textit{(opaque)}}

\begin{itemize}
  \item \mintinline{haskellc}/s/ is the type of the incomplete structure
  \item \mintinline{haskellc}/t/ is arbitrary structure carrying all the destinations to holes of \mintinline{haskellc}/s/
\end{itemize}

E.g. \mintinline{haskellc}/Ampar [Int] (Dest Int, Dest Int)/: list of ints with two missing values

\pause
\medskip

\mintinline{haskellc}/data Dest t = ¤Dest Addr#/ \quad {\small \textit{(opaque)}}

\begin{itemize}
  \item \mintinline{haskellc}/t/ is the type of the hole that the destination references
\end{itemize}

\end{frame}

\begin{frame}[fragile,t]{Example: Breadth-first tree relabeling in DPS (1/2)}

\mintinline{haskellc}/data Tree t = ¤Nil | ¤Node t (Tree t) (Tree t)/

\vspace*{0.5cm}

% On peut dire que l'algo naturel impératif est un peu "fonctionnel" dans l'idée, car la mutation en place est assez optionelle, en soi on process l'arbre dans l'ordre BF et on en créé un nouveau dans cet ordre

\only<1>{\hspace*{-1cm}\scalebox{1.0}{\adjustbox{valign=c}{\tikzfig{schemas/pres-bft-problem-0}}}}
\only<2>{\hspace*{-1cm}\scalebox{1.0}{\adjustbox{valign=c}{\tikzfig{schemas/pres-bft-problem-1}}}}
\only<3>{\hspace*{-1cm}\scalebox{1.0}{\adjustbox{valign=c}{\tikzfig{schemas/pres-bft-problem-2}}}}
\only<4>{\hspace*{-1cm}\scalebox{1.0}{\adjustbox{valign=c}{\tikzfig{schemas/pres-bft-problem-3}}}}
\only<5>{\hspace*{-1cm}\scalebox{1.0}{\adjustbox{valign=c}{\tikzfig{schemas/pres-bft-problem-4}}}}
\only<6>{\hspace*{-1cm}\scalebox{1.0}{\adjustbox{valign=c}{\tikzfig{schemas/pres-bft-problem-5}}}}
\only<7>{\hspace*{-1cm}\scalebox{1.0}{\adjustbox{valign=c}{\tikzfig{schemas/pres-bft-problem-6}}}}
\only<8>{\hspace*{-1cm}\scalebox{1.0}{\adjustbox{valign=c}{\tikzfig{schemas/pres-bft-problem}}}}

\vfill
\only<2-> {\small \textit{I represent boxed integer values in a compact way on the schema for clarity of the presentation.}}

\end{frame}

\begin{frame}[fragile,t]{Example: Breadth-first tree building in DPS (2/2)}
\vspace*{1cm}

\only<1>{\hspace*{-0.5cm}\scalebox{1.0}{\adjustbox{valign=c}{\tikzfig{schemas/pres-bft-answer-0}}}}
\only<2>{\hspace*{-0.5cm}\scalebox{1.0}{\adjustbox{valign=c}{\tikzfig{schemas/pres-bft-answer-1}}}}
\only<3>{\hspace*{-0.5cm}\scalebox{1.0}{\adjustbox{valign=c}{\tikzfig{schemas/pres-bft-answer-2}}}}
\only<4>{\hspace*{-0.5cm}\scalebox{1.0}{\adjustbox{valign=c}{\tikzfig{schemas/pres-bft-answer-3}}}}
\only<5>{\hspace*{-0.5cm}\scalebox{1.0}{\adjustbox{valign=c}{\tikzfig{schemas/pres-bft-answer}}}}
\end{frame}

\begin{frame}[fragile]{Functional DPS API -- First attempt}
\begin{minted}{haskellc}
data Ampar s t
data Dest t
type family DestsOf 'Ctor t  -- returns dests corresponding to fields of Ctor

-- Functions on destinations (infix)
&fill @'Ctor :: Dest t              → DestsOf 'Ctor t
&fillComp    :: Dest s → Ampar s t → t
&fillLeaf    :: Dest t → t         → ()

-- Functions on Ampar
newAmpar   :: Ampar s (Dest s)
fromAmpar' :: Ampar s () → s
`updWith`  :: Ampar s t  → (t → u) → Ampar s u  -- (infix)
\end{minted}
\end{frame}

\begin{frame}[fragile,t]{Functional DPS API -- Functions (1/6)}
\begin{itemize}
\item Allocate a hollow data constructor and plug it into a hole?\\[0.1cm]%
\onslide<2>{\mintinline{haskellc}/&fill @'(:) :: Dest [t]££££££££→££££££££££££££(Dest t, Dest [t])/\\[0.1cm]}
\only<1>{\scalebox{1.0}{\adjustbox{valign=c}{\tikzfig{schemas/pres-fillCons-init}}}\\[0.3cm]}
\only<2>{\scalebox{1.0}{\adjustbox{valign=c}{\tikzfig{schemas/pres-fillCons}}}\\[0.3cm]}%
\onslide<2>{\mintinline{haskellc}/&fill @'[]££:: Dest [t]£££££££→£££££££££()/\\[0.1cm]}%
\only<1>{\scalebox{1.0}{\adjustbox{valign=c}{\tikzfig{schemas/pres-fillNil-init}}}}
\only<2>{\scalebox{1.0}{\adjustbox{valign=c}{\tikzfig{schemas/pres-fillNil}}}}
\end{itemize}
\end{frame}
% On regarde sous le tapis d'abord
% On veut agir sur un trou, et y connecter un nouveau chainon pour notre liste chainee, aka hollow cons constructor
% On alloue ce chainon, et on le connecte au trou
% Dans le monde du dessus, pour agir sur un trou on doit utiliser la destination qui pointe dessus
% Et chaque trou restant dans une structure doit etre representé par une destination
% Conséquemment, l'entrée c'est la dest qui pointe sur le trou sur lequel on veut agir, et la sortie c'est 2 nouvelles dests pour les 2 nouveaux trous dans la structure.
\begin{frame}[fragile,t]{Functional DPS API -- Functions (2/6)}
\begin{itemize}
\item Fill a hole with an already complete value?\\[0.1cm]
\onslide<2>{\mintinline{haskellc}/&fillLeaf ::£££Dest t£££→£££t££££££→£££££££££££££££££()/\\[0.3cm]}%
\only<1>{\scalebox{1.0}{\adjustbox{valign=c}{\tikzfig{schemas/pres-fillLeaf-init}}}}
\only<2>{\scalebox{1.0}{\adjustbox{valign=c}{\tikzfig{schemas/pres-fillLeaf}}}}
\end{itemize}
\end{frame}

\begin{frame}[fragile,t]{Functional DPS API -- Functions (3/6)}
\begin{itemize}
\item Plug an incomplete structure into the hole of another one?\\[0.1cm]
\onslide<2>{\mintinline{haskellc}/&fillComp :: Dest s£££→££££££Ampar s t££££££££££££→££££££££££££££££££t/\\[0.3cm]}%
\only<1>{\scalebox{1.0}{\adjustbox{valign=c}{\tikzfig{schemas/pres-fillComp-init}}}}
\only<2>{\scalebox{1.0}{\adjustbox{valign=c}{\tikzfig{schemas/pres-fillComp}}}}
\end{itemize}
\end{frame}

% Say we won't be able to add an incomplete, unconnected block. Every incomplete block must be wrap in an ampar

\begin{frame}[fragile,t]{Functional DPS API -- Functions (4/6)}
\begin{itemize}
\item Spawn new incomplete structure?\\
\mintinline{haskellc}/newAmpar ::£££Ampar s (Dest s)/\\[0.7cm]
\scalebox{1.0}{\adjustbox{valign=c}{\tikzfig{schemas/pres-newAmpar}}}
\end{itemize}
\end{frame}
\begin{frame}[fragile,t]{Functional DPS API -- Functions (5/6)}
\begin{itemize}
\item Access destinations of an Ampar?\\
\mintinline{haskellc}/`updWith` :: Ampar s t£££££→££(t → u)£££→£££££££Ampar s u/\\[0.7cm]
\hspace*{-1.25cm}\scalebox{1.0}{\adjustbox{valign=c}{\tikzfig{schemas/pres-updWith}}}
\end{itemize}
\end{frame}
\begin{frame}[fragile,t]{Functional DPS API -- Functions (6/6)}
\begin{itemize}
\item Extract a completed structure?\\
\mintinline{haskellc}/fromAmpar' ::£££Ampar s ()£££££££££££££££→££££££££££££s/\\[0.7cm]
\scalebox{1.0}{\adjustbox{valign=c}{\tikzfig{schemas/pres-fromAmpar}}}
\end{itemize}
\end{frame}

\section{Safety concerns for functional DPS}

\def\greyedout#1{\textcolor{black!25}{\texttt{#1}}}

\begin{frame}[fragile]{Unrestricted use of destinations}
\begin{onlyenv}<1>
\begin{minted}[escapeinside=°°]{haskellc}
fromAmpar' :: Ampar s () → s  -- I recall the signature

°\greyedout{let apparentlyComplete :: Ampar [Int] () = }°newAmpar°\greyedout{ `updWith` \textbackslash{}d → ()}°
 °\greyedout{in fromAmpar' apparentlyComplete}°
\end{minted}
\end{onlyenv}
\begin{onlyenv}<2>
\begin{minted}[escapeinside=°°]{haskellc}
fromAmpar' :: Ampar s () → s  -- I recall the signature

let apparentlyComplete :: Ampar [Int] () = newAmpar `updWith` \d → ()
 °\greyedout{in fromAmpar' apparentlyComplete}°
\end{minted}
\end{onlyenv}
\begin{onlyenv}<3>
\begin{minted}[escapeinside=°°]{haskellc}
fromAmpar' :: Ampar s () → s  -- I recall the signature

let apparentlyComplete :: Ampar [Int] () = newAmpar `updWith` \d → ()
 in fromAmpar' apparentlyComplete
\end{minted}
\end{onlyenv}

\medskip

\only<1>{\scalebox{1.1}{\adjustbox{valign=c}{\tikzfig{schemas/pres-fromAmpar-segfault-1}}}}
\only<2>{\scalebox{1.1}{\adjustbox{valign=c}{\tikzfig{schemas/pres-fromAmpar-segfault-2}}}}
\only<3>{\scalebox{1.1}{\adjustbox{valign=c}{\tikzfig{schemas/pres-fromAmpar-segfault}}}}

\end{frame}

\section{Linear types}

\begin{frame}[fragile]{Linearity to the rescue}

Linear types and linearity let us control resource consumption of functions.

Idea : \textbf{destinations are linear resources} i.e. must be consumed \textbf{exactly once}:
\begin{itemize}
  \pause\item consumed less than once \phantom{a}$\to$ hole remained unfilled
  \pause\item consumed more than once $\to$ order of evaluation becomes semantically relevant
\end{itemize}

\pause Unconsumed destination = witnesses a remaining hole
\end{frame}

\begin{frame}[fragile]{Linear Haskell overview (1/2)}
Haskell supports linear types since GHC 9.0.1\\
{\small \textit{follows from ``Linear Haskell: practical linearity in a higher-order polymorphic language'',\\\phantom{follows from }Bernardy et al. (2018)}}

\medskip

\mintinline{haskellc}/s ⊸ t/ = Linear function from \mintinline{haskellc}/s/ to \mintinline{haskellc}/t/\\[0.1cm]
means that if the result of type \mintinline{haskellc}/t/ is consumed exactly once, then the argument of type \mintinline{haskellc}/s/ is consumed exactly once too.
\end{frame}

\begin{frame}[fragile]{Linear Haskell overview (2/2)}
A value is \textbf{consumed once} when:
\begin{itemize}
  \item \textbf{pattern-matched on}, and all its fields are consumed once
  \item \textbf{used as an argument} of a linear function whose results is consumed once
  \item \textit{(function)} \textbf{applied} to give a result which is consumed once
\end{itemize}

\only<2->{\textbf{Examples} (assuming the value on the right is consumed):

\vspace*{-0.5cm}}

\begin{center}
\begin{tabular}{p{0.015\linewidth}cp{0.63\linewidth}p{0.28\linewidth}}
\only<2->{\mintinline{haskellc}/x/ &linear in& \mintinline{haskellc}/(x, y)/\quad?}&\only<2->{\textcolor{emerald}{\textbf{$\to$ YES}}}\\
\only<3->{\mintinline{haskellc}/x/ &linear in& \mintinline{haskellc}/(x, x)/\quad?}&\only<3->{\textcolor{firebrick}{\textbf{$\to$ NO}}}\\
\only<4->{\mintinline{haskellc}/x/ &linear in& \mintinline{haskellc}/case y of {¤Nothing -> x ;      ¤Just v -> v}/\quad?}&\only<4->{\textcolor{firebrick}{\textbf{$\to$ NO}}}\\
\only<5->{\mintinline{haskellc}/x/ &linear in& \mintinline{haskellc}/case y of {¤Nothing -> (x, 0) ; ¤Just v -> (x, v)}/\quad?}&\only<5->{\textcolor{emerald}{\textbf{$\to$ YES}}}\\
\only<6->{\mintinline{haskellc}/x/ &linear in& \mintinline{haskellc}/f x/ \phantom{aa,}\quad where \quad \mintinline{haskellc}/f :: t → u/\quad?}&\only<6->{\textcolor{firebrick}{\textbf{$\to$ NO}}}\\
\only<7->{\mintinline{haskellc}/x/ &linear in& \mintinline{haskellc}/fLin x/\hspace*{-0.5ex} \quad where \quad \mintinline{haskellc}/fLin :: t ⊸ u/\quad?}&\only<7->{\textcolor{emerald}{\textbf{$\to$ YES}}}\\
\only<8->{\mintinline{haskellc}/x/ &linear in& \mintinline{haskellc}/¤Ur x/\quad?} &\only<8->{\textcolor{firebrick}{\textbf{$\to$ NO}}}\\
\end{tabular}
\end{center}

\end{frame}

\begin{frame}[fragile]{Linear scopes and resources}
Linearity chains consumption requirements, but it needs to be bootstrapped. 

Trick: scoping function

\quad\mintinline{haskellc}/withResource :: (Resource ⊸ Ur t) ⊸ Ur t/

which is the only \textbf{producer} of \mintinline{haskellc}/Resource/ values

User must pass a \textbf{linear function} consuming the resource in this scope
\begin{itemize}
  \pause\item \mintinline{haskellc}/withResource (\res -> linearConsume res ; Ur ())/ \quad is \quad \textcolor{emerald}{\textbf{OK}}\\[0.1cm]
  \pause\item \begin{minipage}[c]{0.38\linewidth}\mintinline{haskellc}/withResource (\res -> res)/ or\\\mintinline{haskellc}/withResource (\res -> Ur res)/\end{minipage} \quad are\quad\textcolor{firebrick}{\textbf{REJECTED}} (cannot leak)
\end{itemize}

\end{frame}

\begin{frame}[fragile]{Updating the API with linearity}
Trick to easier manage linear resources and their scopes: linearity-infectious \mintinline{haskellc}/Token/:
\begin{minted}{haskellc}
data Token
dup  :: Token ⊸ (Token, Token)
drop :: Token ⊸ ()
withToken :: (Token ⊸ Ur t) ⊸ Ur t
\end{minted}

\pause

Making sure \mintinline{haskellc}/Ampar/s are used linearly, e.g.:\\[0.1cm]
\textcolor{firebrick}{\textbf{Old:\hspace*{1.4ex}}}~\mintinline[escapeinside=°°]{haskellc}/newAmpar ::          °\hspace*{0.5ex}°Ampar s (Dest s)/\\
\textcolor{emerald}{\textbf{New: }}~\mintinline{haskellc}/newAmpar :: Token ⊸ Ampar s (Dest s)/\\[0.1cm]
\pause
\!\!\textcolor{firebrick}{\textbf{Old:\hspace*{1.4ex}}}~\mintinline{haskellc}/updWith :: Ampar s t → (t → u) → Ampar s u/\\
\textcolor{emerald}{\textbf{New: }}~\mintinline{haskellc}/updWith :: Ampar s t ⊸ (t ⊸ u) ⊸ Ampar s u/\\[0.1cm]
\pause
\!\!\mintinline{haskellc}/Dest/s can only ever be accessed through \mintinline{haskellc}/updWith/, which takes a linear function \mintinline{haskellc}/t ⊸ u/ now
%They apparently can't leak out of the \mintinline{haskellc}/Ampar/'s right side...right?
\end{frame}

\begin{frame}[fragile]{Functional DPS API -- Second attempt, with linearity}
\begin{minted}[escapeinside=°°]{haskellc}
data Ampar s t
data Dest t
type family DestsOf 'Ctor t  -- returns dests corresponding to fields of Ctor

&fill @'Ctor :: Dest t              ⊸ DestsOf 'Ctor t
&fillComp    :: Dest s ⊸ Ampar s t ⊸ t
&fillLeaf    :: Dest t ⊸ t         ⊸ ()

newAmpar     :: Token          ⊸ Ampar s (Dest s)
toAmpar      :: Token   ⊸ s  °\hspace*{0.5ex}°⊸ Ampar s ()
tokenBesides :: Ampar s t      ⊸ (Ampar s t, Token)
fromAmpar    :: Ampar s (Ur t) ⊸ (s, Ur t)
fromAmpar'   :: Ampar s ()     ⊸ s
`updWith`    :: Ampar s t      ⊸ (t ⊸ u) ⊸ Ampar s u
\end{minted}
\end{frame}

\section{Safe yet?}

\begin{frame}[fragile]{Scope escape -- Example}
\begin{onlyenv}<2>
\begin{minted}[escapeinside=°°]{haskellc}
°\greyedout{let outer :: Ampar (Dest ()) ()}°
    °\greyedout{outer = }°(newAmpar tok1) `updWith` \(dOuter :: Dest (Dest ())) →
              °\greyedout{let inner :: Ampar () ()}°
                  °\greyedout{inner =}° (newAmpar tok2) `updWith` \(dInner :: Dest ()) →
                            dOuter &fillLeaf dInner
               °\greyedout{in fromAmpar' inner}°
 °\greyedout{in fromAmpar' outer}°
\end{minted}
\end{onlyenv}
\begin{onlyenv}<1>
\begin{minted}{haskellc}
let outer :: Ampar (Dest ()) ()
    outer = (newAmpar tok1) `updWith` \(dOuter :: Dest (Dest ())) →
              let inner :: Ampar () ()
                  inner = (newAmpar tok2) `updWith` \(dInner :: Dest ()) →
                            dOuter &fillLeaf dInner
               in fromAmpar' inner
 in fromAmpar' outer
\end{minted}
\end{onlyenv}

\bigskip

{\small\textit{Minimal example of type-checked code that produce scope-escape/segfault}}

\end{frame}

\begin{frame}[fragile]{Scope escape -- Bigger picture}

Not \emph{just} an artificial edge-case

\begin{itemize}
  \item Linear API are often based on scope-delimited resource consumption
  \item Any form of (linear) storage for linear resources breaks that\\
        \mintinline{haskellc}/storeAway :: t ⊸ ()  -- resource goes away magically/
\end{itemize}

\end{frame}

\section{Avoiding scope escape in Haskell}

\begin{frame}[fragile]{With just Haskell type system (1/2)}

\begin{block}{Solution 1: destinations can only store non-linear data}

\vspace*{0.2cm}

\textcolor{firebrick}{\textbf{Old:\hspace*{1.4ex}}}~\mintinline{haskellc}/fillLeaf :: t ⊸  Dest t ⊸ ()/\\\textcolor{emerald}{\textbf{New: }}~\mintinline[escapeinside=°°]{haskellc}/fillLeaf :: t °\hspace*{0.2ex}°→ UDest t ⊸ ()/\\[0.1cm]
\textcolor{firebrick}{\textbf{Old:\hspace*{1.4ex}}}~\mintinline{haskellc}/fromAmpar'  ::  Ampar s () ⊸ s/\\\textcolor{emerald}{\textbf{New: }}~\mintinline{haskellc}/fromUAmpar' :: UAmpar s () ⊸ Ur s/

In other words, \mintinline{haskellc}/UAmpar s t/ builds an unrestricted \mintinline{haskellc}/s/

{\small \textit{Used in my library \texttt{linear-dest} from article ``DPS: a Haskell implementation'', Bagrel, JFLA 2024}}
\end{block}

\end{frame}

\begin{frame}[fragile]{With just Haskell type system (2/2)}

\begin{block}{Solution 2: destinations for linear data needs new primitives instead of \mintinline{haskellc}/fillLeaf/ / \mintinline{haskellc}/fillComp/}

\vspace*{0.2cm}

Back to Minamide-like system where one operate on \mintinline{haskellc}/Ampar/s directly instead of \mintinline{haskellc}/Dest/s\\ (to prevent scope escape)

\begin{itemize}
  \item With some complications, can work with multiple holes
  \item Still allows for efficient queue of \mintinline{haskellc}/Dest/s in BF-traversal
\end{itemize}

{\small \textit{Developed in Chapter 4 of the PhD manuscript (unpublished)}}
\end{block}

\end{frame}

\section{A more general solution: age control}

\begin{frame}[fragile]{Age system}
Principle: track the age of resources.

\begin{itemize}
\item Age \textcolor{modecolor}{$\uparrow^0$} says the resource (variable) comes from the innermost \mintinline{haskellc}/`updWith`/ scope.
\item When entering a new \mintinline{haskellc}/`updWith`/ scope, all existing resources ages are multiplied by \textcolor{modecolor}{$\uparrow$}\\(scope number increased by 1)
\end{itemize}

\medskip

{\small \textit{Developed in ``Destination Calculus: A Linear $\lambda$-Calculus for Purely Functional Memory Writes'',\\\phantom{Developed in }Bagrel \& Spiwack, OOPSLA1 2025}}

\end{frame}

\begin{frame}[fragile]{Age system -- Example}
Colors indicate the scope in which each object lives.
\begin{center}
\only<1>{\hspace*{-0.7cm}\scalebox{1.1}{\adjustbox{valign=c}{\tikzfig{schemas/pres-updWithScopes-0}}}}
\only<2>{\hspace*{-0.7cm}\scalebox{1.1}{\adjustbox{valign=c}{\tikzfig{schemas/pres-updWithScopes-1}}}}
\only<3>{\hspace*{-0.7cm}\scalebox{1.1}{\adjustbox{valign=c}{\tikzfig{schemas/pres-updWithScopes-2}}}}
\only<4>{\hspace*{-0.7cm}\scalebox{1.1}{\adjustbox{valign=c}{\tikzfig{schemas/pres-updWithScopes-3}}}}
\only<5>{\hspace*{-0.7cm}\scalebox{1.1}{\adjustbox{valign=c}{\tikzfig{schemas/pres-updWithScopes-4}}}}
\only<6>{\hspace*{-0.7cm}\scalebox{1.1}{\adjustbox{valign=c}{\tikzfig{schemas/pres-updWithScopes}}}}
\end{center}
\end{frame}

\begin{frame}[fragile]{Age control prevents scope escape}

New rule: The LHS of \mintinline{haskellc}/&fillLeaf/ (destination being filled) must be exactly one scope \textbf{younger}\\\phantom{New rule: }than the RHS (content being stored away)

\medskip

\begin{minted}[escapeinside=°°]{haskellc}
°\greyedout{let outer :: Ampar (Dest ()) ()}°
    °\greyedout{outer = }°(newAmpar tok1) `updWith` \(dOuter :: ↑⁰ Dest (Dest ())) →
              °\greyedout{let inner :: Ampar () ()}°
                  °\greyedout{inner =}° (newAmpar tok2) `updWith` \(dInner :: ↑⁰ Dest ()) →
                            (dOuter :: ↑¹) &fillLeaf (dInner :: ↑⁰) -- REJECTED
               °\greyedout{in fromAmpar' inner}°
 °\greyedout{in fromAmpar' outer}°
\end{minted}
\end{frame}

\section{Formalization and proofs in Rocq}

\begin{frame}[fragile]{Formalization}
Essence of {\textit{``Destination Calculus: A Linear $\lambda$-Calculus for Purely Functional Memory Writes'',\\\phantom{Essence of }Bagrel \& Spiwack, OOPSLA1 2025}}:

\begin{itemize}
  \item Formal language $\lambda_d$
  \item Built from the ground up with destination-passing in mind
  \item Equipped with linear types and age control
  \item Mechanical proof of type safety (progress + preservation) in Rocq
\end{itemize}

\textcolor{teal}{$\pmb{\to}$} Prove definitively that it is possible to safely program with destinations in\\\phantom{\textcolor{teal}{$\pmb{\to}$} }a purely functional language!
\end{frame}

\begin{frame}[fragile]{Modal type system to track linearity and ages}

Many similarities with type system and rules of {\textit{``Linear Haskell [...]'', Bernardy et al., 2018}}:

\begin{itemize}
  \item Every variable is annotated with a \textbf{mode}
  \item Modes indicates how variables can be used
  \item Following insight from \textit{``Bounded Linear Types in a Resource Semiring'', Ghica \& al., 2014}\\
  and \textit{``Coeffects: a calculus of context-dependent computation'', Petricek \& al., 2014},\\
  modes as a \textbf{semiring} and operations on modes are lifted to typing contexts
\end{itemize}

\textcolor{teal}{$\pmb{\to}$} Easy to add age control without changing much to linear type system rules!

% Linearity or ages only appear in the rules that need them, otherwise modes are just passed around with no cost
\end{frame}

% Modal system, like Linear Haskell, defined in a generic way
% All the rules not speaking explicitely about ages are still incorporating them implicitely, through modes, so that we don't have to re-write or change them at all
% Ages appear only in the rules that need them, like fill rules
% If we can fit ages in the modal system

\begin{frame}[fragile]{Combining linearity and ages in a same semiring}

Modes are elements of a semiring $(\textcolor{modecolor}{M}, \textcolor{modecolor}{+}, \textcolor{modecolor}{\cdot}, \textcolor{modecolor}{1})$
\begin{itemize}
  \item \textcolor{modecolor}{$+$} is used to combine modes when a same variable is used in multiple sub-expressions
  \item \textcolor{modecolor}{$\cdot$} is used to combine modes when a substitution/function composition happens
\end{itemize}

\smallskip

\pause Linearity is represented as semiring\\
        $(\{\textcolor{modecolor}{l}, \textcolor{modecolor}{\omega}\}, \textcolor{modecolor}{+}, \textcolor{modecolor}{\cdot}, \textcolor{modecolor}{l})$

\smallskip

\pause Ages are represented as semiring\\
        $(\{\textcolor{modecolor}{\uparrow^n} \mid \textcolor{modecolor}{n} \in \mathbb{N}, \textcolor{modecolor}{\infty}\}, \textcolor{modecolor}{\overset{\infty}{=}}, \textcolor{modecolor}{\cdot}, \textcolor{modecolor}{\uparrow^0})$

\smallskip

\pause \textcolor{teal}{$\pmb{\to}$} Product of semirings is a semiring!

% Parler de la formalisation en Rocq
\end{frame}

\bgroup
\def\ottstype#1{\textcolor{typcolor}{\mathtt{#1}}}
\def\ottsctor#1{\textcolor{ctorcolor}{\mathtt{#1}}}
\def\ottsmode#1{\textcolor{modecolor}{\mathtt{#1}}}
\def\ottnt#1{\textcolor{ntcolor}{\mathtt{#1}}}
\def\ottshname#1{\textcolor{hnamecolor}{\mathtt{#1}}}

\begin{frame}[fragile]{Type system -- balancing destinations and holes}

I ensure holes and destinations are balanced using a ``subtractive'' typing technique:
\begin{itemize}
  \item The presence of a hole \textbf{provides} a special binding in the typing context\\
  $\{\ottshname{\destminus} \ottshname{h} :\!_{\! \ottsmode{m} }~\ottstype{Dest}\,\!_{ \ottsmode{n} } \ottstype{t}   \}~~\pmb{\dashv}~~\ottsctor{OpAmpar}~\ottshname{\hboxed{ \ottshname{h} } }~ \raisebox{0.2em}{$\scriptstyle [\hspace*{0.5ex}]$}~~\pmb{\ottstype{::}}~\ottstype{u_1}\,\ottstype{\rightarrowtail}\,\ottstype{u_2} $
  \item The use of a destination \textbf{requires} a special binding in the typing context\\(same as a variable use)\\
  $\{\ottshname{\destminus} \ottshname{h} :\!_{\! \ottsmode{m} }~\ottstype{Dest}\,\!_{ \ottsmode{n} } \ottstype{t} \}~~\pmb{\vdash}~~\ottshname{\destminus} \ottshname{h}   \texttt{~\&fillLeaf~}  \ottsctor{()}~~\pmb{\ottstype{::}}~\ottstype{()} $
\end{itemize}

\textcolor{teal}{$\pmb{\to}$} A closed term/program is necessarily well-balanced wrt. destinations and holes.

\end{frame}

\begin{frame}[fragile]{Semantics}

Theoretical language $\lambda_d$ is equipped with small-step semantics.

\begin{itemize}
  \item Controlled mutations resulting from destination filling are implemented as substitutions on the evaluation context $\ottnt{E}$\\
  \textit{\small Syntactic manipulation of the evaluation context as a stack}
  \item No need for full-blown memory model
\end{itemize}

Named hole substitution lemma is the most technical part of the proofs

\end{frame}

\begin{frame}[fragile]{Type safety}

Proved using fairly standard techniques (progress + preservation).\\[0.1cm]
Most of the heavy lifting is done through lemmas and theorems about typing contexts due to the algebraic structure of the type system.

\begin{theorem}[Type preservation]\label{thm:preservation}
  If\quad$ \,\pmb{\vdash}\, \ottnt{E} \big[\, \ottnt{e} \,\big]~\pmb{\ottstype{::}}~\ottstype{t} $\quad and\quad$ \ottnt{E} \,\big[\, \ottnt{e} \,\big] ~\longrightarrow~ \ottnt{E'} \,\big[\, \ottnt{e'} \,\big]$\quad then\quad$ \,\pmb{\vdash}\, \ottnt{E'} \big[\, \ottnt{e'} \,\big]~\pmb{\ottstype{::}}~\ottstype{t} $
\end{theorem}

\begin{theorem}[Progress]\label{thm:progress}
  If\quad$ \,\pmb{\vdash}\, \ottnt{E} \big[\, \ottnt{e} \,\big]~\pmb{\ottstype{::}}~\ottstype{t} $\quad and\quad$\forall \ottnt{v},~\ottnt{E} \biggerbrackl  \ottnt{e}  \biggerbrackr  \neq  \raisebox{0.075em}{$\scriptstyle [\hspace*{0.5ex}]$} \biggerbrackl  \ottnt{v}  \biggerbrackr $\quad then\quad$\exists\,\ottnt{E'}, \ottnt{e'}.~ \ottnt{E} \,\big[\, \ottnt{e} \,\big] ~\longrightarrow~ \ottnt{E'} \,\big[\, \ottnt{e'} \,\big] $
\end{theorem}

\end{frame}

\begin{frame}[fragile]{Conclusion (1/3) -- Goal reached!}

\textcolor{teal}{$\pmb{\to}$} Safe functional destination-passing is definitely doable!

\begin{itemize}
  \item Build immutable structures in a more flexible order
  \item Incomplete structures as first-class citizens
\end{itemize}

\end{frame}

\begin{frame}[fragile]{Conclusion (2/3) -- Applications}

Direct applications:

\begin{itemize}
  \item Enable new algorithms with less copying (difference lists, BF tree traversal)
  \item Prototype already available in Haskell (\texttt{linear-dest} library)
  \item Zero-copy interface to compact regions in GHC (\textbf{proposal submitted!})
\end{itemize}

\end{frame}

\begin{frame}[fragile]{Conclusion (3/3) -- Trade-offs of the different approaches}

Trade-offs to be found between complexity of the type system and expressivity of the destination-passing interface:

\begin{itemize}
  \item Lower end: Haskell type system only, simple interface, destinations can't store linear data -- still very useful!
  \item Higher end: safe-proven theoretical language with no limit on destination use (but needs a bespoke type system)
\end{itemize}

Further work: Use the theoretical language as a framework to prove safety of less expressive destination-passing systems

\end{frame}

\begin{frame}[fragile]{Contributions}
\begin{itemize}
  \item ``Destination-passing style programming: a Haskell implementation'' (Article + Impl)\\
  {\small JFLA 2024, \url{inria.hal.science/hal-04406360}}
  \item ``A zero-copy interface to compact regions powered by destinations'' (Talk)\\
  {\small HIW 2024, \url{www.youtube.com/watch?v=UIw0s-yEkfw}}
  \item ``Destination Calculus: A Linear $\lambda$-Calculus for Purely Functional Memory Writes'' (Article)\\
  {\small Co-authored with A. Spiwack, OOPSLA1 2025, \url{dl.acm.org/doi/10.1145/3720423}}
  \item ``Primitives for zero-copy compact regions'' (GHC Proposal)\\
  {\small Work in progress, \url{github.com/ghc-proposals/ghc-proposals/pull/683}}
\end{itemize}

\bigskip

Thank you for your attention! I'll be happy to answer your questions.
\end{frame}

% Rappeler la problématique et comment j'y réponds.

\begin{frame}[fragile]{Functional DPS API -- scope-escape free}
\begin{minted}[escapeinside=°°]{haskellc}
data UAmpar s t
data UDest t
type family UDestsOf 'Ctor t  -- returns dests corresponding to fields of Ctor

&fill @'Ctor :: UDest t               ⊸ UDestsOf 'Ctor t
&fillComp    :: UDest s ⊸ UAmpar s t ⊸ t
&fillLeaf    :: UDest t ⊸ t          °\hspace*{0.2ex}°→ ()

newUAmpar    :: Token           ⊸ UAmpar s (Dest s)
toUAmpar     :: Token   ⊸ s   °\hspace*{0.7ex}°→ UAmpar s ()
tokenBesides :: UAmpar s t      ⊸ (UAmpar s t, Token)
fromUAmpar   :: UAmpar s (Ur t) ⊸ Ur (s, t)
fromUAmpar'  :: UAmpar s ()     ⊸ Ur s
`updWith`    :: UAmpar s t      ⊸ (t ⊸ u) ⊸ UAmpar s u
\end{minted}
\end{frame}

\begin{frame}[fragile]{Benchmarks of zero-copy compact region implementation}

S-expression parser

\hspace*{-0.05\linewidth}\includegraphics[width=1.1\linewidth]{graphics/plot-parser.pdf}

\end{frame}

\begin{frame}[fragile]{Benchmarks of zero-copy compact region implementation}

Tree relabeling

\hspace*{-0.05\linewidth}\includegraphics[width=1.1\linewidth]{graphics/plot-bft.pdf}

\end{frame}

\begin{frame}[fragile]{Benchmarks of zero-copy compact region implementation}

Iterated list concatenation

\hspace*{-0.05\linewidth}\includegraphics[width=1.1\linewidth]{graphics/plot-concat.pdf}

\end{frame}

\begin{frame}[fragile]{\texttt{Ampar}: origin of the name}

In classical linear logic, the linear implication $\ottstype{\multimap}$ can decomposed into $\ottstype{\cdot^{\perp}}$ and $\ottstype{\parr}$:

\quad$\ottstype{t \multimap u}~~\equiv~~\ottstype{t^{\perp}~\parr~u}~~\equiv~~\ottstype{u~\parr~t^{\perp}}$

Minamide shows that a structure of type $\ottstype{u}$ with a hole of type $\ottstype{t}$ can be represented as a form of linear function $\ottstype{t \overset{mem}{\multimap} u}$

So we decompose it into~~$\ottstype{u~\overset{mem}{\parr}~t^{\overset{mem}{\perp}}}$.\\Actually,

\begin{itemize}
  \item $\ottstype{t^{\overset{mem}{\perp}}}$ is $\ottstype{Dest~t}$
  \item $\ottstype{\overset{mem}{\parr}}$ is $\ottstype{Ampar}$ type constructor (\textit{asymetrical memory par})\\
\end{itemize}

The \emph{asymetrical} aspect comes from the fact that we lose some nice properties\\ of the original $\ottstype{\parr}$ connective because we are not in a classical setting.
\end{frame}

\begin{frame}[fragile]{Age system VS Rust lifetimes}

\textbf{Ages} in $\lambda_d$ are:
\begin{itemize}
  \item relative (relative offsets through modality $\expcons{[[m]]}$)
  \item locally exact
  \item equalities and strict inequalities
\end{itemize}

\medskip

\textbf{Rust lifetimes} are:
\begin{itemize}
  \item global/absolute
  \item lifetime subtyping = (local) loss of information
  \item supports only large inequalities
\end{itemize}

To avoid scope escape, we want to know that \textbf{something will die strictly before another} instead of that \textbf{something will live at least as long as another}.

\end{frame}

\egroup

% NOTE: Retombées concrètes (proposal GHC, etc)
% NOTE: Thèse industrielle ancrée dans le réel
% 
\end{document}