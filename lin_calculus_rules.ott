defns
LinTy :: '' ::=

defn
P ╟ T :: :: LinMon_Log :: 'LinMon_Log' {{ com Deduction rules }} by

----------------------- :: Var {{ com Id }}
_T ╟ T

P , _T ╟ U [[:Tyu]]
----------------- :: Fun {{ com $\ottstype{\multimap}$I }}
P ╟ T ⊸ U

--------------------- :: Unit {{ com $\ottstype{1}$I }}
{} ╟ ①

P ╟ T1 [[:Tyt1]]
--------------------- :: Left {{ com $\ottstype{\oplus}$I\textsubscript{L} }}
P ╟ T1 ⨁ T2

P ╟ T2 [[:Tyt2]]
--------------------- :: Right {{ com $\ottstype{\oplus}$I\textsubscript{R} }}
P ╟ T1 ⨁ T2

P1 ╟ T1 [[:Tyt1]]
P2 ╟ T2 [[:Tyt2]]
------------------------- :: Prod {{ com $\ottstype{\otimes}$I }}
P1, P2 ╟ T1 ⨂ T2

P1 ╟ T [[:Tyt]]
P2 ╟ T ⊸ U [[:Tytp]]
----------------- :: App {{ com $\ottstype{\multimap}$E }}
P1, P2 ╟ U

P1 ╟ ① [[:Tyt]]
P2 ╟ U [[:Tyu]]
----------------- :: PatU {{ com $\ottstype{1}$E }}
P1 , P2 ╟ U

P1 ╟ T1 ⨁ T2 [[:Tyt]]
P2, _T1 ╟ U [[:Tyu1]]
P2, _T2 ╟ U [[:Tyu2]]
----------------- :: PatS {{ com $\ottstype{\oplus}$E }}
P1, P2 ╟ U

P1 ╟ T1 ⨂ T2 [[:Tyt]]
P2, _T1, _T2 ╟ U [[:Tyu]]
----------------- :: PatP {{ com $\ottstype{\otimes}$E }}
P1, P2 ╟ U

!P ╟ T [[:Tyt]]
--------------------- :: Exp {{ com $\ottstype{!}$P }}
!P ╟ !T

P ╟ !T [[:Tyt]]
----------------- :: Derelict {{ com $\ottstype{!}$D }}
P ╟ T

P1 ╟ !T [[:Tyt]]
P2, _!T, _!T ╟ U [[:Tyu]]
----------------- :: Dup {{ com $\ottstype{!}$C }}
P1, P2 ╟ U

P1 ╟ !T [[:Tyt]]
P2 ╟ U [[:Tyu]]
------------------- :: Drop {{ com $\ottstype{!}$W }}
P1, P2 ╟ U

defn
P ⊪ t : T :: :: LinMon_Ty_term :: 'LinMon_Ty_term_' {{ com Typing judgment for terms }} by

----------------------- :: Var {{ com Id }}
{ x ⫶ T } ⊪ x : T

P , { x ⫶ T } ⊪ u : U [[:Tyu]]
----------------- :: Fun {{ com $\ottstype{\multimap}$I }}
P ⊪ λ x ⟼ u : T ⊸ U

--------------------- :: Unit {{ com $\ottstype{1}$I }}
{} ⊪ () : ①

P ⊪ t1 : T1 [[:Tyt1]]
--------------------- :: Left {{ com $\ottstype{\oplus}$I\textsubscript{L} }}
P ⊪ ˢInl t1 : T1 ⨁ T2

P ⊪ t2 : T2 [[:Tyt2]]
--------------------- :: Right {{ com $\ottstype{\oplus}$I\textsubscript{R} }}
P ⊪ ˢInr t2 : T1 ⨁ T2

P1 ⊪ t1 : T1 [[:Tyt1]]
P2 ⊪ t2 : T2 [[:Tyt2]]
------------------------- :: Prod {{ com $\ottstype{\otimes}$I }}
P1, P2 ⊪ ˢ(t1, t2) : T1 ⨂ T2

P1 ⊪ t : T [[:Tyt]]
P2 ⊪ t' : T ⊸ U [[:Tytp]]
----------------- :: App {{ com $\ottstype{\multimap}$E }}
P1, P2 ⊪ t' t : U

P1 ⊪ t : ① [[:Tyt]]
P2 ⊪ u : U [[:Tyu]]
----------------- :: PatU {{ com $\ottstype{1}$E }}
P1 , P2 ⊪ t ; u : U

P1 ⊪ t : T1 ⨁ T2 [[:Tyt]]
P2, { x1 ⫶ T1 } ⊪ u1 : U [[:Tyu1]]
P2, { x2 ⫶ T2 } ⊪ u2 : U [[:Tyu2]]
----------------- :: PatS {{ com $\ottstype{\oplus}$E }}
P1, P2 ⊪ t ►case ¹ν { Inl x1 ⟼ u1 , Inr x2 ⟼ u2 } : U

P1 ⊪ t : T1 ⨂ T2 [[:Tyt]]
P2, { x1 ⫶ T1 }, { x2 ⫶ T2 } ⊪ u : U [[:Tyu]]
----------------- :: PatP {{ com $\ottstype{\otimes}$E }}
P1, P2 ⊪ t ►case ¹ν (x1 , x2) ⟼ u : U

!P ⊪ t : T [[:Tyt]]
--------------------- :: Exp {{ com $\ottstype{!}$P }}
!P ⊪ ᴇ t : !T

P ⊪ t : !T [[:Tyt]]
----------------- :: Derelict {{ com $\ottstype{!}$D }}
P ⊪ derelict t : T

P1 ⊪ t : !T [[:Tyt]]
P2, { x1 ⫶ !T }, { x2 ⫶ !T } ⊪ u : U [[:Tyu]]
----------------- :: Dup {{ com $\ottstype{!}$C }}
P1, P2 ⊪ dup t as x1, x2 in u : U

P1 ⊪ t : !T [[:Tyt]]
P2 ⊪ u : U [[:Tyu]]
------------------- :: Drop {{ com $\ottstype{!}$W }}
P1, P2 ⊪ drop t in u : U

defn
P ; Ur ⊫ t : T :: :: LinDya_Ty_term :: 'LinDya_Ty_term_' {{ com Typing judgment for terms }} by

----------------------- :: VarLin {{ com Id\textsubscript{Lin} }}
{ x ⫶ T } ; Ur ⊫ x : T

----------------------- :: VarUr {{ com Id\textsubscript{Ur} }}
{} ; Ur , { x ⫶ T } ⊫ x : T

P , { x ⫶ T } ; Ur ⊫ u : U [[:Tyu]]
----------------- :: Fun {{ com $\ottstype{\multimap}$I }}
P ; Ur ⊫ λ x ⟼ u : T ⊸ U

--------------------- :: Unit {{ com $\ottstype{1}$I }}
{} ; Ur ⊫ () : ①

P ; Ur ⊫ t1 : T1 [[:Tyt1]]
--------------------- :: Left {{ com $\ottstype{\oplus}$I\textsubscript{L} }}
P ; Ur ⊫ ˢInl t1 : T1 ⨁ T2

P ; Ur ⊫ t2 : T2 [[:Tyt2]]
--------------------- :: Right {{ com $\ottstype{\oplus}$I\textsubscript{R} }}
P ; Ur ⊫ ˢInr t2 : T1 ⨁ T2

P1 ; Ur ⊫ t1 : T1 [[:Tyt1]]
P2 ; Ur ⊫ t2 : T2 [[:Tyt2]]
------------------------- :: Prod {{ com $\ottstype{\otimes}$I }}
P1, P2 ; Ur ⊫ ˢ(t1, t2) : T1 ⨂ T2

% we should augment age of holes which are below an exponential
{} ; Ur ⊫ t : T [[:Tyt]]
--------------------- :: Exp {{ com $\ottstype{!}$I }}
{} ; Ur ⊫ ᴇ t : !T

P1 ; Ur ⊫ t : T [[:Tyt]]
P2 ; Ur ⊫ t' : T ⊸ U [[:Tytp]]
----------------- :: App {{ com $\ottstype{\multimap}$E }}
P1, P2 ; Ur ⊫ t' t : U

P1 ; Ur ⊫ t : ① [[:Tyt]]
P2 ; Ur ⊫ u : U [[:Tyu]]
----------------- :: PatU {{ com $\ottstype{1}$E }}
P1 , P2 ; Ur ⊫ t ; u : U

P1 ; Ur ⊫ t : T1 ⨁ T2 [[:Tyt]]
P2, { x1 ⫶ T1 } ; Ur ⊫ u1 : U [[:Tyu1]]
P2, { x2 ⫶ T2 } ; Ur ⊫ u2 : U [[:Tyu2]]
----------------- :: PatS {{ com $\ottstype{\oplus}$E }}
P1, P2 ; Ur ⊫ t ►case ¹ν { Inl x1 ⟼ u1 , Inr x2 ⟼ u2 } : U

P1 ; Ur ⊫ t : T1 ⨂ T2 [[:Tyt]]
P2, { x1 ⫶ T1 }, { x2 ⫶ T2 } ; Ur ⊫ u : U [[:Tyu]]
----------------- :: PatP {{ com $\ottstype{\otimes}$E }}
P1, P2 ; Ur ⊫ t ►case ¹ν (x1 , x2) ⟼ u : U

% No shadowing allowed?
P1 ; Ur ⊫ t : ! T [[:Tyt]]
P2 ; Ur, { x ⫶ T } ⊫ u : U [[:Tyu]]
----------------- :: PatE {{ com $\ottstype{!}$E }}
P1, P2 ; Ur ⊫ t ►case ¹ν ᴇ x ⟼ u : U

defn
P ⫢ t : T :: :: LinMod_Ty_term :: 'LinMod_Ty_term_' {{ com Typing judgment for terms }} by

{{ [[˥]] <: [[m]] }} [[:Subtypem]]
----------------------- :: Var {{ com Id }}
ɷ·P, { x : m T } ⫢ x : T

P , { x : m T } ⫢ u : U [[:Tyu]]
----------------- :: Fun {{ com $\ottstype{\multimap}$I }}
P ⫢ ˢλ x m ⟼ u : T m → U

--------------------- :: Unit {{ com $\ottstype{1}$I }}
ɷ·P ⫢ () : ①

P ⫢ t1 : T1 [[:Tyt1]]
--------------------- :: Left {{ com $\ottstype{\oplus}$I\textsubscript{L} }}
P ⫢ ˢInl t1 : T1 ⨁ T2

P ⫢ t2 : T2 [[:Tyt2]]
--------------------- :: Right {{ com $\ottstype{\oplus}$I\textsubscript{R} }}
P ⫢ ˢInr t2 : T1 ⨁ T2

P1 ⫢ t1 : T1 [[:Tyt1]]
P2 ⫢ t2 : T2 [[:Tyt2]]
------------------------- :: Prod {{ com $\ottstype{\otimes}$I }}
P1 + P2 ⫢ ˢ(t1, t2) : T1 ⨂ T2

% we should augment age of holes which are below an exponential
P ⫢ t : T [[:Tyt]]
--------------------- :: Exp {{ com $\ottstype{!}$I }}
n·P ⫢ ˢᴇ n t : ! n T

P1 ⫢ t : T [[:Tyt]]
P2 ⫢ t' : T m → U [[:Tytp]]
----------------- :: App {{ com $\ottstype{\multimap}$E }}
m·P1 + P2 ⫢ t' t : U

P1 ⫢ t : ① [[:Tyt]]
P2 ⫢ u : U [[:Tyu]]
----------------- :: PatU {{ com $\ottstype{1}$E }}
P1 + P2 ⫢ t ; u : U

P1 ⫢ t : T1 ⨁ T2 [[:Tyt]]
P2, { x1 : ˥ T1 } ⫢ u1 : U [[:Tyu1]]
P2, { x2 : ˥ T2 } ⫢ u2 : U [[:Tyu2]]
----------------- :: PatS {{ com $\ottstype{\oplus}$E }}
P1 + P2 ⫢ t ►case ¹ν { Inl x1 ⟼ u1 , Inr x2 ⟼ u2 } : U

P1 ⫢ t : T1 ⨂ T2 [[:Tyt]]
P2, { x1 : ˥ T1 }, { x2 : ˥ T2 } ⫢ u : U [[:Tyu]]
----------------- :: PatP {{ com $\ottstype{\otimes}$E }}
P1 + P2 ⫢ t ►case ¹ν (x1 , x2) ⟼ u : U

P1 ⫢ t : !n T [[:Tyt]]
P2, { x : n T } ⫢ u : U [[:Tyu]]
----------------- :: PatE {{ com $\ottstype{!}$E }}
P1 + P2 ⫢ t ►case ¹ν ᴇ n x ⟼ u : U

defn
P ⟚ t : T :: :: LinDeepMod_Ty_term :: 'LinDeepMod_Ty_term_' {{ com Typing judgment for terms }} by

P1 ⟚ t : T1 ⨁ T2 [[:Tyt]]
P2, { x1 : m T1 } ⟚ u1 : U [[:Tyu1]]
P2, { x2 : m T2 } ⟚ u2 : U [[:Tyu2]]
----------------- :: PatS {{ com $\ottstype{\oplus}$E }}
m·P1 + P2 ⟚ t ►case m { Inl x1 ⟼ u1 , Inr x2 ⟼ u2 } : U

P1 ⟚ t : T1 ⨂ T2 [[:Tyt]]
P2, { x1 : m T1 }, { x2 : m T2 } ⟚ u : U [[:Tyu]]
----------------- :: PatP {{ com $\ottstype{\otimes}$E }}
m·P1 + P2 ⟚ t ►case m (x1 , x2) ⟼ u : U

P1 ⟚ t : !n T [[:Tyt]]
P2, { x : m·n T } ⟚ u : U [[:Tyu]]
----------------- :: PatE {{ com $\ottstype{!}$E }}
m·P1 + P2 ⟚ t ►case m ᴇ n x ⟼ u : U

% defns
% Sem :: '' ::=

% % If ectx composition is not a meta instruction but a syntactic rule for context formation, then all unfoc rules can be merged as a single "pop & reform term" instruction ?
% % Not really for Close_Ampar because it is transformed back to a closed ampar instead of just being ectx substitution.

% % We want theorem that C[t] -->* C[v] where englobing context doesn't change?

% defn
% C [ t ] ⟶ C' [ t' ] :: :: Sem :: '' {{ com Small-step evaluation of commands }} {{ tex [[C]]\biggerbrackl [[t]] \biggerbrackr[[⟶]][[C']]\biggerbrackl [[t']] \biggerbrackr }} by

% {{ NotVal [[t]] }} [[:NotValt]]
% ----------------------------- :: Focus_App1
% C[t' t] ⟶ (C ∘ (t' ⬜))[t]

% ----------------------------- :: Unfocus_App1
% (C ∘ (t' ⬜))[v] ⟶ C[t' v]

% {{ NotVal [[t']] }} [[:NotValtp]]
% ----------------------------- :: Focus_App2
% C[t' v] ⟶ (C ∘ (⬜ v))[t']

% ----------------------------- :: Unfocus_App2
% (C ∘ (⬜ v))[v'] ⟶ C[v' v]

% ------------------ :: Red_App
% C[(ᵛλ x m ⟼ u) v] ⟶ C[u[x ≔ v] ]

% {{ NotVal [[t]] }} [[:NotValt]]
% ----------------------- :: Focus_PatU
% C[t ; u] ⟶ (C ∘ (⬜ ; u))[t]

% ----------------------- :: Unfocus_PatU
% (C ∘ (⬜ ; u))[v] ⟶ C[v ; u]

% ----------------------- :: Red_PatU
% C[() ; u] ⟶ C[u]

% {{ NotVal [[t]] }} [[:NotValt]]
% ----------------------- :: Focus_PatS
% C[t ►case m { Inl x1 ⟼ u1, Inr x2 ⟼ u2 }] ⟶ (C ∘ (⬜ ►case m { Inl x1 ⟼ u1, Inr x2 ⟼ u2 }))[t]

% ----------------------- :: Unfocus_PatS
% (C ∘ (⬜ ►case m { Inl x1 ⟼ u1, Inr x2 ⟼ u2 }))[v] ⟶ C[v ►case m { Inl x1 ⟼ u1, Inr x2 ⟼ u2 }]

% ----------------------- :: Red_PatL
% C[(Inl v1) ►case m { Inl x1 ⟼ u1, Inr x2 ⟼ u2 }] ⟶ C[u1[x1 ≔ v1] ]

% ----------------------- :: Red_PatR
% C[(Inr v2) ►case m { Inl x1 ⟼ u1, Inr x2 ⟼ u2 }] ⟶ C[u2[x2 ≔ v2] ]

% {{ NotVal [[t]] }} [[:NotValt]]
% ----------------------- :: Focus_PatP
% C[t ►case m (x1,x2) ⟼ u] ⟶ (C ∘ (⬜ ►case m (x1,x2) ⟼ u))[t]

% ----------------------- :: Unfocus_PatP
% (C ∘ (⬜ ►case m (x1,x2) ⟼ u))[v] ⟶ C[v ►case m (x1,x2) ⟼ u]

% ----------------------- :: Red_PatP
% C[(v1, v2) ►case m (x1,x2) ⟼ u] ⟶ C[u[x1 ≔ v1][x2 ≔ v2] ]

% {{ NotVal [[t]] }} [[:NotValt]]
% ----------------------- :: Focus_PatE
% C[t ►case m ᴇ n x ⟼ u] ⟶ (C ∘ (⬜ ►case m ᴇ n x ⟼ u))[t]

% ----------------------- :: Unfocus_PatE
% (C ∘ (⬜ ►case m ᴇ n x ⟼ u))[v] ⟶ C[v ►case m ᴇ n x ⟼ u]

% ----------------------- :: Red_PatE
% C[ᴇ n v' ►case m ᴇ n x ⟼ u] ⟶ C[u[x ≔ v'] ]

% {{ NotVal [[t]] }} [[:NotValt]]
% ----------------------- :: Focus_Map
% C[t ►map x ⟼ t'] ⟶ (C ∘ (⬜ ►map x ⟼ t'))[t]

% ----------------------- :: Unfocus_Map
% (C ∘ (⬜ ►map x ⟼ t'))[v] ⟶ C[v ►map x ⟼ t']

% {{ [[h''']] = [[max(H ∪ hnames(C)) + 1]] }} [[:hpMaxC]]
% ---------------------------------- :: Open_Ampar
% C[ H ⟨ v2 ❟ v1 ⟩ ►map x ⟼ t'] ⟶ (C ∘ (H⩲h''' ᵒᵖ⟨ v2[H⩲h'''] ❟ ⬜⟩))[ t'[x ≔ v1[H⩲h'''] ] ]

% ---------------------------------- :: Close_Ampar
% (C ∘ H ᵒᵖ⟨ v2 ❟ ⬜⟩)[v1] ⟶ C[ H ⟨ v2 ❟ v1 ⟩ ]

% % -------------------------- :: Red_Alloc
% % C[alloc] ⟶ C[{1} ⟨ +1 ❟ -1 ⟩]

% {{ NotVal [[u]] }} [[:NotValu]]
% -------------------------- :: Focus_ToA
% C[to⧔ u] ⟶ (C ∘ (to⧔ ⬜))[u]

% % No shape control here, so could be totally merged with Red_ToA
% -------------------------- :: Unfocus_ToA
% (C ∘ (to⧔ ⬜))[v2] ⟶ C[to⧔ v2]

% ----------------------------------------- :: Red_ToA
% C[to⧔ v2] ⟶ C[{} ⟨ v2 ❟ () ⟩]

% {{ NotVal [[t]] }} [[:NotValt]]
% -------------------------- :: Focus_FromA
% C[from⧔ t] ⟶ (C ∘ (from⧔ ⬜))[t]

% -------------------------- :: Unfocus_FromA
% (C ∘ (from⧔ ⬜))[v] ⟶ C[from⧔ v]

% -------------------------------------- :: Red_FromA
% C[from⧔ {} ⟨ v2 ❟ ᴇ ¹∞ v1 ⟩] ⟶ C[(v2, ᴇ ¹∞ v1)]

% -------------------------------------- :: Red_Alloc
% C[alloc] ⟶ C[{1} ⟨ +1 ❟ -1 ⟩]

% {{ NotVal [[t]] }} [[:NotValt]]
% -------------------------- :: Focus_FillU
% C[t ⨞ ()] ⟶ (C ∘ (⬜ ⨞ () ))[t]

% -------------------------- :: Unfocus_FillU
% (C ∘ (⬜ ⨞ () ))[v] ⟶ C[v ⨞ ()]

% ------------------------------------- :: Red_FillU
% C[-h ⨞ ()] ⟶ C[h ≔ {} ()][()]

% {{ NotVal [[t]] }} [[:NotValt]]
% ------------------------------------- :: Focus_FillL
% C[t ⨞ Inl] ⟶ (C ∘ (⬜ ⨞ Inl))[t]

% ------------------------------------- :: Unfocus_FillL
% (C ∘ (⬜ ⨞ Inl))[v] ⟶ C[v ⨞ Inl]

% {{ [[h']] = [[max(hnames(C) ∪ {h}) + 1]] }} [[:hpMaxCh]]
% --------------------------------------- :: Red_FillL
% C[-h ⨞ Inl] ⟶ C[h ≔ {h'+1} Inl  +(h'+1)][-(h'+1)]

% {{ NotVal [[t]] }} [[:NotValt]]
% ------------------------------------- :: Focus_FillR
% C[t ⨞ Inr] ⟶ (C ∘ (⬜ ⨞ Inr))[t]

% ------------------------------------- :: Unfocus_FillR
% (C ∘ (⬜ ⨞ Inr))[v] ⟶ C[v ⨞ Inr]

% {{ [[h']] = [[max(hnames(C) ∪ {h}) + 1]] }} [[:hpMaxCh]]
% --------------------------------------- :: Red_FillR
% C[-h ⨞ Inr] ⟶ C[h ≔ {h'+1} Inr  +(h'+1)][-(h'+1)]

% {{ NotVal [[t]] }} [[:NotValt]]
% ------------------------------------- :: Focus_FillE
% C[t ⨞ ᴇ m] ⟶ (C ∘ (⬜ ⨞ ᴇ m))[t]

% ------------------------------------- :: Unfocus_FillE
% (C ∘ (⬜ ⨞ ᴇ m))[v] ⟶ C[v ⨞ ᴇ m]

% {{ [[h']] = [[max(hnames(C) ∪ {h}) + 1]] }} [[:hpMaxCh]]
% --------------------------------------- :: Red_FillE
% C[-h ⨞ ᴇ m] ⟶ C[h ≔ {h'+1} ᴇ m  +(h'+1)][-(h'+1)]

% {{ NotVal [[t]] }} [[:NotValt]]
% ------------------------------------- :: Focus_FillP
% C[t ⨞ (,)] ⟶ (C ∘ (⬜ ⨞ (,)))[t]

% ------------------------------------- :: Unfocus_FillP
% (C ∘ (⬜ ⨞ (,)))[v] ⟶ C[v ⨞ (,)]

% {{ [[h']] = [[max(hnames(C) ∪ {h}) + 1]] }} [[:hpMaxCh]]
% --------------------------------------- :: Red_FillP
% C[-h ⨞ (,)] ⟶ C[h ≔ {h'+1,h'+2} ( +(h'+1), +(h'+2))][( -(h'+1), -(h'+2) )]

% {{ NotVal [[t]] }} [[:NotValt]]
% ------------------------------------- :: Focus_FillF
% C[t ⨞(λ x m ⟼ u)] ⟶ (C ∘ (⬜ ⨞(λ x m ⟼ u)))[t]

% ------------------------------------- :: Unfocus_FillF
% (C ∘ (⬜ ⨞(λ x m ⟼ u)))[v] ⟶ C[v ⨞(λ x m ⟼ u)]

% ------------------------------------- :: Red_FillF
% C[-h ⨞ (λ x m ⟼ u)] ⟶ C[h ≔ {} ᵛλ x m ⟼ u][()]

% {{ NotVal [[t]] }} [[:NotValt]]
% ------------------------------------- :: Focus_FillComp1
% C[t ⨞· t'] ⟶ (C ∘ (⬜ ⨞· t'))[t]

% ------------------------------------- :: Unfocus_FillComp1
% (C ∘ (⬜ ⨞· t'))[v] ⟶ C[v ⨞· t']

% {{ NotVal [[t']] }} [[:NotValtp]]
% ------------------------------------- :: Focus_FillComp2
% C[v ⨞· t'] ⟶ (C ∘ (v ⨞· ⬜))[t']

% ------------------------------------- :: Unfocus_FillComp2
% (C ∘ (v ⨞· ⬜))[v'] ⟶ C[v ⨞· v']

% {{ [[h'']] = [[max(H ∪ (hnames(C) ∪ {h})) + 1]] }} [[:hpMaxCh]]
% ---------------------------------------- :: Red_FillComp
% C[-h ⨞· H ⟨ v2 ❟ v1 ⟩] ⟶ C[h ≔ (H⩲h'') v2[H⩲h''] ][v1[H⩲h''] ]

% {{ NotVal [[t]] }} [[:NotValt]]
% ------------------------------------- :: Focus_FillLeaf1
% C[t ◀ t'] ⟶ (C ∘ (⬜ ◀ t'))[t]

% ------------------------------------- :: Unfocus_FillLeaf1
% (C ∘ (⬜ ◀ t'))[v] ⟶ C[v ◀ t']

% {{ NotVal [[t']] }} [[:NotValtp]]
% ------------------------------------- :: Focus_FillLeaf2
% C[v ◀ t'] ⟶ (C ∘ (v ◀ ⬜))[t']

% ------------------------------------- :: Unfocus_FillLeaf2
% (C ∘ (v ◀ ⬜))[v'] ⟶ C[v ◀ v']

% ---------------------------------------- :: Red_FillLeaf
% C[-h ◀ v] ⟶ C[h ≔ {} v ][ () ]