@inproceedings{bagrel_destination-passing_2024,
  address     = {Saint-Jacut-de-la-Mer, France},
  author      = {Bagrel, Thomas},
  booktitle   = {{35es Journ{\'e}es Francophones des Langages Applicatifs (JFLA 2024)}},
  hal_id      = {hal-04406360},
  hal_version = {v1},
  month       = Jan,
  pdf         = {https://inria.hal.science/hal-04406360/file/jfla2024-paper-16.pdf},
  title       = {{Destination-passing style programming: a Haskell implementation}},
  url         = {https://inria.hal.science/hal-04406360},
  year        = {2024}
}

@inproceedings{shaikhha_destination-passing_2017,
  abstract  = {We show how to compile high-level functional array-processing programs, drawn from image processing and machine learning, into C code that runs as fast as hand-written C. The key idea is to transform the program to destination-passing style, which in turn enables a highly-efficient stack-like memory allocation discipline.},
  address   = {Oxford UK},
  author    = {Shaikhha, Amir and Fitzgibbon, Andrew and Peyton Jones, Simon and Vytiniotis, Dimitrios},
  booktitle = {Proceedings of the 6th {ACM} {SIGPLAN} {International} {Workshop} on {Functional} {High}-{Performance} {Computing}},
  doi       = {10.1145/3122948.3122949},
  isbn      = {978-1-4503-5181-2},
  keywords  = {destination, mutable},
  language  = {en},
  month     = sep,
  pages     = {12--23},
  publisher = {ACM},
  title     = {Destination-passing style for efficient memory management},
  url       = {https://dl.acm.org/doi/10.1145/3122948.3122949},
  urldate   = {2022-03-15},
  year      = {2017}
}

@inproceedings{minamide_functional_1998,
  abstract  = {Data structures with a hole, in other words data structures with an uninitialized field, are useful to write efficient programs: they enable us to construct functional data structures flexibly and write functions such as append and map as tail recursive functions. In this paper we present an approach to introducing data structures with a hole into call-by-value functional programming languages like ML. Data structures with a hole are formalized as a new form of λ-abstraction called hole abstraction. The novel features of hole abstraction are that expressions inside hole abstraction are evaluated and application is implemented by destructive update of a hole. We present a simply typed call-by-value λ-calculus extended with hole abstractions. Then we show a compilation method of hole abstraction and prove correctness of the compilation.},
  address   = {New York, NY, USA},
  author    = {Minamide, Yasuhiko},
  booktitle = {Proceedings of the 25th {ACM} {SIGPLAN}-{SIGACT} symposium on {Principles} of programming languages},
  doi       = {10.1145/268946.268953},
  isbn      = {978-0-89791-979-1},
  keywords  = {calculus, destination},
  month     = jan,
  pages     = {75--84},
  publisher = {Association for Computing Machinery},
  series    = {{POPL} '98},
  title     = {A functional representation of data structures with a hole},
  url       = {https://doi.org/10.1145/268946.268953},
  urldate   = {2022-03-15},
  year      = {1998}
}

@incollection{girard_linear_1995,
  address    = {Cambridge},
  author     = {Girard, J.-Y.},
  booktitle  = {Advances in {Linear} {Logic}},
  doi        = {10.1017/CBO9780511629150.002},
  editor     = {Girard, Jean-Yves and Lafont, Yves and Regnier, Laurent},
  isbn       = {978-0-511-62915-0},
  keywords   = {linear, logic},
  language   = {en},
  pages      = {1--42},
  publisher  = {Cambridge University Press},
  shorttitle = {Linear {Logic}},
  title      = {Linear {Logic}: its syntax and semantics},
  url        = {https://www.cambridge.org/core/product/identifier/CBO9780511629150A008/type/book_part},
  urldate    = {2022-03-21},
  year       = {1995}
}

@article{bour_tmc_2021,
  abstract = {OCaml function calls consume space on the system stack. Operating systems set default limits on the stack space which are much lower than the available memory. If a program runs out of stack space, they get the dreaded "Stack Overflow" exception -- they crash. As a result, OCaml programmers have to be careful, when they write recursive functions, to remain in the so-called \_tail-recursive\_ fragment, using \_tail\_ calls that do not consume stack space. This discipline is a source of difficulties for both beginners and experts. Beginners have to be taught recursion, and then tail-recursion. Experts disagree on the "right" way to write `List.map`. The direct version is beautiful but not tail-recursive, so it crashes on larger inputs. The naive tail-recursive transformation is (slightly) slower than the direct version, and experts may want to avoid that cost. Some libraries propose horrible implementations, unrolling code by hand, to compensate for this performance loss. In general, tail-recursion requires the programmer to manually perform sophisticated program transformations. In this work we propose an implementation of "Tail Modulo Cons" (TMC) for OCaml. TMC is a program transformation for a fragment of non-tail-recursive functions, that rewrites them in \_destination-passing style\_. The supported fragment is smaller than other approaches such as continuation-passing-style, but the performance of the transformed code is on par with the direct, non-tail-recursive version. Many useful functions that traverse a recursive datastructure and rebuild another recursive structure are in the TMC fragment, in particular `List.map` (and `List.filter`, `List.append`, etc.). Finally those functions can be written in a way that is beautiful, correct on all inputs, and efficient.},
  author   = {Bour, Frédéric and Clément, Basile and Scherer, Gabriel},
  journal  = {arXiv:2102.09823 [cs]},
  keywords = {caml, destination, mutable, tail-recursion},
  month    = feb,
  note     = {arXiv: 2102.09823},
  title    = {Tail {Modulo} {Cons}},
  url      = {http://arxiv.org/abs/2102.09823},
  urldate  = {2022-03-22},
  year     = {2021}
}

@inproceedings{yang_efficient_2015,
  abstract  = {In distributed applications, the transmission of non-contiguous data structures is greatly slowed down by the need to serialize them into a buffer before sending. We describe Compact Normal Forms, an API that allows programmers to explicitly place immutable heap objects into regions, which can both be accessed like ordinary data as well as efﬁciently transmitted over the network. The process of placing objects into compact regions (essentially a copy) is faster than any serializer and can be amortized over a series of functional updates to the data structure in question. We implement this scheme in the Glasgow Haskell Compiler and show that even with the space expansion attendant with memory-oriented data structure representations, we achieve between ×2 and ×4 speedups on fast local networks with sufﬁciently large data structures.},
  address   = {Vancouver BC Canada},
  author    = {Yang, Edward Z. and Campagna, Giovanni and Ağacan, Ömer S. and El-Hassany, Ahmed and Kulkarni, Abhishek and Newton, Ryan R.},
  booktitle = {Proceedings of the 20th {ACM} {SIGPLAN} {International} {Conference} on {Functional} {Programming}},
  doi       = {10.1145/2784731.2784735},
  isbn      = {978-1-4503-3669-7},
  keywords  = {compact-regions, memory, serialization},
  language  = {en},
  month     = aug,
  pages     = {362--374},
  publisher = {ACM},
  title     = {Efficient communication and collection with compact normal forms},
  url       = {https://dl.acm.org/doi/10.1145/2784731.2784735},
  urldate   = {2022-04-04},
  year      = {2015}
}

@article{bernardy_linear_2018,
  abstract   = {Linear type systems have a long and storied history, but not a clear path forward to integrate with existing languages such as OCaml or Haskell. In this paper, we study a linear type system designed with two crucial properties in mind: backwards-compatibility and code reuse across linear and non-linear users of a library. Only then can the benefits of linear types permeate conventional functional programming. Rather than bifurcate types into linear and non-linear counterparts, we instead attach linearity to function arrows. Linear functions can receive inputs from linearly-bound values, but can also operate over unrestricted, regular values. To demonstrate the efficacy of our linear type system - both how easy it can be integrated in an existing language implementation and how streamlined it makes it to write programs with linear types - we implemented our type system in GHC, the leading Haskell compiler, and demonstrate two kinds of applications of linear types: mutable data with pure interfaces; and enforcing protocols in I/O-performing functions.},
  author     = {Bernardy, Jean-Philippe and Boespflug, Mathieu and Newton, Ryan R. and Jones, Simon Peyton and Spiwack, Arnaud},
  doi        = {10.1145/3158093},
  issn       = {2475-1421},
  journal    = {Proceedings of the ACM on Programming Languages},
  keywords   = {Computer Science - Programming Languages},
  month      = jan,
  note       = {arXiv:1710.09756 [cs]},
  number     = {POPL},
  pages      = {1--29},
  shorttitle = {Linear {Haskell}},
  title      = {Linear {Haskell}: practical linearity in a higher-order polymorphic language},
  url        = {http://arxiv.org/abs/1710.09756},
  urldate    = {2022-06-23},
  volume     = {2},
  year       = {2018}
}

@inproceedings{gibbons_phases_2023,
  abstract  = {The large-scale structure of executing a computation can often be thought of as being separated into distinct phases. But the most natural form in which to specify that computation may well have a different and conflicting structure. For example, the computation might consist of gathering data from some locations, processing it, then distributing the results back to the same locations; it may be executed in three phases—gather, process, distribute—but mostly conveniently specified orthogonally—by location. We have recently shown that this multi-phase structure can be expressed as a novel applicative functor (also known as an idiom, or lax monoidal functor). Here we summarize the idea from the perspective of software architecture. At the end, we speculate about applications to choreography and multi-tier architecture.},
  address   = {Seattle WA USA},
  author    = {Gibbons, Jeremy and Kidney, Donnacha Oisín and Schrijvers, Tom and Wu, Nicolas},
  booktitle = {Proceedings of the 1st {ACM} {SIGPLAN} {International} {Workshop} on {Functional} {Software} {Architecture}},
  doi       = {10.1145/3609025.3609479},
  isbn      = {9798400702976},
  language  = {en},
  month     = aug,
  pages     = {29--33},
  publisher = {ACM},
  title     = {Phases in {Software} {Architecture}},
  url       = {https://dl.acm.org/doi/10.1145/3609025.3609479},
  urldate   = {2023-10-02},
  year      = {2023}
}

@inproceedings{protzenko_mezzo_2013,
  abstract  = {We present Mezzo, a typed programming language of ML lineage. Mezzo is equipped with a novel static discipline of duplicable and affine permissions, which controls aliasing and ownership. This rules out certain mistakes, including representation exposure and data races, and enables new idioms, such as gradual initialization, memory re-use, and (type)state changes. Although the core static discipline disallows sharing a mutable data structure, Mezzo offers several ways of working around this restriction, including a novel dynamic ownership control mechanism which we dub "adoption and abandon".},
  author    = {Protzenko, Jonathan and Pottier, François},
  booktitle = {Proceedings of the 18th {ACM} {SIGPLAN} international conference on {Functional} programming},
  doi       = {10.1145/2500365.2500598},
  keywords  = {Computer Science - Programming Languages, D.3.2},
  month     = sep,
  note      = {arXiv:1311.7242 [cs]},
  pages     = {173--184},
  title     = {Programming with {Permissions} in {Mezzo}},
  url       = {http://arxiv.org/abs/1311.7242},
  urldate   = {2023-10-16},
  year      = {2013}
}


@inproceedings{okasaki_bfs_2000,
  abstract   = {Every programmer has blind spots. Breadth-first numbering is an interesting toy problem that exposes a blind spot common to many---perhaps most---functional programmers.},
  address    = {New York, NY, USA},
  author     = {Okasaki, Chris},
  booktitle  = {Proceedings of the fifth {ACM} {SIGPLAN} international conference on {Functional} programming},
  doi        = {10.1145/351240.351253},
  file       = {Full Text PDF:/home/thomas/Zotero/storage/RWTQGQAF/Okasaki - 2000 - Breadth-first numbering lessons from a small exer.pdf:application/pdf},
  isbn       = {978-1-58113-202-1},
  keywords   = {Breadth-first numbering, breadth-first traversal, views},
  month      = sep,
  pages      = {131--136},
  publisher  = {Association for Computing Machinery},
  series     = {{ICFP} '00},
  shorttitle = {Breadth-first numbering},
  title      = {Breadth-first numbering: lessons from a small exercise in algorithm design},
  url        = {https://dl.acm.org/doi/10.1145/351240.351253},
  urldate    = {2023-10-12},
  year       = {2000}
}

@phdthesis{larus_restructuring_1989,
  abstract = {C scURARE, the program restructurer described in this dissertation, automatically transforms a sequential Lisp program into an equivalent concurrent program that executes on a multiprocessor. C scURARE first analyzes a program to find its control and data dependences. This analysis is most difficult for references to structures connected by pointers. C scURARE uses a new data-dependence algorithm, which finds and classifies these dependences. The analysis is conservative and may detect conflicts that do not arise in practice. A programmer can temper and refine its results with declarations. Dependences constrain the program's concurrent execution because, in general, two conflicting statements cannot execute in a different order without affecting the program's result. A restructurer must know all dependences in order to preserve them. However, not all dependences are essential to produce the program's result. C scURARE attempts to transform the program so it computes its result with fewer conflicts. An optimized program will execute with less synchronization and more concurrency. C scURARE then examines loops in a program to find those that are unconstrained or lightly constrained by dependences. By necessity, C scURARE treats recursive functions as loops and does not limit itself to explicit program loops. Recursive functions offer several advantages over explicit loops since they provide a convenient framework for inserting locks and handling the dynamic behavior of symbolic programs. Loops that are suitable for concurrent execution are changed to execute on a set of concurrent server processes. These servers execute single loop iterations and therefore need to be extremely inexpensive to invoke. Restructured programs execute significantly faster than the original sequential programs. This improvement is large enough to attract programmers to a multiprocessor, particularly since it requires little effort on their part. Although restructured programs may not make optimal use of a multiprocessor's parallelism, they make good use of a programmer's time.},
  author   = {Larus, James Richard},
  note     = {AAI9006407},
  school   = {University of California, Berkeley},
  title    = {Restructuring symbolic programs for concurrent execution on multiprocessors},
  type     = {phd},
  year     = {1989}
}

@article{spiwack_linearly_2022,
  abstract   = {A linear parameter must be consumed exactly once in the body of its function. When declaring resources such as file handles and manually managed memory as linear arguments, a linear type system can verify that these resources are used safely. However, writing code with explicit linear arguments requires bureaucracy. This paper presents linear constraints, a front-end feature for linear typing that decreases the bureaucracy of working with linear types. Linear constraints are implicit linear arguments that are filled in automatically by the compiler. We present linear constraints as a qualified type system,together with an inference algorithm which extends GHC's existing constraint solver algorithm. Soundness of linear constraints is ensured by the fact that they desugar into Linear Haskell.},
  author     = {Spiwack, Arnaud and Kiss, Csongor and Bernardy, Jean-Philippe and Wu, Nicolas and Eisenberg, Richard A.},
  doi        = {10.1145/3547626},
  journal    = {Proceedings of the ACM on Programming Languages},
  keywords   = {constraints, GHC, Haskell, inference, linear logic, linear types, qualified types},
  month      = aug,
  number     = {ICFP},
  pages      = {95:137--95:164},
  shorttitle = {Linearly qualified types},
  title      = {Linearly qualified types: generic inference for capabilities and uniqueness},
  url        = {https://dl.acm.org/doi/10.1145/3547626},
  urldate    = {2023-10-16},
  volume     = {6},
  year       = {2022}
}

@article{jones_gibbons_linearbfs_93,
  abstract   = {This paper is about an application of the mathematics of the zip, reduce (fold) and accumulate (scan) operations on lists. It gives an account of the derivation of a linear-time breadth-first tree traversal algorithm, and of a subtle and efficient breadth-first tree labelling algorithm.},
  author     = {Gibbons, Jeremy},
  language   = {en-gb},
  note       = {Number: No. 71},
  number     = {No. 71},
  shorttitle = {Linear-time {Breadth}-first {Tree} {Algorithms}},
  title      = {Linear-time {Breadth}-first {Tree} {Algorithms}: {An} {Exercise} in the {Arithmetic} of {Folds} and {Zips}},
  url        = {https://www.cs.ox.ac.uk/publications/publication2363-abstract.html},
  urldate    = {2023-10-18},
  year       = {1993}
}

@misc{custom_ghc,
  author       = {Bagrel, Thomas},
  howpublished = {\\Software Heritage,\\\href{https://archive.softwareheritage.org/swh:1:dir:84c7e717fd5f189c6b6222e0fc92d0a82d755e7c;origin=https://github.com/tweag/ghc;visit=swh:1:snp:141fa3c28e01574deebb6cc91693c75f49717c32;anchor=swh:1:rev:184f838b352a0d546e574bdeb83c8c190e9dfdc2}{\texttt{swh:1:dir:84c7e717fd5f189c6b6222e0fc92d0a82d755e7c;\\
                  origin=https://github.com/tweag/ghc;\\
                  visit=swh:1:snp:141fa3c28e01574deebb6cc91693c75f49717c32;\\
                  anchor=swh:1:rev:184f838b352a0d546e574bdeb83c8c190e9dfdc2}}},
  title        = {{GHC} with support for hollow constructor allocation},
  urldate      = {2023-10-19},
  year         = 2023
}

@misc{linear_dest,
  author       = {Bagrel, Thomas},
  howpublished = {Software Heritage,\\ \href{https://archive.softwareheritage.org/swh:1:rev:0e7db2e6b24aad348837ac78d8137712c1d8d12a;origin=https://github.com/tweag/linear-dest;visit=swh:1:snp:c0eb2661963bb176204b46788f4edd26f72ac83c}{\texttt{swh:1:rev:0e7db2e6b24aad348837ac78d8137712c1d8d12a;\\origin=https://github.com/tweag/linear-dest;\\visit=swh:1:snp:c0eb2661963bb176204b46788f4edd26f72ac83c}}},
  title        = {\texttt{linear-dest}, a {Haskell} library that adds supports for {DPS} programming},
  urldate      = {2023-10-19},
  year         = 2023
}

@inproceedings{launchbury_lazy_1994,
  abstract  = {Some algorithms make critical internal use of updatable state, even though their external specification is purely functional. Based on earlier work on monads, we present a way of securely encapsulating stateful computations that manipulate multiple, named, mutable objects, in the context of a non-strict, purely-functional language. The security of the encapsulation is assured by the type system, using parametricity. Intriguingly, this parametricity requires the provision of a (single) constant with a rank-2 polymorphic type.},
  address   = {New York, NY, USA},
  author    = {Launchbury, John and Peyton Jones, Simon L.},
  booktitle = {Proceedings of the {ACM} {SIGPLAN} 1994 conference on {Programming} language design and implementation},
  doi       = {10.1145/178243.178246},
  isbn      = {978-0-89791-662-2},
  month     = jun,
  pages     = {24--35},
  publisher = {Association for Computing Machinery},
  series    = {{PLDI} '94},
  title     = {Lazy functional state threads},
  url       = {https://dl.acm.org/doi/10.1145/178243.178246},
  urldate   = {2023-12-11},
  year      = {1994}
}


@article{lorenzen_fp_2023,
  abstract   = {As functional programmers we always face a dilemma: should we write purely  
                functional code, or sacrifice purity for efficiency and resort to in-place  
                updates? This paper identifies precisely when we can have the best of both  
                worlds: a wide class of purely functional programs can be executed safely using  
                in-place updates without requiring allocation, provided their arguments are not  
                shared elsewhere.
                We describe a linear \_fully in-place\_ (FIP) calculus where we prove that we can  
                always execute such functions in a way that requires no (de)allocation and uses  
                constant stack space. Of course, such a calculus is only relevant if we can  
                express interesting algorithms; we provide numerous examples of in-place  
                functions on datastructures such as splay trees or finger trees, together with  
                in-place versions of merge sort and quick sort.
                We also show how we can generically derive a map function over \_any\_ polynomial  
                data type that is fully in-place. Finally, we have implemented the rules of the  
                FIP calculus in the Koka language. Using the Perceus reference counting garbage  
                collection, this implementation dynamically executes FIP functions in-place  
                whenever possible.},
  author     = {Lorenzen, Anton and Leijen, Daan and Swierstra, Wouter},
  doi        = {10.1145/3607840},
  issn       = {2475-1421},
  journal    = {Proceedings of the ACM on Programming Languages},
  language   = {en},
  month      = aug,
  number     = {ICFP},
  pages      = {275--304},
  shorttitle = {{FP}$^2$},
  title      = {{FP}$^2$: {Fully} in-{Place} {Functional} {Programming}},
  url        = {https://dl.acm.org/doi/10.1145/3607840},
  urldate    = {2023-12-11},
  volume     = {7},
  year       = {2023}
}


@article{leijen_trmc_2023,
  abstract   = {The tail-recursion modulo
                cons
                transformation can rewrite functions that are not quite tail-recursive into a tail-recursive form that can be executed efficiently. In this article we generalize tail recursion modulo
                cons
                (TRMc) to modulo
                contexts
                (TRMC), and calculate a general TRMC algorithm from its specification. We can instantiate our general algorithm by providing an implementation of application and composition on abstract contexts, and showing that our
                context
                laws\_ hold. We provide some known instantiations of TRMC, namely modulo
                evaluation contexts
                (CPS), and
                associative operations
                , and further instantiantions not so commonly associated with TRMC, such as
                defunctionalized
                evaluation contexts,
                monoids
                ,
                semirings
                ,
                exponents
                , and
                cons products
                . We study the modulo
                cons
                instantiation in particular and prove that an instantiation using Minamide’s hole calculus is sound. We also calculate a second instantiation in terms of the Perceus heap semantics to precisely reason about the soundness of in-place update. While all previous approaches to TRMc fail in the presence of non-linear control (for example induced by call/cc, shift/reset or algebraic effect handlers), we can elegantly extend the heap semantics to a hybrid approach which dynamically adapts to non-linear control flow. We have a full implementation of hybrid TRMc in the Koka language and our benchmark shows the TRMc transformed functions are always as fast or faster than using manual alternatives.},
  author     = {Leijen, Daan and Lorenzen, Anton},
  doi        = {10.1145/3571233},
  issn       = {2475-1421},
  journal    = {Proceedings of the ACM on Programming Languages},
  language   = {en},
  month      = jan,
  number     = {POPL},
  pages      = {1152--1181},
  shorttitle = {Tail {Recursion} {Modulo} {Context}},
  title      = {Tail {Recursion} {Modulo} {Context}: {An} {Equational} {Approach}},
  url        = {https://dl.acm.org/doi/10.1145/3571233},
  urldate    = {2024-01-25},
  volume     = {7},
  year       = {2023}
}

@article{bernardy_modality_2020,
  abstract   = {We propose to unify the treatment of a broad range of modalities in typed lambda calculi. We do so by defining a generic structure of modalities, and show that this structure arises naturally from the structure of intuitionistic logic, and as such finds instances in a wide range of type systems previously described in literature. Despite this generality, this structure has a rich metatheory, which we expose.},
  address    = {New York, NY, USA},
  articleno  = {90},
  author     = {Abel, Andreas and Bernardy, Jean-Philippe},
  doi        = {10.1145/3408972},
  issue_date = {August 2020},
  journal    = {Proc. ACM Program. Lang.},
  keywords   = {linear types, modal logic, subtyping},
  month      = {aug},
  number     = {ICFP},
  numpages   = {28},
  publisher  = {Association for Computing Machinery},
  title      = {A unified view of modalities in type systems},
  url        = {https://doi.org/10.1145/3408972},
  volume     = {4},
  year       = {2020}
}

@inproceedings{sewell_ott_2007,
  abstract  = {It is rare to give a semantic definition of a full-scale programming language, despite the many potential benefits. Partly this is because the available metalanguages for expressing semantics - usually either L<scp>a</scp>TEX for informal mathematics, or the formal mathematics of a proof assistant - make it much harder than necessary to work with large definitions.We present a metalanguage specifically designed for this problem, and a tool, ott, that sanity-checks such definitions and compiles them into proof assistant code for Coq, HOL, Isabelle, and (in progress) Twelf, together with L<scp>a</scp>TEX code for production-quality typesetting, and OCaml boilerplate. The main innovations are:(1) metalanguage design to make definitions concise, and easy to read and edit;(2) an expressive but intuitive metalanguage for specifying binding structures; and (3) compilation to proof assistant code.This has been tested in substantial case studies, including modular specifications of calculi from the TAPL text, a Lightweight Java with Java JSR 277/294 module system proposals, and a large fragment of OCaml (around 306 rules), with machine proofs of various soundness results. Our aim with this work is to enable a phase change: making it feasible to work routinely, without heroic effort, with rigorous semantic definitions of realistic languages.},
  address   = {New York, NY, USA},
  author    = {Sewell, Peter and Nardelli, Francesco Zappa and Owens, Scott and Peskine, Gilles and Ridge, Thomas and Sarkar, Susmit and Strni\v{s}a, Rok},
  booktitle = {Proceedings of the 12th ACM SIGPLAN International Conference on Functional Programming},
  doi       = {10.1145/1291151.1291155},
  isbn      = {9781595938152},
  location  = {Freiburg, Germany},
  numpages  = {12},
  pages     = {1–12},
  publisher = {Association for Computing Machinery},
  series    = {ICFP '07},
  title     = {Ott: effective tool support for the working semanticist},
  url       = {https://doi.org/10.1145/1291151.1291155},
  year      = {2007}
}


@misc{nardelli_nameless_2009,
  author  = {Nardelli, Francesco Zappa},
  month   = mar,
  title   = {Locally nameless backend for {Ott}},
  type    = {Blog post},
  url     = {https://fzn.fr/projects/ln_ott/},
  urldate = {2024-07-08},
  year    = {2009}
}

@inproceedings{deyoung_sax_2020,
  address   = {Dagstuhl, Germany},
  annote    = {Keywords: Sequent calculus, Curry-Howard isomorphism, shared memory concurrency},
  author    = {DeYoung, Henry and Pfenning, Frank and Pruiksma, Klaas},
  booktitle = {5th International Conference on Formal Structures for Computation and Deduction (FSCD 2020)},
  doi       = {10.4230/LIPIcs.FSCD.2020.29},
  editor    = {Ariola, Zena M.},
  isbn      = {978-3-95977-155-9},
  issn      = {1868-8969},
  pages     = {29:1--29:22},
  publisher = {Schloss Dagstuhl -- Leibniz-Zentrum f{\"u}r Informatik},
  series    = {Leibniz International Proceedings in Informatics (LIPIcs)},
  title     = {{Semi-Axiomatic Sequent Calculus}},
  url       = {https://drops.dagstuhl.de/entities/document/10.4230/LIPIcs.FSCD.2020.29},
  urn       = {urn:nbn:de:0030-drops-123515},
  volume    = {167},
  year      = {2020}
}

@article{hughes_dlist_1986,
  author  = {Hughes, John},
  journal = {Inf. Process. Lett.},
  month   = {01},
  pages   = {141-144},
  title   = {A Novel Representation of Lists and its Application to the Function "reverse".},
  volume  = {22},
  year    = {1986}
}


@article{hood_queue_1981,
  author   = {Hood, Robert and Melville, Robert},
  doi      = {https://doi.org/10.1016/0020-0190(81)90030-2},
  issn     = {0020-0190},
  journal  = {Information Processing Letters},
  keywords = {Lisp, real-time queue},
  number   = {2},
  pages    = {50--54},
  title    = {Real-time queue operations in pure {LISP}},
  url      = {https://www.sciencedirect.com/science/article/pii/0020019081900302},
  volume   = {13},
  year     = {1981}
}

@article{granule_2019,
  abstract   = {In programming, some data acts as a resource (e.g., file handles, channels) subject to usage constraints. This poses a challenge to software correctness as most languages are agnostic to constraints on data. The approach of linear types provides a partial remedy, delineating data into resources to be used but never copied or discarded, and unconstrained values. Bounded Linear Logic provides a more fine-grained approach, quantifying non-linear use via an indexed-family of modalities. Recent work on coeffect types generalises this idea to graded comonads, providing type systems which can capture various program properties. Here, we propose the umbrella notion of graded modal types, encompassing coeffect types and dual notions of type-based effect reasoning via graded monads. In combination with linear and indexed types, we show that graded modal types provide an expressive type theory for quantitative program reasoning, advancing the reach of type systems to capture and verify a broader set of program properties. We demonstrate this approach via a type system embodied in a fully-fledged functional language called Granule, exploring various examples.},
  address    = {New York, NY, USA},
  articleno  = {110},
  author     = {Orchard, Dominic and Liepelt, Vilem-Benjamin and Eades III, Harley},
  doi        = {10.1145/3341714},
  issue_date = {August 2019},
  journal    = {Proc. ACM Program. Lang.},
  keywords   = {linear types, implementation, graded modal types, coeffects},
  month      = {jul},
  number     = {ICFP},
  numpages   = {30},
  publisher  = {Association for Computing Machinery},
  title      = {Quantitative program reasoning with graded modal types},
  url        = {https://doi.org/10.1145/3341714},
  volume     = {3},
  year       = {2019}
}

@inproceedings{qtt_2018,
  abstract  = {We present Quantitative Type Theory, a Type Theory that records usage information for each variable in a judgement, based on a previous system by McBride. The usage information is used to give a realizability semantics using a variant of Linear Combinatory Algebras, refining the usual realizability semantics of Type Theory by accurately tracking resource behaviour. We define the semantics in terms of Quantitative Categories with Families, a novel extension of Categories with Families for modelling resource sensitive type theories.},
  address   = {New York, NY, USA},
  author    = {Atkey, Robert},
  booktitle = {Proceedings of the 33rd Annual ACM/IEEE Symposium on Logic in Computer Science},
  doi       = {10.1145/3209108.3209189},
  isbn      = {9781450355834},
  keywords  = {Linear Logic, Type Theory},
  location  = {Oxford, United Kingdom},
  numpages  = {10},
  pages     = {56–65},
  publisher = {Association for Computing Machinery},
  series    = {LICS '18},
  title     = {Syntax and Semantics of Quantitative Type Theory},
  url       = {https://doi.org/10.1145/3209108.3209189},
  year      = {2018}
}

@article{lorenzen_searchtree_2024,
  abstract   = {Algorithms on restructuring binary search trees are typically 
                presented in imperative pseudocode. Understandably so, as their 
                performance relies on in-place execution, rather than the repeated 
                allocation of fresh nodes in memory. Unfortunately, these imperative 
                algorithms are notoriously difficult to verify as their loop 
                invariants must relate the unfinished tree fragments being 
                rebalanced. This paper presents several novel functional algorithms 
                for accessing and inserting elements in a restructuring binary search 
                tree that are as fast as their imperative counterparts; yet the 
                correctness of these functional algorithms is established using a 
                simple inductive argument. For each data structure, move-to-root, 
                splay, and zip trees, this paper describes both a bottom-up 
                algorithm using zippers and a top-down algorithm using a novel 
                first-class constructor context primitive. 
                The functional and imperative algorithms are equivalent: 
                we mechanise the proofs establishing this in the Coq 
                proof assistant using the Iris framework. This yields a first fully 
                verified implementation of well known algorithms on binary search trees with 
                performance on par with the fastest implementations in C.},
  address    = {New York, NY, USA},
  articleno  = {168},
  author     = {Lorenzen, Anton and Leijen, Daan and Swierstra, Wouter and Lindley, Sam},
  doi        = {10.1145/3656398},
  issue_date = {June 2024},
  journal    = {Proc. ACM Program. Lang.},
  keywords   = {FBIP, FIP, Splay Trees, Tail Recursion Modulo Cons, Zip Trees, Zippers},
  month      = {jun},
  number     = {PLDI},
  numpages   = {25},
  publisher  = {Association for Computing Machinery},
  title      = {The Functional Essence of Imperative Binary Search Trees},
  url        = {https://doi.org/10.1145/3656398},
  volume     = {8},
  year       = {2024}
}

@inproceedings{herbelin_curien_2000,
  abstract  = {We present the μ -calculus, a syntax for λ-calculus + control operators exhibiting symmetries such as program/context and call-by-name/call-by-value. This calculus is derived from implicational Gentzen's sequent calculus LK, a key classical logical system in proof theory. Under the Curry-Howard correspondence between proofs and programs, we can see LK, or more precisely a formulation called LKμ , as a syntax-directed system of simple types for μ -calculus. For μ -calculus, choosing a call-by-name or call-by-value discipline for reduction amounts to choosing one of the two possible symmetric orientations of a critical pair. Our analysis leads us to revisit the question of what is a natural syntax for call-by-value functional computation. We define a translation of λμ-calculus into μ -calculus and two dual translations back to λ-calculus, and we recover known CPS translations by composing these translations.},
  address   = {New York, NY, USA},
  author    = {Curien, Pierre-Louis and Herbelin, Hugo},
  booktitle = {Proceedings of the Fifth ACM SIGPLAN International Conference on Functional Programming},
  doi       = {10.1145/351240.351262},
  isbn      = {1581132026},
  numpages  = {11},
  pages     = {233–243},
  publisher = {Association for Computing Machinery},
  series    = {ICFP '00},
  title     = {The duality of computation},
  url       = {https://doi.org/10.1145/351240.351262},
  year      = {2000}
}


@article{abramsky_interpretation_lin_1993,
	title = {Computational interpretations of linear logic},
	volume = {111},
	issn = {0304-3975},
	url = {https://www.sciencedirect.com/science/article/pii/030439759390181R},
	doi = {10.1016/0304-3975(93)90181-R},
	abstract = {We study Girard's linear logic from the point of view of giving a concrete computational interpretation of the logic, based on the Curry—Howard isomorphism. In the case of Intuitionistic linear logic, this leads to a refinement of the lambda calculus, giving finer control over order of evaluation and storage allocation, while maintaining the logical content of programs as proofs, and computation as cut-elimination. In the classical case, it leads to a concurrent process paradigm with an operational semantics in the style of Berry and Boudol's chemical abstract machine. This opens up a promising new approach to the parallel implementation of functional programming languages; and offers the prospect of typed concurrent programming in which correctness is guaranteed by the typing.},
	number = {1},
	urldate = {2024-11-18},
	journal = {Theoretical Computer Science},
	author = {Abramsky, Samson},
	month = apr,
	year = {1993},
	pages = {3--57},
	file = {ScienceDirect Full Text PDF:/home/thomas/Zotero/storage/WC5846Z4/Abramsky - 1993 - Computational interpretations of linear logic.pdf:application/pdf;ScienceDirect Snapshot:/home/thomas/Zotero/storage/4DQGV66G/030439759390181R.html:text/html},
}

@incollection{pfenning_linear_2001,
	address = {Carnegie Mellon University, School of Computer Science},
	title = {Linear $\lambda$-{Calculus}},
	url = {https://www.cs.cmu.edu/~fp/courses/15816-f01/handouts/linlam.pdf},
	number = {6},
	urldate = {2024-11-18},
	booktitle = {15-816 {Linear} {Logic}},
	author = {Pfenning, Frank},
	year = {2001},
	pages = {13},
	file = {PDF:/home/thomas/Zotero/storage/UDZN98AF/linlam.pdf:application/pdf},
}


@article{orchard_graded_modal_2019,
	title = {Quantitative program reasoning with graded modal types},
	volume = {3},
	url = {https://dl.acm.org/doi/10.1145/3341714},
	doi = {10.1145/3341714},
	abstract = {In programming, some data acts as a resource (e.g., file handles, channels) subject to usage constraints. This poses a challenge to software correctness as most languages are agnostic to constraints on data. The approach of linear types provides a partial remedy, delineating data into resources to be used but never copied or discarded, and unconstrained values. Bounded Linear Logic provides a more fine-grained approach, quantifying non-linear use via an indexed-family of modalities. Recent work on coeffect types generalises this idea to graded comonads, providing type systems which can capture various program properties. Here, we propose the umbrella notion of graded modal types, encompassing coeffect types and dual notions of type-based effect reasoning via graded monads. In combination with linear and indexed types, we show that graded modal types provide an expressive type theory for quantitative program reasoning, advancing the reach of type systems to capture and verify a broader set of program properties. We demonstrate this approach via a type system embodied in a fully-fledged functional language called Granule, exploring various examples.},
	number = {ICFP},
	urldate = {2024-12-05},
	journal = {Language implementation for Quantitative Program Reasoning with Graded Modal Types},
	author = {Orchard, Dominic and Liepelt, Vilem-Benjamin and Eades III, Harley},
	month = jul,
	year = {2019},
	pages = {110:1--110:30},
	file = {Full Text PDF:/home/thomas/Zotero/storage/8RRX9XDW/Orchard et al. - 2019 - Quantitative program reasoning with graded modal types.pdf:application/pdf},
}

@inproceedings{atkey_quant_type_2018,
	address = {New York, NY, USA},
	series = {{LICS} '18},
	title = {Syntax and {Semantics} of {Quantitative} {Type} {Theory}},
	isbn = {978-1-4503-5583-4},
	url = {https://dl.acm.org/doi/10.1145/3209108.3209189},
	doi = {10.1145/3209108.3209189},
	abstract = {We present Quantitative Type Theory, a Type Theory that records usage information for each variable in a judgement, based on a previous system by McBride. The usage information is used to give a realizability semantics using a variant of Linear Combinatory Algebras, refining the usual realizability semantics of Type Theory by accurately tracking resource behaviour. We define the semantics in terms of Quantitative Categories with Families, a novel extension of Categories with Families for modelling resource sensitive type theories.},
	urldate = {2024-12-05},
	booktitle = {Proceedings of the 33rd {Annual} {ACM}/{IEEE} {Symposium} on {Logic} in {Computer} {Science}},
	publisher = {Association for Computing Machinery},
	author = {Atkey, Robert},
	month = jul,
	year = {2018},
	pages = {56--65},
	file = {Full Text PDF:/home/thomas/Zotero/storage/W28HNPNW/Atkey - 2018 - Syntax and Semantics of Quantitative Type Theory.pdf:application/pdf},
}

@article{abel_unified_modal_2020,
	title = {A unified view of modalities in type systems},
	volume = {4},
	url = {https://dl.acm.org/doi/10.1145/3408972},
	doi = {10.1145/3408972},
	abstract = {We propose to unify the treatment of a broad range of modalities in typed lambda calculi. We do so by defining a generic structure of modalities, and show that this structure arises naturally from the structure of intuitionistic logic, and as such finds instances in a wide range of type systems previously described in literature. Despite this generality, this structure has a rich metatheory, which we expose.},
	number = {ICFP},
	urldate = {2024-12-05},
	journal = {Proc. ACM Program. Lang.},
	author = {Abel, Andreas and Bernardy, Jean-Philippe},
	month = aug,
	year = {2020},
	pages = {90:1--90:28},
	file = {Full Text PDF:/home/thomas/Zotero/storage/DVF7B59D/Abel et Bernardy - 2020 - A unified view of modalities in type systems.pdf:application/pdf},
}

@article{andreoli_linlog_1992,
	title = {Logic {Programming} with {Focusing} {Proofs} in {Linear} {Logic}},
	volume = {2},
	issn = {0955-792X},
	url = {https://doi.org/10.1093/logcom/2.3.297},
	doi = {10.1093/logcom/2.3.297},
	abstract = {The deep symmetry of linear logic [18] makes it suitable for providing abstract models of computation, free from implementation details which are, by nature, oriented and non-symmetrical. I propose here one such model, in the area of logic programming, where the basic computational priciple isComputation = Proof searchProofs cinsidered here are those of the Gentzen style sequent calculus for linear logic. However, proofs in this system may be redundant, in that two proofs canbe syntactically different although identical up to some irrelevant reordering or simplification of the applications of the inferences rules. This leads to an untractable proof search where the search procedure is forced to make costly choices whch turn out to be irrelevant. To overcome this problem, a subclass of proofs, called the ‘focusing’ proofs, which is both complete (any derivable formla in linear logic has a focusing proof) and tractable (many irrelevant choices in the search are eliminated when aimed at focusing proofs) is identified. The main constraint underlying the specificatuon of focusing proofs has been to preserve the symmetry of linear logic, which is its most salient feature. In particular, dual connectives have dual properties with respect to focusing proofsThen, a progrmming language, called LinLog, consisting of a fragment of linear logic, in which focussing proofs have a more compact form, is presented. Linlog deals with formulae which have a syntax similar to the of the definite clauses and goals of Horn logic, but the crucial difference here is that it allows clauses with multiple atoms in the head, connected by the ‘par’ (multiplicative disjuction). It is then shown that the syntyactic restriction induced by LinLog is not performed at the cost of any expressive power: a mapping from full linear logic to LinLog, preserving focusing proofs, and analogous to the normalization to clausal form for classical logic, is presented.},
	number = {3},
	urldate = {2024-12-05},
	journal = {Journal of Logic and Computation},
	author = {Andreoli, Jean-Marc},
	month = jun,
	year = {1992},
	pages = {297--347},
	file = {Full Text PDF:/home/thomas/Zotero/storage/WMF9HQ6L/ANDREOLI - 1992 - Logic Programming with Focusing Proofs in Linear Logic.pdf:application/pdf;Snapshot:/home/thomas/Zotero/storage/UGVVXM5E/1012743.html:text/html},
}


@article{girard_bounded_1992,
	title = {Bounded linear logic: a modular approach to polynomial-time computability},
	volume = {97},
	issn = {0304-3975},
	shorttitle = {Bounded linear logic},
	url = {https://www.sciencedirect.com/science/article/pii/030439759290386T},
	doi = {10.1016/0304-3975(92)90386-T},
	abstract = {Usual typed lambda-calculi yield input/output specifications; in this paper the authors show how to extend this paradigm to complexity specifications. This is achieved by means of a restricted version of linear logic in which the use of exponential connectives is bounded in advance. This bounded linear logic naturally involves polynomials in its syntax and dynamics. It is then proved that any functional term of appropriate type actually encodes a polynomial-time algorithm and that conversely any polynomial-time function can be obtained in this way.},
	number = {1},
	urldate = {2024-12-05},
	journal = {Theoretical Computer Science},
	author = {Girard, Jean-Yves and Scedrov, Andre and Scott, Philip J.},
	month = apr,
	year = {1992},
	pages = {1--66},
	file = {ScienceDirect Snapshot:/home/thomas/Zotero/storage/QACBJBYY/030439759290386T.html:text/html},
}

@inproceedings{ghica_bounded_2014,
	address = {Berlin, Heidelberg},
	title = {Bounded {Linear} {Types} in a {Resource} {Semiring}},
	isbn = {978-3-642-54833-8},
	doi = {10.1007/978-3-642-54833-8_18},
	abstract = {Bounded linear types have proved to be useful for automated resource analysis and control in functional programming languages. In this paper we introduce a bounded linear typing discipline on a general notion of resource which can be modeled in a semiring. For this type system we provide both a general type-inference procedure, parameterized by the decision procedure of the semiring equational theory, and a (coherent) categorical semantics. This could be a useful type-theoretic and denotational framework for resource-sensitive compilation, and it represents a generalization of several existing type systems. As a non-trivial instance, motivated by hardware compilation, we present a complex new application to calculating and controlling timing of execution in a (recursion-free) higher-order functional programming language with local store.},
	language = {en},
	booktitle = {Programming {Languages} and {Systems}},
	publisher = {Springer},
	author = {Ghica, Dan R. and Smith, Alex I.},
	editor = {Shao, Zhong},
	year = {2014},
	keywords = {Derivation Tree, Linear Logic, Resource Action, Type Inference, Type System},
	pages = {331--350},
	file = {Full Text PDF:/home/thomas/Zotero/storage/ZXE3WVI9/Ghica et Smith - 2014 - Bounded Linear Types in a Resource Semiring.pdf:application/pdf},
}

@inproceedings{petricek_coeffects_2014,
	address = {New York, NY, USA},
	series = {{ICFP} '14},
	title = {Coeffects: a calculus of context-dependent computation},
	isbn = {978-1-4503-2873-9},
	shorttitle = {Coeffects},
	url = {https://dl.acm.org/doi/10.1145/2628136.2628160},
	doi = {10.1145/2628136.2628160},
	abstract = {The notion of context in functional languages no longer refers just to variables in scope. Context can capture additional properties of variables (usage patterns in linear logics; caching requirements in dataflow languages) as well as additional resources or properties of the execution environment (rebindable resources; platform version in a cross-platform application). The recently introduced notion of coeffects captures the latter, whole-context properties, but it failed to capture fine-grained per-variable properties.We remedy this by developing a generalized coeffect system with annotations indexed by a coeffect shape. By instantiating a concrete shape, our system captures previously studied flat (whole-context) coeffects, but also structural (per-variable) coeffects, making coeffect analyses more useful. We show that the structural system enjoys desirable syntactic properties and we give a categorical semantics using extended notions of indexed comonad.The examples presented in this paper are based on analysis of established language features (liveness, linear logics, dataflow, dynamic scoping) and we argue that such context-aware properties will also be useful for future development of languages for increasingly heterogeneous and distributed platforms.},
	urldate = {2024-12-05},
	booktitle = {Proceedings of the 19th {ACM} {SIGPLAN} international conference on {Functional} programming},
	publisher = {Association for Computing Machinery},
	author = {Petricek, Tomas and Orchard, Dominic and Mycroft, Alan},
	month = aug,
	year = {2014},
	pages = {123--135},
	file = {Full Text PDF:/home/thomas/Zotero/storage/S637FPWR/Petricek et al. - 2014 - Coeffects a calculus of context-dependent computation.pdf:application/pdf},
}

@TechReport{bierman_linlog_phd_1994,
  author =	 {Bierman, G.M.},
  title = 	 {{On intuitionistic linear logic}},
  year = 	 1994,
  month = 	 aug,
  url = 	 {https://www.cl.cam.ac.uk/techreports/UCAM-CL-TR-346.pdf},
  institution =  {University of Cambridge, Computer Laboratory},
  doi = 	 {10.48456/tr-346},
  number = 	 {UCAM-CL-TR-346}
}


@article{danvy_refocusing_2004,
	title = {Refocusing in {Reduction} {Semantics}},
	volume = {11},
	issn = {1601-5355, 0909-0878},
	url = {https://tidsskrift.dk/brics/article/view/21851},
	doi = {10.7146/brics.v11i26.21851},
	abstract = {The evaluation function of a reduction semantics (i.e., a small-step operational semantics with an explicit representation of the reduction context) is canonically deﬁned as the transitive closure of (1) decomposing a term into a reduction context and a redex, (2) contracting this redex, and (3) plugging the contractum in the context. Directly implementing this evaluation function therefore yields an interpreter with a worst-case overhead, for each step, that is linear in the size of the input term.},
	language = {en},
	number = {26},
	urldate = {2024-12-17},
	journal = {BRICS Report Series},
	author = {Danvy, Olivier and Nielsen, Lasse R.},
	month = nov,
	year = {2004},
	file = {PDF:/home/thomas/Zotero/storage/2K33TR3T/Danvy et Nielsen - 2004 - Refocusing in Reduction Semantics.pdf:application/pdf},
}

@phdthesis{felleisen_calculi_1987,
	address = {USA},
	type = {phd},
	title = {The calculi of lambda-nu-cs conversion: a syntactic theory of control and state in imperative higher-order programming languages},
	shorttitle = {The calculi of lambda-nu-cs conversion},
	url = {https://www2.ccs.neu.edu/racket/pubs/dissertation-felleisen.pdf},
	school = {Indiana University},
	author = {Felleisen, Matthias},
	year = {1987},
	note = {AAI8727494},
}

@article{biernacka_syntactic_2007,
	series = {Festschrift for {John} {C}. {Reynolds}’s 70th birthday},
	title = {A syntactic correspondence between context-sensitive calculi and abstract machines},
	volume = {375},
	issn = {0304-3975},
	url = {https://www.sciencedirect.com/science/article/pii/S0304397506009170},
	doi = {10.1016/j.tcs.2006.12.028},
	abstract = {We present a systematic construction of environment-based abstract machines from context-sensitive calculi of explicit substitutions, and we illustrate it with ten calculi and machines for applicative order with an abort operation, normal order with generalized reduction and call/cc, the lambda-mu-calculus, delimited continuations, stack inspection, proper tail-recursion, and lazy evaluation. Most of the machines already exist but they have been obtained independently and are only indirectly related to the corresponding calculi. All of the calculi are new and they make it possible directly to reason about the execution of the corresponding machines.},
	number = {1},
	urldate = {2024-12-17},
	journal = {Theoretical Computer Science},
	author = {Biernacka, Małgorzata and Danvy, Olivier},
	month = may,
	year = {2007},
	keywords = {Continuations, Defunctionalization, Delimited continuations, Environment-based machines, Explicit substitutions, Proper tail recursion, Reduction semantics, Contexts, Refocusing, Stack inspection},
	pages = {76--108},
	file = {ScienceDirect Snapshot:/home/thomas/Zotero/storage/JPXNMZYV/S0304397506009170.html:text/html;Version soumise:/home/thomas/Zotero/storage/D2PVBXBW/Biernacka et Danvy - 2007 - A syntactic correspondence between context-sensitive calculi and abstract machines.pdf:application/pdf},
}


@article{lorenzen_oxidizing_2024,
	title = {Oxidizing {OCaml} with {Modal} {Memory} {Management}},
	volume = {8},
	url = {https://dl.acm.org/doi/10.1145/3674642},
	doi = {10.1145/3674642},
	abstract = {Programmers can often improve the performance of their programs by reducing heap allocations: either by allocating on the stack or reusing existing memory in-place. However, without safety guarantees, these optimizations can easily lead to use-after-free errors and even type unsoundness. In this paper, we present a design based on modes which allows programmers to safely reduce allocations by using stack allocation and in-place updates of immutable structures. We focus on three mode axes: affinity, uniqueness and locality. Modes are fully backwards compatible with existing OCaml code and can be completely inferred. Our work makes manual memory management in OCaml safe and convenient and charts a path towards bringing the benefits of Rust to OCaml.},
	number = {ICFP},
	urldate = {2025-01-06},
	journal = {Proc. ACM Program. Lang.},
	author = {Lorenzen, Anton and White, Leo and Dolan, Stephen and Eisenberg, Richard A. and Lindley, Sam},
	month = aug,
	year = {2024},
	pages = {253:485--253:514},
	file = {Full Text PDF:/home/thomas/Zotero/storage/V75Y7QIG/Lorenzen et al. - 2024 - Oxidizing OCaml with Modal Memory Management.pdf:application/pdf},
}


@incollection{sergey_linearity_uniqueness_2022,
	address = {Cham},
	title = {Linearity and {Uniqueness}: {An} {Entente} {Cordiale}},
	volume = {13240},
	isbn = {978-3-030-99335-1 978-3-030-99336-8},
	shorttitle = {Linearity and {Uniqueness}},
	url = {https://link.springer.com/10.1007/978-3-030-99336-8_13},
	abstract = {Substructural type systems are growing in popularity because they allow for a resourceful interpretation of data which can be used to rule out various software bugs. Indeed, substructurality is ﬁnally taking hold in modern programming; Haskell now has linear types roughly based on Girard’s linear logic but integrated via graded function arrows, Clean has uniqueness types designed to ensure that values have at most a single reference to them, and Rust has an intricate ownership system for guaranteeing memory safety. But despite this broad range of resourceful type systems, there is comparatively little understanding of their relative strengths and weaknesses or whether their underlying frameworks can be uniﬁed. There is often confusion about whether linearity and uniqueness are essentially the same, or are instead ‘dual’ to one another, or somewhere in between. This paper formalises the relationship between these two well-studied but rarely contrasted ideas, building on two distinct bodies of literature, showing that it is possible and advantageous to have both linear and unique types in the same type system. We study the guarantees of the resulting system and provide a practical implementation in the graded modal setting of the Granule language, adding a third kind of modality alongside coeﬀect and eﬀect modalities. We then demonstrate via a benchmark that our implementation beneﬁts from expected eﬃciency gains enabled by adding uniqueness to a language that already has a linear basis.},
	language = {en},
	urldate = {2025-03-24},
	booktitle = {Programming {Languages} and {Systems}},
	publisher = {Springer International Publishing},
	author = {Marshall, Danielle and Vollmer, Michael and Orchard, Dominic},
	editor = {Sergey, Ilya},
	year = {2022},
	doi = {10.1007/978-3-030-99336-8_13},
	note = {Series Title: Lecture Notes in Computer Science},
	pages = {346--375},
	file = {PDF:/home/thomas/Zotero/storage/4KWKII8X/Marshall et al. - 2022 - Linearity and Uniqueness An Entente Cordiale.pdf:application/pdf},
}

@article{harrington_uniqueness_2006,
	title = {Uniqueness logic},
	volume = {354},
	copyright = {https://www.elsevier.com/tdm/userlicense/1.0/},
	issn = {03043975},
	url = {https://linkinghub.elsevier.com/retrieve/pii/S0304397505008522},
	doi = {10.1016/j.tcs.2005.11.006},
	abstract = {A uniqueness type system is used to distinguish values which are referenced at most once from values which may be referenced an arbitrary number of times in a program. Uniqueness type systems are used in the Clean and Mercury programming languages to provide efﬁciently updatable data-structures and I/O without compromising referential transparency.},
	language = {en},
	number = {1},
	urldate = {2025-03-24},
	journal = {Theoretical Computer Science},
	author = {Harrington, Dana},
	month = mar,
	year = {2006},
	pages = {24--41},
	file = {PDF:/home/thomas/Zotero/storage/3GBFJLV4/Harrington - 2006 - Uniqueness logic.pdf:application/pdf},
}


@misc{spiwack_linear_scopes_2023,
	type = {Blog},
	title = {Linear {Constraints}: the problem with scopes},
	shorttitle = {Linear {Constraints}},
	url = {https://tweag.io/blog/2023-03-23-linear-constraints-linearly/},
	abstract = {How linear constraints get rid of scope functions and why it matters.},
	language = {en},
	urldate = {2025-03-25},
	journal = {Tweag Engineering Blog},
	author = {Spiwack, Arnaud},
	month = mar,
	year = {2023},
	file = {Snapshot:/home/thomas/Zotero/storage/7F9FZPYS/2023-03-23-linear-constraints-linearly.html:text/html},
}


@misc{spiwack_linear_prop_2023,
	title = {Linear constraints proposal by aspiwack · {Pull} {Request} \#621 · ghc-proposals/ghc-proposals},
	shorttitle = {Linear constraints proposal},
	url = {https://github.com/ghc-proposals/ghc-proposals/pull/621},
	abstract = {Adds a linear fat arrow \%1 =\&gt; this is meant to greatly improve the ergonomics of some of the APIs using linear types (it tends to apply to APIs based on typestate or related to mutation).
Render...},
	language = {en},
	urldate = {2025-03-25},
	journal = {GitHub},
	author = {Spiwack, Arnaud},
	month = nov,
	year = {2023},
	file = {Snapshot:/home/thomas/Zotero/storage/DZYL528V/621.html:text/html},
}


@misc{spiwack_ur_2024,
	type = {Blog},
	title = {Ur can't be a newtype},
	url = {https://www.tweag.io/blog/2024-01-18-linear-desugaring/#ur-cant-be-a-newtype},
	abstract = {How GHC's design informs linear types},
	language = {en},
	urldate = {2025-04-01},
	journal = {Tweag Engineering Blog},
	author = {Spiwack, Arnaud},
	month = jan,
	year = {2024},
	file = {Snapshot:/home/thomas/Zotero/storage/SVJJRH97/2024-01-18-linear-desugaring.html:text/html},
}


@misc{bagrel_primitives_2024,
	title = {Primitives for zero-copy compact regions by tbagrel1 · {Pull} {Request} \#683 · ghc-proposals/ghc-proposals},
	shorttitle = {Pull {Request}: {Primitives} for zero-copy compact regions},
	url = {https://github.com/ghc-proposals/ghc-proposals/pull/683},
	abstract = {This proposal introduces new primops in GHC to enable direct data structure building in compact regions (without temporary storage in the regular garbage-collected heap).},
	language = {en},
	urldate = {2025-04-01},
	journal = {GitHub},
	author = {Bagrel, Thomas},
	month = nov,
	year = {2024},
	file = {Snapshot:/home/thomas/Zotero/storage/LX53B3DH/683.html:text/html},
}

@book{pierce_tapl_2002,
author = {Pierce, Benjamin C.},
title = {Types and Programming Languages},
year = {2002},
isbn = {0262162091},
publisher = {The MIT Press},
edition = {1st},
abstract = {A type system is a syntactic method for automatically checking the absence of certain erroneous behaviors by classifying program phrases according to the kinds of values they compute. The study of type systems -- and of programming languages from a type-theoretic perspective -- has important applications in software engineering, language design, high-performance compilers, and security.This text provides a comprehensive introduction both to type systems in computer science and to the basic theory of programming languages. The approach is pragmatic and operational; each new concept is motivated by programming examples and the more theoretical sections are driven by the needs of implementations. Each chapter is accompanied by numerous exercises and solutions, as well as a running implementation, available via the Web. Dependencies between chapters are explicitly identified, allowing readers to choose a variety of paths through the material.The core topics include the untyped lambda-calculus, simple type systems, type reconstruction, universal and existential polymorphism, subtyping, bounded quantification, recursive types, kinds, and type operators. Extended case studies develop a variety of approaches to modeling the features of object-oriented languages.}
}

@book{sorensen_natural_curry_howard_2006,
	edition = {1st},
	series = {Studies in {Logic} and the {Foundations} of {Mathematics}},
	title = {Lectures on the {Curry}-{Howard} {Isomorphism}},
	volume = {149},
	isbn = {978-0-444-52077-7},
	url = {https://www.cs.cmu.edu/~rwh/courses/clogic/www/handouts/curry-howard.pdf},
	abstract = {The Curry-Howard isomorphism states an amazing correspondence between systems of formal logic as encountered in proof theory and computational calculi},
	language = {en-US},
	urldate = {2025-05-05},
	publisher = {Elsevier Science},
	author = {Sørensen, Morten Heine B. and Urzyczyn, Paweł},
	month = jul,
	year = {2006},
	file = {PDF:/home/thomas/Zotero/storage/VMRJ9E5L/curry-howard.pdf:application/pdf},
}

@article{girard_original_1987,
title = {Linear logic},
journal = {Theoretical Computer Science},
volume = {50},
number = {1},
pages = {1-101},
year = {1987},
issn = {0304-3975},
doi = {https://doi.org/10.1016/0304-3975(87)90045-4},
url = {https://www.sciencedirect.com/science/article/pii/0304397587900454},
author = {Jean-Yves Girard},
abstract = {The familiar connective of negation is broken into two operations: linear negation which is the purely negative part of negation and the modality “of course” which has the meaning of a reaffirmation. Following this basic discovery, a completely new approach to the whole area between constructive logics and programmation is initiated.}
}


@misc{howard_formulae-as-types_1969,
	title = {The formulae-as-types notion of construction},
	url = {https://www.dcc.fc.up.pt/~acm/howard2.pdf},
	language = {en},
	urldate = {2025-05-05},
	author = {Howard, W H},
	year = {1969},
	note = {Transcribed in 2017 to LATEX by Armando B. Matos},
	file = {PDF:/home/thomas/Zotero/storage/7WXQ3JU7/Howard - The formulae-as-types notion of construction.pdf:application/pdf},
}

@article{bagrel_destination_2025,
author = {Bagrel, Thomas and Spiwack, Arnaud},
title = {Destination Calculus: A Linear 𝜆-Calculus for Purely Functional Memory Writes},
year = {2025},
issue_date = {April 2025},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {9},
number = {OOPSLA1},
url = {https://doi.org/10.1145/3720423},
doi = {10.1145/3720423},
abstract = {Destination passing —aka. out parameters— is taking a parameter to fill rather than returning a result from a function. Due to its apparently imperative nature, destination passing has struggled to find its way to pure functional programming. In this paper, we present a pure functional calculus with destinations at its core. Our calculus subsumes all the similar systems, and can be used to reason about their correctness or extension. In addition, our calculus can express programs that were previously not known to be expressible in a pure language. This is guaranteed by a modal type system where modes are used to manage both linearity and scopes. Type safety of our core calculus was proved formally with the Coq proof assistant.},
journal = {Proc. ACM Program. Lang.},
month = apr,
articleno = {89},
numpages = {27},
keywords = {Destination Passing, Functional Programming, Linear Types, Pure Language}
}


@article{leijen_tail_2025,
	title = {Tail {Recursion} {Modulo} {Context}: {An} {Equational} {Approach} (extended version)},
	url = {https://antonlorenzen.de/trmc-jfp.pdf},
	urldate = {2025-05-13},
	journal = {under submission to JFP’25},
	author = {Leijen, Daan and Lorenzen, Anton},
	file = {https\://antonlorenzen.de/trmc-jfp.pdf:/home/thomas/Zotero/storage/FI3VK48V/trmc-jfp.pdf:application/pdf},
}

@article{pearce_lifetime_2021,
        title = {A {Lightweight} {Formalism} for {Reference} {Lifetimes} and {Borrowing} in {Rust}},
        volume = {43},
        issn = {0164-0925},
        url = {https://dl.acm.org/doi/10.1145/3443420},
        doi = {10.1145/3443420},
        abstract = {Rust is a relatively new programming language that has gained significant traction since its v1.0 release in 2015. Rust aims to be a systems language that competes with C/C++. A claimed advantage of Rust is a strong focus on memory safety without garbage collection. This is primarily achieved through two concepts, namely, reference lifetimes and borrowing. Both of these are well-known ideas stemming from the literature on region-based memory management and linearity/uniqueness. Rust brings both of these ideas together to form a coherent programming model. Furthermore, Rust has a strong focus on stack-allocated data and, like C/C++ but unlike Java, permits references to local variables.Type checking in Rust can be viewed as a two-phase process: First, a traditional type checker operates in a flow-insensitive fashion; second, a borrow checker enforces an ownership invariant using a flow-sensitive analysis. In this article, we present a lightweight formalism that captures these two phases using a flow-sensitive type system that enforces “type and borrow safety.” In particular, programs that are type and borrow safe will not attempt to dereference dangling pointers. Our calculus core captures many aspects of Rust, including copy- and move-semantics, mutable borrowing, reborrowing, partial moves, and lifetimes. In particular, it remains sufficiently lightweight to be easily digested and understood and, we argue, still captures the salient aspects of reference lifetimes and borrowing. Furthermore, extensions to the core can easily add more complex features (e.g., control-flow, tuples, method invocation). We provide a soundness proof to verify our key claims of the calculus. We also provide a reference implementation in Java with which we have model checked our calculus using over 500B input programs. We have also fuzz tested the Rust compiler using our calculus against 2B programs and, to date, found one confirmed compiler bug and several other possible issues.},
        number = {1},
        urldate = {2025-01-15},
        journal = {ACM Trans. Program. Lang. Syst.},
        author = {Pearce, David J.},
        month = apr,
        year = {2021},
        pages = {3:1--3:73},
        file = {Full Text PDF:/home/thomas/Zotero/storage/VDJHA6JK/Pearce - 2021 - A Lightweight Formalism for Reference Lifetimes and Borrowing in Rust.pdf:application/pdf},
}


@article{huet_zipper_1997,
	title = {The {Zipper}},
	volume = {7},
	issn = {1469-7653, 0956-7968},
	url = {https://www.cambridge.org/core/journals/journal-of-functional-programming/article/zipper/0C058890B8A9B588F26E6D68CF0CE204},
	doi = {10.1017/S0956796897002864},
	abstract = {Almost every programmer has faced the problem of 

representing a tree together with a 

subtree that is the focus of attention, where that focus may 

move left, right, up or down the tree. The Zipper is Huet's nifty name for a nifty data structure which fulfills this need. I wish I had known of it when I faced this task, because the solution 

I came up with was not quite so efficient or elegant as the Zipper.},
	language = {en},
	number = {5},
	urldate = {2025-05-20},
	journal = {Journal of Functional Programming},
	author = {Huet, Gérard},
	month = sep,
	year = {1997},
	pages = {549--554},
	file = {Full Text PDF:/home/thomas/Zotero/storage/NJABL9I3/Huet - 1997 - The Zipper.pdf:application/pdf},
}
