\documentclass[nofrench, 11pt]{article}
% \usepackage{xmpincl}
\usepackage{luatex85}
\usepackage[a-1b]{pdfx}
\usepackage[margin=2cm]{geometry}
\hypersetup{
  hypertexnames=false,
  pdftitle   = {Formalisation et implémentation de techniques sûres de passage de destinations pour les langages de programmation fonctionnels purs},
  pdfauthor  = {Thomas Bagrel},
  pdfsubject = {Résumé de thèse de doctorat},
  pdfcreator = {Thomas Bagrel},
  % ...
}

\usepackage{etoolbox}
\usepackage{calc}
\usepackage{xargs}
\usepackage{xpatch}
\usepackage{xkeyval}
\usepackage{xstring}
\usepackage{xifthen}
\usepackage{xparse}
\usepackage{expl3}
\usepackage{environ}
\usepackage{mathtools, amsfonts, amssymb, amsthm}
\usepackage{chngcntr}
\usepackage{csquotes}

% \usepackage[utf8]{inputenc}
% \usepackage[T1]{fontenc}
\usepackage{fontspec}
% \usepackage{unicode-math}

\usepackage[activate={true, nocompatibility}, stretch=10, shrink=10]{microtype}
%\usepackage[svgnames]{xcolor}
\usepackage{graphicx}
\usepackage{polyglossia}
\setmainlanguage{french}
\setotherlanguage{english}
\SetLanguageKeys{english}{indentfirst=true}
\SetLanguageKeys{french}{indentfirst=true}
\usepackage{float}
\renewcommand{\topfraction}{.67}
\renewcommand{\bottomfraction}{.0}
\renewcommand{\textfraction}{.33}
\renewcommand{\floatpagefraction}{.67}
\renewcommand{\dbltopfraction}{.67}
% \renewcommand{\dblbottomfraction}{.0}
% \renewcommand{\dbltextfraction}{.33}
\renewcommand{\dblfloatpagefraction}{.67}
\setcounter{topnumber}{9}
\setcounter{bottomnumber}{9}
\setcounter{totalnumber}{20}
\setcounter{dbltopnumber}{9}


\usepackage{caption}
\usepackage{subcaption}
\usepackage{refcount}
\makeatletter
\providecommand\english@loaded{}
\providecommand\frensh@loaded{}
\makeatother
\usepackage{url}
\usepackage{lastpage}
\usepackage{setspace}
\usepackage{enumitem}\let\newlist\relax\let\renewlist\relax
\usepackage{fancybox}
\usepackage{tabularx}
\usepackage[defaultlines=3,all]{nowidow}
% \usepackage{fancyhdr}

%% For rendering of JFLA article
% \usepackage{tipa}
\usepackage{minted}\usemintedstyle{tango}
\usepackage{stmaryrd}
\usepackage{hhline}
\usepackage[tikz]{bclogo}
\usepackage[normalem]{ulem}
\usepackage{newunicodechar}

%% For schemas
\usepackage{tikzit}
\input{tikzstyle.tikzstyles}
%\tikzset{every picture/.style={line width=10pt}}
\newcommand{\figcomment}[1]{\textcolor{gray}{#1}}
\newcommand{\smallspc}{\hspace{-0.5em}}
\def\figscale{1.2}
\definecolor{sczcolor}{RGB}{0,0,0}
\definecolor{sczfcolor}{RGB}{128, 128, 128}
\definecolor{scicolor}{RGB}{199, 22, 6}
\definecolor{scifcolor}{RGB}{251, 164, 157}
\definecolor{sciicolor}{RGB}{60, 103, 163}
\definecolor{sciiicolor}{RGB}{97, 5, 94}
\newcommand{\scz}[1]{\textcolor{sczcolor}{#1}}
\newcommand{\sczf}[1]{\textcolor{sczfcolor}{#1}}
\newcommand{\sci}[1]{\textcolor{scicolor}{#1}}
\newcommand{\scif}[1]{\textcolor{scifcolor}{#1}}
\newcommand{\scii}[1]{\textcolor{sciicolor}{#1}}
\newcommand{\sciii}[1]{\textcolor{sciiicolor}{#1}}

%% For OTT rendering
\newunicodechar{⥶}{\ensuremath{\raisebox{0.2em}{$\scriptstyle<$}\hspace*{-0.65em}\raisebox{-0.12em}{$\scriptscriptstyle\leftarrow$}}}
\newcommand{\pleq}{[[⥶]]_{\scriptscriptstyle{\pmb{\mathtt{p}}}}}
\newcommand{\aleq}{[[⥶]]_{\scriptscriptstyle{\pmb{\mathtt{a}}}}}
\usepackage[supertabular]{ottalt}
\inputott{destination_calculus_ott.tex}
\usepackage{ottstyling}
% Hide "Index for ranges" from the metavars displayed tabular
% \patchcmd{\ottmetavars}{$ \ottmv{k} $ & \ottcom{Index for ranges} \\}{}{}{}

% \patchcmd{\ottdruleTyXXectxsXXOpenAmpar}{%
% \ottpremise{  \Delta_{{\mathrm{1}}} ,~ \Delta_{{\mathrm{2}}}  \,\pmb{\dashv}\, \ottnt{C} \pmb{:}  \ottstype{(}  \ottstype{U} \,\ottstype{\ltimes}\, \ottstype{T'}  \ottstype{)}  \ottstype{\rightarrowtail} \ottstype{U_{{\mathrm{0}}}} }%
% \ottpremise{ \Delta_{{\mathrm{2}}} ,~  \ottshname{\destminus^{\scriptscriptstyle\text{-}1} } \Delta_{{\mathrm{3}}}    \!\!\pmb{\phantom{a}^{\scriptscriptstyle \mathrm{v} }\!\!\vdash}\,  \ottnt{v_{{\mathrm{2}}}}  \pmb{:}  \ottstype{U}}%
% }{\ottpremise{  \Delta_{{\mathrm{1}}} ,~ \Delta_{{\mathrm{2}}}  \,\pmb{\dashv}\, \ottnt{C} \pmb{:}  \ottstype{(}  \ottstype{U} \,\ottstype{\ltimes}\, \ottstype{T'}  \ottstype{)}  \ottstype{\rightarrowtail} \ottstype{U_{{\mathrm{0}}}}
% \qquad
% \Delta_{{\mathrm{2}}} ,~  \ottshname{\destminus^{\scriptscriptstyle\text{-}1} } \Delta_{{\mathrm{3}}}    \!\!\pmb{\phantom{a}^{\scriptscriptstyle \mathrm{v} }\!\!\vdash}\,  \ottnt{v_{{\mathrm{2}}}}  \pmb{:}  \ottstype{U}}
% }{}{}

% \patchcmd{\ottdruleTyXXvalXXAmpar}{%
% \ottpremise{   \ottsmode{1}  \hspace{-0.15ex}  \ottsmode{\uparrow}    \ottsmode{\hspace{-0.1ex}\cdot\hspace{-0.1ex} }  \Delta_{{\mathrm{1}}} ,~ \Delta_{{\mathrm{3}}}   \!\!\pmb{\phantom{a}^{\scriptscriptstyle \mathrm{v} }\!\!\vdash}\,  \ottnt{v_{{\mathrm{1}}}}  \pmb{:}  \ottstype{T}}%
% \ottpremise{ \Delta_{{\mathrm{2}}} ,~  \ottshname{\destminus^{\scriptscriptstyle\text{-}1} } \Delta_{{\mathrm{3}}}    \!\!\pmb{\phantom{a}^{\scriptscriptstyle \mathrm{v} }\!\!\vdash}\,  \ottnt{v_{{\mathrm{2}}}}  \pmb{:}  \ottstype{U}}%
% }{
% \ottpremise{   \ottsmode{1}  \hspace{-0.15ex}  \ottsmode{\uparrow}    \ottsmode{\hspace{-0.1ex}\cdot\hspace{-0.1ex} }  \Delta_{{\mathrm{1}}} ,~ \Delta_{{\mathrm{3}}}   \!\!\pmb{\phantom{a}^{\scriptscriptstyle \mathrm{v} }\!\!\vdash}\,  \ottnt{v_{{\mathrm{1}}}}  \pmb{:}  \ottstype{T}
% \qquad
% \Delta_{{\mathrm{2}}} ,~  \ottshname{\destminus^{\scriptscriptstyle\text{-}1} } \Delta_{{\mathrm{3}}}    \!\!\pmb{\phantom{a}^{\scriptscriptstyle \mathrm{v} }\!\!\vdash}\,  \ottnt{v_{{\mathrm{2}}}}  \pmb{:}  \ottstype{U}}%
% }{}{}

% \patchcmd{\ottdruleTyXXtermXXPatS}{%
% \ottpremise{ \Gamma_{{\mathrm{2}}} ,~  \ottmv{x_{{\mathrm{1}}}} :\!_{\! \ottsmode{m} } \ottstype{T_{{\mathrm{1}}}}    \,\pmb{\vdash}\,  \ottnt{u_{{\mathrm{1}}}}  \pmb{:}  \ottstype{U}}%
% \ottpremise{ \Gamma_{{\mathrm{2}}} ,~  \ottmv{x_{{\mathrm{2}}}} :\!_{\! \ottsmode{m} } \ottstype{T_{{\mathrm{2}}}}    \,\pmb{\vdash}\,  \ottnt{u_{{\mathrm{2}}}}  \pmb{:}  \ottstype{U}}%
% }{\ottpremise{ \Gamma_{{\mathrm{2}}} ,~  \ottmv{x_{{\mathrm{1}}}} :\!_{\! \ottsmode{m} } \ottstype{T_{{\mathrm{1}}}}    \,\pmb{\vdash}\,  \ottnt{u_{{\mathrm{1}}}}  \pmb{:}  \ottstype{U}%
% \qquad
% \Gamma_{{\mathrm{2}}} ,~  \ottmv{x_{{\mathrm{2}}}} :\!_{\! \ottsmode{m} } \ottstype{T_{{\mathrm{2}}}}    \,\pmb{\vdash}\,  \ottnt{u_{{\mathrm{2}}}}  \pmb{:}  \ottstype{U}}
% }{}{}

% \patchcmd{\ottdruleTyXXectxsXXPatS}{%
% \ottpremise{\Delta_{{\mathrm{2}}}  +   \ottmv{x_{{\mathrm{1}}}} :\!_{\! \ottsmode{m} } \ottstype{T_{{\mathrm{1}}}}   \,\pmb{\vdash}\,  \ottnt{u_{{\mathrm{1}}}}  \pmb{:}  \ottstype{U}}%
% \ottpremise{\Delta_{{\mathrm{2}}}  +   \ottmv{x_{{\mathrm{2}}}} :\!_{\! \ottsmode{m} } \ottstype{T_{{\mathrm{2}}}}   \,\pmb{\vdash}\,  \ottnt{u_{{\mathrm{2}}}}  \pmb{:}  \ottstype{U}}%
% }{
%   \ottpremise{\Delta_{{\mathrm{2}}}  +   \ottmv{x_{{\mathrm{1}}}} :\!_{\! \ottsmode{m} } \ottstype{T_{{\mathrm{1}}}}   \,\pmb{\vdash}\,  \ottnt{u_{{\mathrm{1}}}}  \pmb{:}  \ottstype{U}
% \qquad
%   \Delta_{{\mathrm{2}}}  +   \ottmv{x_{{\mathrm{2}}}} :\!_{\! \ottsmode{m} } \ottstype{T_{{\mathrm{2}}}}   \,\pmb{\vdash}\,  \ottnt{u_{{\mathrm{2}}}}  \pmb{:}  \ottstype{U}}
% }{}{}

%% Bibliography settings
\usepackage[
  backend=biber,
  natbib=true,
  bibstyle=authoryear,
  citestyle=authoryear-comp,
  sorting=ynt]{biblatex}
\addbibresource{bibliography.bib}

%% General document setup
\setmainlanguage{english}

\makeatletter

\newrobustcmd*{\parentexttrack}[1]{%
  \begingroup
  \blx@blxinit
  \blx@setsfcodes
  \blx@bibopenparen#1\blx@bibcloseparen
  \endgroup}

\AtEveryCite{%
  \let\parentext=\parentexttrack%
  \let\bibopenparen=\bibopenbracket%
  \let\bibcloseparen=\bibclosebracket}

\makeatother

\let\cite\parencite
\let\citet\textcite

% \setmainfont{Tinos}[
%   Path=./fonts/,
%   Extension=.ttf,
%   UprightFont=*-Regular,
%   BoldFont=*-Bold,
%   ItalicFont=*-Italic,
%   BoldItalicFont=*-BoldItalic,
%   Scale=1.033]
\setmainfont{CMUSerif}[
  Path=./fonts/,
  Extension=.otf,
  UprightFont=*-Roman,
  BoldFont=*-Bold,
  ItalicFont=*-Italic,
  BoldItalicFont=*-BoldItalic,
  Scale=1.0]
\setsansfont{iosevka-quasi-proportional-ss07}[
  Path=fonts/,
  Extension=.ttf,
  UprightFont=*-regular,
  BoldFont=*-semibold,
  ItalicFont=*-italic,
  BoldItalicFont=*-semibolditalic,
  Scale=0.887]
\setmonofont{iosevka-quasi-proportional-ss07}[
  Path=fonts/,
  Extension=.ttf,
  UprightFont=*-regular,
  BoldFont=*-semibold,
  ItalicFont=*-italic,
  BoldItalicFont=*-semibolditalic,
  Scale=0.887]
% \setmonofont{Iosevka-Term-SS07}[
%   Path=fonts/,
%   Extension=.ttf,
%   UprightFont=*-Regular,
%   BoldFont=*-Semibold,
%   ItalicFont=*-Italic,
%   BoldItalicFont=*-SemiboldItalic,
%   Scale=0.92]
\setmathrm{iosevka-quasi-proportional-ss07}[
  Path=fonts/,
  Extension=.ttf,
  UprightFont=*-regular,
  BoldFont=*-semibold,
  ItalicFont=*-italic,
  BoldItalicFont=*-semibolditalic,
  Scale=0.887]
% \setmathsf{Tinos}[
%   Path=fonts/,
%   Extension=.ttf,
%   UprightFont=*-Italic,
%   BoldFont=*-BoldItalic,
%   ItalicFont=*-Italic,
%   BoldItalicFont=*-BoldItalic,
%   Scale=1.033]
\setmathsf{CMUSerif}[
  Path=./fonts/,
  Extension=.otf,
  UprightFont=*-Italic,
  BoldFont=*-BoldItalic,
  ItalicFont=*-Italic,
  BoldItalicFont=*-BoldItalic,
  Scale=1.0]
% \setmonofont{Fira-Code-Nerd-Font-Complete}[
%   Extension=.otf,
%   UprightFont=*-Regular,
%   BoldFont=*-Medium,
%   Scale=0.887]

\setlength{\parskip}{0.25\baselineskip}
\setlist[itemize]{topsep=0ex,itemsep=-0.5ex}

\definecolor{mintedframe}{RGB}{100,100,100}
\setminted{
    linenos,                       % Enable line numbering
    xleftmargin=12pt,              % Set left margin to 0
    frame=leftline,                  % Use a frame around the code
    framesep=7.5pt,                 % Space between frame and code
    rulecolor=mintedframe,
    numbersep=7.5pt,                % Space between line numbers and code
    numberblanklines=true,
}

\renewcommand{\theFancyVerbLine}{
\ttfamily
\textcolor{mintedframe}{
\scriptsize{
\arabic{FancyVerbLine}}}}

%% New listing float
\newfloat{listing}{tbp}{lop}[section]
\floatname{listing}{Listing}
\renewcommand{\thelisting}{\thesection.\arabic{listing}} % section-based numbering

% Step 3 (optional): Reset counter per chapter (for books/theses)
% \counterwithin{listing}{chapter}

%% Editing marks
\usepackage[colorinlistoftodos,prependcaption,textsize=tiny]{todonotes}
% TOGGLE ME to turn off all the commentary:
\InputIfFileExists{no-editing-marks}{
  \def\noeditingmarks{}
}
% ^^ Need for pgfsyspdfmark apparently?
\ifx\noeditingmarks\undefined
    % Adapting to acmart's small margins
    \setlength{\marginparsep}{0.3em}
    \setlength{\marginparwidth}{1.4cm}

    \newcommand{\Red}[1]{{\color{red}{#1}}}
    \newcommand{\newaudit}[1]{{\color{blue}{#1}}}
    \newcommand{\note}[1]{{\color{blue}{\begin{itemize} \item {#1} \end{itemize}}}}
    \newenvironment{alt}{\color{red}}{}

    \newcommandx{\unsure}[2][1=]{\todo[linecolor=orange,backgroundcolor=orange!25,bordercolor=orange,#1]{#2}}
    \newcommandx{\info}[2][1=]{\todo[linecolor=green,backgroundcolor=green!25,bordercolor=green,#1]{#2}}
    \newcommandx{\change}[2][1=]{\todo[linecolor=blue,backgroundcolor=blue!25,bordercolor=blue,#1]{#2}}
    \newcommandx{\inconsistent}[2][1=]{\todo[linecolor=red,backgroundcolor=red!25,bordercolor=red,#1]{#2}}
    \newcommandx{\critical}[2][1=]{\todo[linecolor=purple,backgroundcolor=purple!25,bordercolor=purple,#1]{#2}}
    \newcommand{\improvement}[1]{\todo[linecolor=pink,backgroundcolor=pink!25,bordercolor=pink]{#1}}
    \newcommandx{\resolved}[2][1=]{\todo[linecolor=OliveGreen,backgroundcolor=OliveGreen!25,bordercolor=OliveGreen,#1]{#2}} % use this to mark a resolved question
\else
%    \newcommand{\Red}[1]{#1}
    \newcommand{\Red}[1]{{\color{red}{#1}}}
    \newcommand{\newaudit}[1]{#1}
    \newcommand{\note}[1]{}
    \newenvironment{alt}{}{}
%    \renewcommand\todo[2]{}
    \newcommand{\unsure}[2][1=]{}
    \newcommand{\info}[2][1=]{}
    \newcommand{\change}[2]{}
    \newcommand{\inconsistent}[2]{}
    \newcommand{\critical}[2]{}
    \newcommand{\improvement}[1]{}
    \newcommand{\resolved}[2]{}
\fi

%\usepackage[hypertexnames=false]{hyperref}
\usepackage[capitalize, noabbrev]{cleveref}

%% User defined commands

\makeatletter
\newlength\fake@f
\newlength\fake@c
\def\fakesc#1{%
  \begingroup%
  \xdef\fake@name{\csname\curr@fontshape/\f@size\endcsname}%
  \fontsize{\fontdimen8\fake@name}{\baselineskip}\selectfont%
  \uppercase{#1}%
  \endgroup%
}
\makeatother
\newcommand\fauxsc[1]{\fauxschelper#1 \relax\relax}
\def\fauxschelper#1 #2\relax{%
  \fauxschelphelp#1\relax\relax%
  \if\relax#2\relax\else\ \fauxschelper#2\relax\fi%
}
\def\Hscale{.83}\def\Vscale{.79}\def\Cscale{1.00}
\def\fauxschelphelp#1#2\relax{%
  \ifnum`#1>``\ifnum`#1<`\{\scalebox{\Hscale}[\Vscale]{\uppercase{#1}}\else%
    \scalebox{\Cscale}[1]{#1}\fi\else\scalebox{\Cscale}[1]{#1}\fi%
  \ifx\relax#2\relax\else\fauxschelphelp#2\relax\fi}
% \let\textsc\fauxsc

\newcommand{\TODO}[1]{\textnormal{\textcolor{red}{TODO: #1} } }
\newcommand{\sepimp}{\mathrel{-\mkern-6mu*}}
\newcommand{\textopname}[1]{``#1''}
\newcommand{\parr}{\rotatebox[origin=c]{180}{\&}}
\makeatletter
\newcommand{\smallbullet}{} % for safety
\DeclareRobustCommand\smallbullet{%
\mathord{\mathpalette\smallbullet@{0.5}}%
}
\newcommand{\smallbullet@}[2]{%
\vcenter{\hbox{\scalebox{#2}{$\m@th#1\bullet$}}}%
}
\makeatother

\makeatletter
\newcommand{\oset}[3][0ex]{%
\mathrel{\mathop{#3}\limits^{
  \vbox to#1{\kern-2\ex@
  \hbox{$\scriptstyle#2$}\vss}}}}
\makeatother

\def\mycasem#1{\ifthenelse{\equal{#1}{[[¹ν]]}}{}{#1}}
\def\myfunvm#1{\ifthenelse{\equal{#1}{[[¹ν]]}}{\,\,}{#1}}
\def\myfuntm#1{\ifthenelse{\equal{#1}{[[¹ν]]}}{\,}{#1}}
\def\mydestm#1{\ifthenelse{\equal{#1}{[[¹ν]]}}{}{#1}}
\def\mymul#1{\ifthenelse{\equal{#1}{[[¹]]}}{}{#1}}

\let\figtextsize\normalsize
\newcommand{\destcalculus}{\ensuremath{\lambda_d}}
\newcommand{\destcalculusinplace}{\ensuremath{\lambda_{d\,\textsc{ip}}}}
\newtheorem{lemma}{Lemma}
\newtheorem{theorem}{Theorem}
\newcommand\btriangleq{\pmb{\triangleq}}
\newcommand\btriangleqrec{\oset{\mathsf{rec}}{\pmb{\triangleq}}}
\newlength{\interdefskip}
\setlength{\interdefskip}{0.1cm}
\newcommand{\newtype}[3][]{#2~\ifthenelse{\equal{#1}{}}{\btriangleq}{\btriangleqrec}~#3\\[\interdefskip]}
\newcommand{\newoperator}[5][]{\phantom{a}\!\!\!\!\!\!\begin{array}[t]{l}%
#2 ~\pmb{:}~ #3 \\
#4 ~\ifthenelse{\equal{#1}{}}{\btriangleq}{\btriangleqrec}~ #5
\end{array}\\[\interdefskip]}
\newcommand{\newoperatorb}[5][]{\phantom{a}\!\!\!\!\!\!\begin{array}[t]{l}%
#2 ~\pmb{:}~ #3 \\
#4 ~\ifthenelse{\equal{#1}{}}{\btriangleq}{\btriangleqrec}~\\\myspace{1}#5
\end{array}\\[\interdefskip]}
\newcommand{\figureratio}{1}
\newcommand{\codehere}[2][t]{\vspace{-0.05cm}\begin{center}\begin{minipage}[#1]{\figureratio\linewidth}{\figtextsize\ensuremath{#2}}\end{minipage}\end{center}\vspace{-0.05cm}}
\NewEnviron{codefig}[2][tbp]{\begin{listing}[#1]
\codehere{\BODY}#2
\end{listing}}
\NewEnviron{ottfig}[2][tbp]{\begin{figure}[#1]
\figtextsize\BODY#2
\end{figure}}
\newcommand{\sidebysidecodehere}[4]{\begin{center}\begin{minipage}[#1]{\figureratio\linewidth}
\noindent\begin{minipage}[#1]{#2\linewidth-0.02\linewidth}{\figtextsize\ensuremath{#3}}\end{minipage}
\hfill
\vrule width 0.5pt % Vertical rule of 1pt width
\hfill
\begin{minipage}[#1]{\linewidth-#2\linewidth-0.02\linewidth}{\figtextsize\ensuremath{#4}}\end{minipage}
\end{minipage}\end{center}
}

\newcommand{\sidebysidecodefig}[6][t]{
\begin{listing}[#1]
\sidebysidecodehere{#3}{#4}{#5}{#6}
#2
\end{listing}
}

\newenvironment{stretchedarray}[2][1]
  {\bgroup\renewcommand*{\arraystretch}{#1}\begin{array}{#2}}
  {\end{array}\egroup}

\newcommand{\mpar}{\text{\,\textramshorns\,}}
\newcommand{\dest}{-\prec}
%\newcommand{\TODO}[1]{{\color{red}\large #1}}
\newcommand{\mnew}[1]{\colorbox{green!50}{#1}}
\newcommand{\muline}[1]{\uline{#1}}
\newcommand{\mold}[1]{\uwave{#1}}
\newunicodechar{⊸}{\ensuremath{\pmb{\multimap}}}
\newunicodechar{→}{\ensuremath{\pmb{\to}}}
\newunicodechar{←}{\ensuremath{\leftarrow}}
\newunicodechar{⇒}{\ensuremath{\pmb{\Rightarrow}}}
\newunicodechar{□}{\ensuremath{{\color{hnamecolor} \square}}}
\newunicodechar{¤}{}
\newunicodechar{;}{\ensuremath{\fatsemi}}
\newunicodechar{∀}{\ensuremath{\pmb{\forall}}}
\newunicodechar{⩴}{\hspace{-0.2ex}:\hspace{-0.2ex}:\hspace{-0.2ex}}
\newunicodechar{Ⴈ}{1}
\newunicodechar{☠}{$\skull$}

\newlength{\widthaugment}
\NewEnviron{augmentwidth}[1]
  {\setlength{\widthaugment}{#1}
   \pgfmathsetmacro{\myratio}{\linewidth / (\widthaugment + \linewidth)}
   \scalebox{\myratio}{\begin{minipage}{\linewidth+\widthaugment}\BODY
   \end{minipage}}}

\makeatletter
\AtBeginEnvironment{minted}{\dontdofcolorbox}
\def\dontdofcolorbox{\renewcommand\fcolorbox[4][]{##4}}
\xpatchcmd{\inputminted}{\minted@fvset}{\minted@fvset\dontdofcolorbox}{}{}
\xpatchcmd{\mintinline}{\minted@fvset}{\minted@fvset\dontdofcolorbox}{}{} % see https://tex.stackexchange.com/a/401250/
\makeatother

\renewcommand{\MintedPygmentize}{./pygmentize_local}
\newlength{\currentparskip}
\newenvironment{unbreakable}
{%
  \setlength{\currentparskip}{\parskip}% Save current \parskip
  \setlength{\parskip}{\currentparskip}% Save current \parskip
  \par\vspace{0.5\baselineskip}% Add possible separation
  \noindent\begin{minipage}{\textwidth}%
    \setlength{\parskip}{\currentparskip}% Restore current \parskip
  %\medskip%
}
{%
  \end{minipage}%
  \par\vspace{0.5\baselineskip}% Add possible vertical separation
}

\def\foreverunspace{%
  \ifnum\lastnodetype=11
    \unskip\foreverunspace
  \else
    \ifnum\lastnodetype=12
      \unkern\foreverunspace
    \else
      \ifnum\lastnodetype=13
        \unpenalty\foreverunspace
      \fi
    \fi
  \fi
}

\newcommand{\IfFancyRuleNames}[2]{#1}

\newcommand{\SetPrefix}[1]{\IfFancyRuleNames{\renewcommand{\ottdrulename}[1]{#1}}{}}

\makeatletter

\IfFancyRuleNames{
  \def\CSep{/}
  \def\CHole{id\textsubscript{H}}
  \def\CDest{id\textsubscript{D}}
  \def\CUnit{$\ottstype{1}$I}
  \def\CFun{$\ottstype{\multimap}$I}
  \def\CLeft{$\ottstype{\oplus}$I\textsubscript{1}}
  \def\CRight{$\ottstype{\oplus}$I\textsubscript{2}}
  \def\CProd{$\ottstype{\otimes}$I}
  \def\CExp{$\ottstype{!}$I}
  \def\CBangProm{$\ottstype{!}$P}
  \def\CBangDerel{$\ottstype{!}$D}
  \def\CBangWeak{$\ottstype{!}$W}
  \def\CBangContr{$\ottstype{!}$C}
  \def\CAmpar{$\ottstype{\ltimes}$I}
  \def\CVal{fromVal}
  \def\CVar{id\textsubscript{V}}
  \def\CApp{$\ottstype{\multimap}$E}
  \def\CPatU{$\ottstype{1}$E}
  \def\CPatS{$\ottstype{\oplus}$E}
  \def\CPatP{$\ottstype{\otimes}$E}
  \def\CPatE{$\ottstype{!}$E}
  \def\CUpdA{$\ottstype{\ltimes}$upd}
  \def\CToA{$\ottstype{\ltimes}$to}
  \def\CFromA{$\ottstype{\ltimes}$from}
  \def\CNewA{$\ottstype{\ltimes}$new}
  \def\CFillU{$\ottstype{\lfloor 1\rfloor}$E}
  \def\CFillL{$\ottstype{\lfloor \oplus\rfloor}$E\textsubscript{1}}
  \def\CFillR{$\ottstype{\lfloor \oplus\rfloor}$E\textsubscript{2}}
  \def\CFillP{$\ottstype{\lfloor \otimes\rfloor}$E}
  \def\CFillE{$\ottstype{\lfloor !\rfloor}$E}
  \def\CFillF{$\ottstype{\lfloor \multimap\rfloor}$E}
  \def\CFillComp{$\ottstype{\lfloor}$~$\ottstype{\rfloor}$E\textsubscript{c}}
  \def\CFillLeaf{$\ottstype{\lfloor}$~$\ottstype{\rfloor}$E\textsubscript{l}}
  \def\CId{id}
  \def\COpenAmpar{$\ottstype{\ltimes}$op}
  \def\CAmparOpen{$\ottstype{\ltimes}$op}
  \def\CAmparClose{$\ottstype{\ltimes}$cl}
  \def\CFocus{F}
  \def\CUnfocus{U}
  \def\CRed{C}
  \def\CTyTerm{\destcalculus{}--ty}
  \def\CTySTerm{\destcalculus{}--ty\textsubscript{s}}
  \def\CTyVal{\destcalculus{}--ty\textsubscript{v}}
  \def\CTyEctxs{\destcalculus{}--ty\textsubscript{E}}
  \def\CTyCmd{\destcalculus{}--ty\textsubscript{cmd}}
  \def\CSem{\destcalculus{}--sem}
  \def\CLOne{$\lambda_{L1}$}
  \def\CLTwo{$\lambda_{L2}$}
  \def\CLm{$\lambda_{Lm}$}
  \def\CLdm{$\lambda_{Ldm}$}
  \def\CLOneOrTwo{$\lambda_{L1,2}$}
  \def\CLTwoOrm{$\lambda_{L2,m}$}
  \def\CSemSuff{\hspace*{-0.2ex}--sem}
  \def\CTy{\hspace*{-0.2ex}--ty}
  \def\CILL{ILL}
  \def\rref*#1{\textsc{#1}}
}{
  \renewcommand{\ottdrulename}[1]{\ottalt@replace@cs\ranchor\_-{}#1\\}\renewcommand{\maybecomm}[1]{\bgroup\def\text##1{}#1\egroup}
  \def\CSep{-}
  \def\CHole{Hole}
  \def\CDest{Dest}
  \def\CUnit{Unit}
  \def\CFun{Fun}
  \def\CLeft{Left}
  \def\CRight{Right}
  \def\CProd{Prod}
  \def\CExp{Exp}
  \def\CBangProm{Prom}
  \def\CBangDerel{Derel}
  \def\CBangWeak{Weak}
  \def\CBangContr{Contra}
  \def\CAmpar{Ampar}
  \def\CVal{Val}
  \def\CVar{Var}
  \def\CApp{App}
  \def\CPatU{PatU}
  \def\CPatS{PatS}
  \def\CPatP{PatP}
  \def\CPatE{PatE}
  \def\CUpdA{UpdA}
  \def\CToA{ToA}
  \def\CFromA{FromA}
  \def\CNewA{NewA}
  \def\CFillU{FillU}
  \def\CFillL{FillL}
  \def\CFillR{FillR}
  \def\CFillP{FillP}
  \def\CFillE{FillE}
  \def\CFillF{FillF}
  \def\CFillComp{FillComp}
  \def\CFillLeaf{FillLeaf}
  \def\CId{Id}
  \def\COpenAmpar{OpenAmpar}
  \def\COpen{Open}
  \def\CClose{Close}
  \def\CFocus{Focus}
  \def\CUnfocus{Unfocus}
  \def\CRed{Red}
  \def\CTyTerm{Ty-term}
  \def\CTySTerm{Ty-sterm}
  \def\CTyVal{Ty-val}
  \def\CTyEctxs{Ty-ectxs}
  \def\CTyCmd{Ty-cmd}
}
\makeatother

\makeatletter
\def\uwave{\bgroup \markoverwith{\lower3.5\p@\hbox{\sixly \textcolor{red}{\char58}}}\ULon}
\font\sixly=lasy6 % does not re-load if already loaded, so no memory problem.
\makeatother

\newcommand{\grammsep}{\hspace*{1.8ex}|\hspace*{1.8ex}}
\newcommand{\grammdef}{\mathrel{\raisebox{0.09ex}{$\mathop{:}$\hspace*{-0.1ex}$\mathop{:}$\hspace*{-0.1ex}}\shorteq}}

%-------------------------------------------------------------------
%                         Page de titre:
%-------------------------------------------------------------------

\begin{document}

\title{Formalisation et implémentation de techniques sûres de passage de destinations pour les langages de programmation fonctionnels purs}
\date{Résumé étendu de thèse de doctorat, soutenue le 14 novembre 2025}
\author{Thomas \textsc{Bagrel}}

% Type de la these
\maketitle\clearpage

\section*{Introduction}

\def\cpp{C+\!\!+}

Tout comme la pléthore de langues humaines, il existe un nombre impressionnant de langages de programmation différents, chacun avec des choix de conception reflétant des compromis entre expressivité, performance, sûreté et facilité d’utilisation.

Un des aspects par lesquels les langages se distinguent est leur approche de la gestion mémoire. Ce choix influence profondément la manière dont les programmes sont écrits. Les langages de haut niveau, comme Python ou Java, délèguent la gestion mémoire à un ramasse-miettes, simplifiant l'écriture de code mais introduisant une latence imprévisible. À l’opposé, les langages bas niveau, tels que C ou Zig, confient la gestion mémoire au programmeur, offrant un contrôle fin mais exposant à des erreurs très coûteuses. Des approches plus récentes, comme les pointeurs intelligents en \cpp{} ou le modèle d’\emph{ownership} en Rust, tentent de concilier sûreté et performance sans recourir à un système de ramasse-miettes, mais ces dernières ne s'appliquent pas trop aux langages fonctionnels, qui sont l'objet de notre étude.

\paragraph{Langages de programmation fonctionnels}

Les langages de programmation fonctionnels se caractérisent d'abord par l'accès à des fonctions pouvant être manipulées, stockées, ou passés en paramètres comme n'importe quelle autre valeur. Ils affichent également une préférence pour les expressions (à la place des instructions ayant des effets de bords) et les structures immuables. Inspirés et proches de modèles mathématiques, leur formalisation est facilitée, et il présentent de nombreuses propriétés intéressantes pour leur analyse statique (permettant d'éviter de nombreuses classes d'erreurs). C'est d'autant plus le cas pour les langages fonctionnels \emph{purs}, où les effets de bords sont clairement circonscrits et explicitement représentés au niveau du système de type, et où toute fonction est transparente par substitution. La pureté impose alors usuellement l'utilisation d'un système de gestion automatique de la mémoire, typiquement un ramasse-miettes, limitant les possibilités de contrôle explicite (qui peuvent sembler antithétiques avec l'idée de pureté).

\paragraph{Structures à trous}

Cependant, Minamide a présenté en 1998 un premier système permettant de représenter des structures incomplètes, ou ``avec trous'', c'est à dire des structures de données non encore finalisés, au sein d'un langage fonctionnel pur. Ces structures peuvent être progressivement complétées, tout en garantissant, via un usage ingénieux d'un système de types linéaires, qu’elles ne sont lisibles qu’une fois entièrement initialisées. Cette technique permet de dépasser certaines contraintes habituelles des langages fonctionnels purs (par exemple l'immuabilité des structures de données, qui force souvent à créer des copies intermédiaires) sans introduire de risques d'erreurs.

Ma thèse poursuit cette idée en proposant un langage fonctionnel où les structures avec trous sont dotées de pointeurs d’écriture explicites -- les destinations -- pointant vers leurs trous. Cette approche n'est pas sans rappeler le passage de paramètres par adresse dans les langages impératifs, mais elle est ici adaptée à un contexte fonctionnel pur, en réutilisant les idées pionnières de Minamide.

Grâce à la manipulation explicite de \emph{destinations}, il est possible à la fois d'exprimer certains algorithmes -- dont l'implémentation fonctionnelle était peu ergonomique -- d'une manière simple se rapprochant des approches impérative ; mais également de permettre une gestion mémoire semi-manuelle afin d’obtenir des gains de performances quand la gestion automatique du ramasse-miette n'est pas optimale. Je développe d'abord un langage formel, servant de cadre théorique pour raisonner sur la sûreté et la correction des approches de passage de destinations, avant de concrétiser mon approche par un prototype en Haskell.

L'ensemble de mon approche repose, comme pour Minamide, sur un système de types incorporant les types linéaires. Grâce aux types linéaires, il est possible d'imposer et d'assurer que chaque destination est bien utilisée une seule et unique fois, garantissant à la fois que chaque champ d’une structure est correctement initialisé avant toute lecture, mais également qu'une valeur ne sera pas écrasée par une autre une fois qu'elle a été écrite dans un champ d'une structure (permettant de respecter l'immuabilité chère aux langages fonctionnels).

\section*{$\lambda$-calcul linéaire}

Le $\lambda$-calcul linéaire est une variante typée du $\lambda$-calcul dans laquelle l’usage des variables est contrôlé statiquement. Contrairement au $\lambda$-calcul classique, où les règles structurelles autorisent implicitement la duplication et l’abandon de variables, dans le $\lambda$-calcul linéaire, chaque variable doit être utilisée exactement une fois. Cette discipline permet d’exprimer directement, au niveau du système de types, des invariants d’usage sur les ressources.

La base sous-jacente est la logique linéaire, dans laquelle la contraction et l’affaiblissement d'hypothèses n'est pas possible. En restreignant ces règles, les hypothèses sont interprétées comme des ressources qui doivent être utilisées exactement une fois. Cette interprétation se transpose via l’isomorphisme de Curry-Howard : un programme qui fait un usage incorrect de variables linéaires n'est pas typable dans un language avec un système de types linéaires.

Le $\lambda$-calcul linéaire introduit en particulier la flèche de fonction linéaire $[[T ⊸ U]]$, indiquant que l’argument est consommé exactement une fois pour produire le résultat de la fonction. Les paires linéaires sont données par le tenseur $[[T⨂U]]$, dont les deux composantes doivent être consommées exactement une fois. Les règles d’introduction et d’élimination des connecteurs linéaires imposent une une utilisation contrôlée des ressources : il n'est pas possible de partager une variable entre deux sous-termes par exemple.

Un calcul strictement linéaire étant peu utilisable en pratique, le système est enrichi par une modalité exponentielle. Un type de la forme $[[!T]]$ désigne une ressource de type $[[T]]$ qui peut être dupliquée ou ignorée. Cette distinction rend explicite, dans les types, la frontière entre ressources linéaires et ressources non-linéaires. Seulement, dans la présentation du $\lambda$-calcul linéaire usuelle, la gestion de cette modalité doit être faite explicitement, via des opérateurs dédiés.

Pour améliorer l’ergonomie du système, on propose une présentation du $\lambda$-calcul linéaire fondée sur des modalités graduées, ou multiplicités. Une variable est alors annotée, dans le contexte de typage, par une multiplicité indiquant son régime d’utilisation. Les multiplicité usuelles distinguent l’usage linéaire (exactement une fois) et l’usage non restreint. Cette information est portée par les contextes de typage et propagée via les règles de typage, ce qui permet d'éviter une partie de la manipulation explicite de la modalité exponentielle.

Dans cette continuité, on introduit les flèches de fonction annotées par une multiplicité $[[T m → U]]$, qui indique que l'argument de type $[[T]]$ est utilisé selon la multiplicité $[[m]]$ pour produire le résultat de type $[[U]]$. La polymorphie en multiplicité permet alors d’écrire des fonctions et programmes plus génériques lorsque cela est possible.

On fait également le choix, pour notre langage d'étude, de propager les modalités graduées à travers les types de données algébriques, ce qui donne la notion de \emph{modes profonds}. Ainsi, une paire non restreinte $[[! ɷ (T1⨂T2)]]$ autorise la duplication et l’abandon de chacune de ses deux composantes, de façon indépendante, ce qui n'est pas usuellement le cas dans le $\lambda$-calcul linéaire traditionnel.

Ces principes sont incarnés concrètement dans \emph{Linear Haskell}, l'extension de Haskell permettant la gestion des types linéaires, qui est utilisées pour nos différents prototypes. Cette extension introduit entre autre des flèches de fonctions annotées par des multiplicité, comme décrit plus haut, tout en restant rétrocompatible avec du code Haskell standard. La linéarité devient ainsi un outil modulaire pour exprimer des invariants forts quand nécessaire.

\section*{Le \emph{Destination Calculus} \destcalculus{}}

Le langage \destcalculus{} que j'ai créé est un calcul fonctionnel pur, linéaire, qui intègre le \emph{destination-passing style} (DPS) à la racine du langage, en faisant des \emph{destinations} des valeurs de première classe. Une destination représente un emplacement abstrait en mémoire destiné à être rempli par une valeur, et toutes les structures de données dans \destcalculus{} sont créées par remplissage de destination, au moyen d'opérateurs spécifiques.

L'opérateur le plus simple est celui permettant d'écrire une valeur dans une destination, ce qui consomme la destination et retourne \emph{unit} (le type ne contenant qu'une seule valeur, dont l'usage se rapproche de \texttt{void} dans les langages impératifs):
\[
[[ d ◀ x ]]
\]
Par cette expression, la valeur portée $[[x]]$ est écrite dans la cellule mémoire pointée par la destination $[[d]]$. Cette opération constitue la manière la plus simple d’utiliser une destination.

Il est également possible de remplir une destination avec un constructeur de données \emph{creux}, c'est à dire un constructeur de données où les champs sont laissés vides. L'opération retournera alors autant de nouvelles destinations que de champs laissés vides dans le constructeur, pour permettre leur remplissage ultérieur. Par exemple, pour une paire :

\[
[[ (d ⨞(,)) ►case ¹ν (d1, d2) ⟼ … ]]
\]

Ici, $[[d1]]$ et $[[d2]]$ sont des destinations pointant respectivement vers les deux champs du constructeur de paire qui a été écrit dans la cellule pointée par $[[d]]$. Elles devront être consommées (remplies) avant que la paire complète ne puisse être lue. Ce système de remplissage des destinations par des constructeurs creux est la base qui permet de construire des structures de données pas à pas, sans avoir besoin de les finaliser immédiatement.

L'accès à ce système de destinations permet d'exprimer de nombreux algorithmes en \emph{destination-passing style}, permettant parfois de net gains d'expressivité par rapport au style fonctionnel usuel.

Par exemple, il est possible d'implémenter une version \emph{tail-recursive}, en une passe, de la fonction $\texttt{map}$ sur les listes: 

\[
\newoperatorb
  {\ottkw{map'}}{[[(T ¹ν → U) ɷ → List T ¹ν → ⌊ List U ⌋ ¹ν ¹ν → ①]]}
  {[[map' f l dl]]}{\!\!\!\begin{array}[t]{l}[[
l ►case ¹ν {⮒
‥‥ˢ[] ⟼ dl⨞[],⮒
‥‥x ˢ:: xs ⟼ (dl⨞(::)) ►case ¹ν⮒
‥‥‥‥(dx, dxs) ⟼ dx ◀ f x ; map' f xs dxs}]]\end{array}}
\newoperator
  {\ottkw{map}}{[[(T ¹ν → U) ɷ → List T ¹ν → List U]]}
  {[[map f l]]}{[[from⧔' ((alloc @ (List U) ⧔ ⌊ List U ⌋ ¹ν) ►map dl ⟼ map' f l dl)]]}
\]

Ce genre de technique est notamment intéressant dans des langages fonctionnels stricts comme OCaml, où le côté \emph{tail-recursif} permet d'éviter l'explosion de la pile d'appels pour de grandes listes, sans nécessiter de construire une liste intermédiaire qu'il faut ensuite retourner (contrairement à l'approche \emph{tail-recursive} usuelle avec accumulateur).

\paragraph{Système de types pour \destcalculus{}}

Un tel langage nécessite de nombreuses garanties de sûreté pour s'assurer que les destinations sont correctement utilisées. En particulier, il est crucial de garantir qu'une destination est utilisée une seule et unique fois, pour garantir que le champ initialement vide d'une structure est bien rempli (une seule fois, pour éviter tout écrasement de données précédemment écrit) avant d'être lu.

Pour ce faire, nous utilisons un système de types linéaires, comme décrit dans la section précédente. Les destinations sont alors traitées comme des ressources linéaires, qui ne peuvent être ni dupliquées ni abandonnées. Chaque opération de remplissage de destination via $\blacktriangleleft$ or $\triangleleft$ consomme la destination, garantissant ainsi qu'elle ne peut pas être réutilisée.

\paragraph{\emph{Scope-escape} de destinations}

Dans \destcalculus{}, les destinations sont intrinsèquement liées au contexte de remplissage d'une structure à trou; seul espace lexical dans lequel elles sont valides et peuvent être remplies.

Cependant, un soucis majeur qui s'est posé dans la conception de \destcalculus{} est le \emph{scope escape}: en effet, il est possible, en chaînant intelligemment plusieurs contextes de construction de structures à trous, de stocker une destination à l'extérieur du contexte de remplissage de la structure associée. La destination semble alors ``consommée'', alors qu'en réalité elle n'a pas été remplie (seulement stockée pour un usage ultérieur), ce qui viole les garanties de sûreté du langage.

Il s'avère qu'un système de types linéaires classique n'est pas suffisant pour prévenir ce genre de situation. Pour y remédier, j'ai ajouté une deuxième dimension de contrôle des variables (en plus de la linéarité) : le contrôle d'âge. L'idée est d'associer, en plus de la multiplicité, une indication d'âge à chaque variable dans le contexte de typage (le \emph{mode} attachée à une variable dans le contexte de typage est alors une paire d'une multiplicité et d'un âge). Cette indication d'âge reflète le contexte de construction de structure à trous dans lequel la variable a été créée, et les règles de remplissages de destinations sont adaptées de sorte d'interdire la fuite d'une destination dans un contexte plus ancien que celui dont elle dépend (i.e. un contexte parent).

\paragraph{Propriétés de sûreté et preuve formelle}

J'ai équipé \destcalculus{} d'un système de type qui a été formalisé en Rocq, et j'ai prouvé les propriétés de sûreté usuelles par les théorèmes de réduction et progrès. Ces propriétés garantissent que les programmes bien typés dans \destcalculus{} ne peuvent pas se retrouver dans des états erronés, notamment en ce qui concerne l'usage des destinations.

Pour ce faire, il a été nécessaire de développer des techniques de typage nouvelles, notamment pour s'assurer que les destinations et trous restants pour une structure donnée sont correctement équilibrés : il doit rester exactement autant de destinations non consommées que de trous restants dans la structure. Cela a été possible par une technique de typage soustractive, où destinations et trous apparaissent dans le contexte de typage, mais s'annulent (ce qui permet de former un terme clos) s'ils sont correctement appairés. Nous avons donc la garantie que tout terme ou programme clos ne peut pas contenir de destinations ou trous non appairés.

\section*{Implémentation en Haskell d'une version restreinte de \destcalculus{}}

L'idée de cette thèse était également d'aboutir à une implémentation concrète d'un système de passage de destinations sûr pour un langage fonctionnel pur, Haskell.

Cependant, si Haskell dispose de support pour les types linéaires via l'extension Linear Haskell, il ne permet pas d'exprimer nativement les notions d'âge qui ont été développées spécifiquement pour \destcalculus{}. Il n'est donc pas possible d'éviter les problèmes de \emph{scope escape} par le biais de ces mécanismes.

\`A la place, dans cette première implémentation, j'ai pris une décision drastique : empêcher les destinations d'être remplies par des ressources linéaires. Cette fonctionnalité est en effet un prérequis pour que le \emph{scope escape} puisse se produire, et en la retirant, on évite le problème. Cependant, cette restriction limite également l'expressivité du système. En particulier, une structure de données construite via des destinations ne peut pas stocker de données linéaires, ce qui restreint légèrement les cas d'utilisation possibles.

Un travail technique a également été nécessaire pour trouver comment faire des mutations en mémoire dans Haskell, sans que cela ne pose des problèmes avec le ramasse-miettes. J'ai pour cela choisi d'utiliser les \emph{compact regions}, déjà supportées par le compilateur GHC, qui permettent de gérer des blocs de mémoire semi-manuellement, dans lequel le ramasse-miettes ne s'immisce pas, sauf quand l'entièreté de la région n'est plus utilisée (auquel cas elle est libérée d'un coup).

Cette implémentation permet, au final, de conserver de nombreux avantages des approches de passage de destinations, et j'ai obtenu des résultats encourageants dans les benchmarks qui comparent des algorithmes fonctionnels usuels et leur équivalent en \emph{destination-passing style}.

\section*{Vers l'expressivité complète de \destcalculus{} en Haskell}

Il convient de se demander s'il est possible d'implémenter l'entièreté de \destcalculus{} en Haskell, en levant les restrictions mentionnées plus haut.

J'ai donc dédié un chapitre de la thèse à l'exploration de nouvelles techniques, qui permettent d'autoriser le remplissage de destinations par des ressources linéaires, tout en excluant toute possibilité de \emph{scope escape}.

Une des possibilités est de revenir à un système à la Minamide pour les destinations pour ressources linéaires, c'est-à-dire un système où ces destinations ne sont pas exposées directement aux programmeurs (elles ne peuvent donc pas fuiter vers un contexte parent). Cependant, cette approche perd une partie de l'attrait des destinations en tant que valeurs de première classe.

L'autre approche que nous développons est l'utilisation de \emph{lenses} linéaires. Ces dernières permettent de représenter un focus sur une partie d'une structure de données, qui peut être lue et modifiée, de façon très contrôlée, de par la structure même des \emph{lenses}. 

Nous utilisons les \emph{lenses} linéaires pour permettre à l'utilisateur de représenter les manipulations qu'il veut effectuer sur les destinations des structures à trous, sans pour autant exposer directement les destinations elles-mêmes. On retrouve la même flexibilité pratique que le système de \destcalculus{}, sans besoin d'un système d'âge pour en assurer la sûreté, mais au prix d'une ergonomie réduite et de signature de types assez lourdes.

\section*{Conclusion et travaux futurs}

Dans cette thèse, j'ai présenté \destcalculus{}, un langage fonctionnel pur intégrant le passage de destinations à son c\oe{}ur, avec un système de types linéaires et un mécanisme de contrôle d'âge pour assurer la sûreté de l'usage des destinations. J'ai formalisé le langage et prouvé ses propriétés de sûreté, avant de développer plusieurs implémentations en Haskell, avec différents niveaux de compromis entre expressivité et complexité des mécanismes assurant la sûreté (puisque nous ne disposons pas du système d'âge développé spécialement pour \destcalculus{}).

Ce travail présente des résultats positifs sur la pertinence du passage de destinations -- qui est historiquement une technique impérative -- dans un contexte fonctionnel pur, mais pose également les bases théoriques pour analyser et prouver la sûreté de futurs systèmes similaires.

Il existe plusieurs axes de travaux futurs pour poursuivre cette recherche. Tout d'abord, il serait intéressant d'explorer des optimisations supplémentaires pour les implémentations en Haskell, afin de maximiser les gains de performance apportés par le passage de destinations, et également envisager des implémentations dans d'autres espaces mémoires que les \emph{compact regions}. Ensuite, l'étude de l'intégration de ces techniques dans d'autres langages, comme OCaml ou Rust, pourrait ouvrir la voie à une adoption plus large, sous réserve que ces langages se voient dotés d'une extension de leur système de types pour la gestion des types linéaires. Enfin, d'un point de vue théorique, il serait pertinent d'adapter la preuve formelle de sûreté de \destcalculus{} pour couvrir les variantes implémentées en Haskell, afin de garantir formellement que les techniques alternatives développées dans ces implémentations sont tout aussi sûres que le système original.

\end{document}
