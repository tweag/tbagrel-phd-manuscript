\chapter{Extending DPS support for linear data structures}\label{chap:ext-linear-nonlinear}

One issue with the approach of the previous chapter is that we are not able to build data structures hosting linear data with a destination-based approach. This is the consequence of having a lot of flexibility in the handling of destinations, without a system of ages to prevent scope escape in a fine-grained manner. So we had to use \emph{unrestrictedness} as a barrier for destinations.

Previous work however, such as \cite{minamide_functional_1998}, or \cite{lorenzen_searchtree_2024}, would allow for efficient queues (see \cref{ssec:efficient-queue}) or any structure with holes to store linear data, without issues with scope escape. Mainly because they don't have a concept of destinations; we can only fill holes in a structure by interacting with the incomplete structure (ampar) itself. So we ought to find a way for our Haskell implementation to be at least as expressive as these works.

\section{Challenges of destinations for linear data}\label{sec:dps-lin-challenges}

If we now allow destinations to be filled with linear data\footnote{Starting from this point, we will call \emph{linear destination} an object of type $[[⌊ T ⌋ ˥]]$ or corresponding \mintinline{haskellc}/Dest 1 t/, that is, a destination that can host linear data. Similarly, an \emph{unrestricted destination} will be an object of type $[[⌊ T ⌋ ɷ]]$ or \mintinline{haskellc}/Dest ω t/. Regardless, a destination is always, itself, a resource that must be managed linearly.}, we have to be extremely careful about potential scope escape. One observation is that scope escape can only happen when we let the user fill an older linear destination in a newer scope.

A potential remedy would be to not allow older linear destinations to be filled using \mintinline{haskellc}/fillLeaf/ or \mintinline{haskellc}/fillComp/ functions. Instead, linear destinations could only be filled with a value by operating on the ampar they belong to, as in \cite{minamide_functional_1998} and \cite{lorenzen_searchtree_2024}. We will use the base name \mintinline{haskellc}/extend/ for this new family of operators. Unrestricted destinations, on the other hand, could still be used with \mintinline{haskellc}/fill/-like functions. Filling a destination with a hollow constructor cannot cause any scope escape issues, so it's safe to do with \mintinline{haskellc}/fill @lCtor/ for both linear and unrestricted destinations. Let's see what the API could look like:

\begin{minted}[linenos,escapeinside=°°]{haskellc}
data Ampar s t
data Dest m t  -- m is the multiplicity, either 1 or ω
newAmpar ⩴ Token ⊸ Ampar s (Dest 1 s)
updWith ⩴ Ampar s t ⊸ (t ⊸ u) ⊸ Ampar s u

-- for unrestricted destinations
fillLeaf ⩴ t → Dest ω t → ()

-- for linear destinations
extendLeaf ⩴ t ⊸ Ampar s (Dest 1 t) ⊸ Ampar s ()
\end{minted}

The idea is that \mintinline{haskellc}/extendLeaf/ is a way of opening a new scope, and filling the linear destination, belonging to that fresh scope, immediately, without letting the user interfere. So we are confident that the linear destination filled by \mintinline{haskellc}/extendLeaf/ is strictly younger than whatever ends up stored into it, which prevents scope escape (recall the sane example of \cref{sec:scope-escape-dests}, where an older destination is stored into a younger one with no issues).

Except\ldots{}it doesn't work:

\begin{minted}[linenos,escapeinside=°°]{haskellc}
newAmpar tok0 `updWith` \(d0 ⩴ Dest 1 (Dest 1 t)) ->
  newAmpar tok1 `updWith` \(d1 ⩴ Dest 1 t) ->
    (newAmpar tok2 `updWith` \(d2 ⩴ Dest ω ()) -> d2 &fillLeaf () ; d0) &extendLeaf d1
\end{minted}

In this particularly cursed but valid excerpt\footnote{It's valid in Linear Haskell, but the example would be rejected by \destcalculus{}, as \mintinline{haskellc}/d0/ would have age $[[↑^2]]$ when it is used as a variable in the innermost scope, which isn't allowed by rule \rref*{\CTyTerm\CSep\CId}.}, we hide an old destination \mintinline{haskellc}/d0/ inside the nest of a fresher one \mintinline{haskellc}/d2/ that we've just consumed. So we have an ampar \mintinline{haskellc}/(newAmpar `updWith` \d2 -> d2 &fillLeaf () ; d0)/ whose right-hand side contains a destination \mintinline{haskellc}/d0/ which isn't its own; and we can use that together with \mintinline{haskellc}/extendLeaf/ to cause scope escape (as \mintinline{haskellc}/d1/ get stored in the outermost ampar)!

There seems to be an inevitable friction between having a flexible \mintinline{haskellc}/updWith/ function, and having safe linear destinations, when we don't have a proper age system to ensure there is no cheating with scopes.

\paragraph{Restricting \mintinline{haskellc}/updWith/}

If we want to prevent older destinations from hiding in newer ampars, we can ask for \mintinline{haskellc}/updWith/ to \emph{not} capture any linear resource. That way, the only destinations accessible and usable in the scope of \mintinline{haskellc}/updWith/ are the one coming immediately from the ampar being opened.

This is done by changing the signature from \mintinline{haskellc}/updWith ⩴ Ampar s t ⊸ (t ⊸ u) ⊸ Ampar s u/ to \mintinline{haskellc}/updWith ⩴ Ampar s t ⊸ (t ⊸ u) → Ampar s u/. Notice the unrestricted function arrow \mintinline{haskellc}/→/: it means the linear function supplied by the user must not capture anything linear (but still must use its argument linearly). Adding this drastic restrictions has many consequences. 

First, obviously, we cannot use any linear resource coming from outer scopes inside the scope of \mintinline{haskellc}/updWith/. In particular, we cannot use a \mintinline{haskellc}/Token/ coming from the top-level linear scope. Instead, we have to start a new nested linear scope (by calling \mintinline{haskellc}/withToken/) if we want to create new ampars in that scope, or tweak \mintinline{haskellc}/updWith/ to also provide a linear token to the inner scope: \mintinline{haskellc}/updWith ⩴ Ampar s t ⊸ ((t, Token) ⊸ u) → Ampar s u/.

Also, we still cannot fill linear destinations using a \mintinline{haskellc}/fillLeaf/ or \mintinline{haskellc}/fillComp/ function, for two main reasons. One being that we cannot bring linear resources in the scope anyway, so we wouldn't have something useful to fill into the linear destination. The second being that in addition to scope escape, we must be careful about sibling destinations from the same scope interacting with one another:
\begin{minted}[linenos,escapeinside=°°]{haskellc}
fromAmpar' (
  newAmpar @(t, Dest 1 t) tok `updWith` \(d :: Dest 1 (t, Dest 1 t)) ->
    case (d &fill @'(,)) of (dt :: Dest 1 t, ddt :: Dest 1 (Dest 1 t)) ->
      ddt &fillLeaf dt
)
\end{minted}
Here, we create a new ampar for a pair of a \mintinline{haskellc}/t/ and a \mintinline{haskellc}/Dest 1 t/. After filling the root destination with a hollow pair constructor, we get two destinations, \mintinline{haskellc}/dt/ and \mintinline{haskellc}/ddt/. If we have access to a \mintinline{haskellc}/fillLeaf/ function operating with a linear destination on the left, we can actually put \mintinline{haskellc}/dt/ into \mintinline{haskellc}/ddt/. Because we've consumed the two destinations and unit is returned, it seems that the ampar is complete, while in fact we've never provided a value of type \mintinline{haskellc}/t/ for the first field of the pair! So the structure is still incomplete while we are allowed to call \mintinline{haskellc}/fromAmpar'/ on it and read it!

So far we hadn't spoke about that danger, because mechanisms used to stop scope escape in \cref{chap:dest-calculus,chap:dps-haskell}, that is, the age system, or absence of linear destinations, are enough to also prevent sibling destinations interacting with one another. But here, the limitation put on \mintinline{haskellc}/updWith/ (not allowing capture of linear resources) only stops scope escape, but not this other issue, because both sibling destinations are coming from the same, freshest scope. Hence, we still cannot have a function \mintinline{haskellc}/fillLeaf/ or \mintinline{haskellc}/fillComp/ operating on linear destinations.

\section{\mintinline{haskellc}/extend/ functions for ampars with a single hole}\label{sec:single-hole}

We've just seen that to use linear destinations safely, we need operators that work on closed ampars, instead of destinations. In fact, that is exactly what happens in \cite{minamide_functional_1998}, or \cite{lorenzen_searchtree_2024}: they only allow incomplete structures with one hole, and extending the structure happens by manipulating the whole incomplete structure itself, not destinations (as they don't exist in these works).

For starters, let's start on that way, and design operators for ampars with only one hole, so exactly one destination on their right-hand side. If we want always only one hole, then it means we cannot have equivalents for functions such that \mintinline{haskellc}/fill @'(:)/ that plugs a new hollow constructor with two new holes. Instead, we must ask the user to specify a value for all except one field of the newly added constructor, so that only one new hole remains\footnote{As we said above, it's still possible to use \mintinline{haskellc}/fill @'(:)/ on a linear destination, creating two new linear destinations. However, after that, we would have no way to fill either of these linear destinations, as \mintinline{haskellc}/extendLeaf/ or \mintinline{haskellc}/extendComp/ work on an ampar with just a single destination on the right-hand side, and \mintinline{haskellc}/fillLeaf/ or \mintinline{haskellc}/fillComp/ work only on unrestricted destinations.}. The signature of such a function would be as follows:

\begin{minted}[linenos,escapeinside=°°]{haskellc}
extend ⩴ ∀ lCtor k t s m fiTys kthFiTy othFiTys.
          (OnlyLinear lCtor t,
           FieldTypes lCtor t ~ fiTys,
           At k fiTys ~ kthFiTy, Remove k fiTys ~ othFiTys) ⇒
          Ampar s (Dest m t) ⊸ othFiTys %m→ Ampar s (Dest m kthFiTy)
\end{minted}

There's a lot to decipher here. \mintinline{haskellc}/FieldsTypes/ is a type family that returns the types of the fields for a given constructor, specified in its type-lifted representation \mintinline{haskellc}/lCtor/ and the type \mintinline{haskellc}/t/ to which the constructor belongs. For example, \mintinline{haskellc}/FieldsTypes '(:) [Int]/ resolves to \mintinline{haskellc}/(Int, [Int])/. \mintinline{haskellc}/At k/ is a type family that returns the \mintinline{haskellc}/k/\textsuperscript{th} element (i.e. type) of a tuple type, and similarly, \mintinline{haskellc}/Remove k/ returns the same tuple type it is given, with the \mintinline{haskellc}/k/\textsuperscript{th} removed.

The symbol \mintinline{haskellc}/~/ is for type equality constraint, and can be used as above as a way to bind type variables to complex type-level expressions in a function or type class signature. Above, we say that \mintinline{haskellc}/fiTys/ represents all field types of \mintinline{haskellc}/lCtor/, \mintinline{haskellc}/kthFiTy/ is the \mintinline{haskellc}/k/\textsuperscript{th} of these, and \mintinline{haskellc}/othfiTys/ is all the other field types in a tuple except the \mintinline{haskellc}/k/\textsuperscript{th} one.

For instance, in \mintinline{haskellc}/extend @'(:) @0 @[Int]/, \mintinline{haskellc}/kthFiTy/ is \mintinline{haskellc}/Int/, and \mintinline{haskellc}/othFiTys/ is the one-element tuple type \mintinline{haskellc}/Solo [Int]/\footnote{We could also decide to use the type \mintinline{haskellc}/t/ directly instead of \mintinline{haskellc}/Solo t/ for when there is only one element remaining, as we did for \mintinline{haskellc}/UDestsOf/ in \cref{chap:dps-haskell}.}. Conversely, in \mintinline{haskellc}/extend @'(:) @1 @[Int]/, \mintinline{haskellc}/kthFiTy/ is \mintinline{haskellc}/[Int]/, and \mintinline{haskellc}/othFiTys/ is \mintinline{haskellc}/Solo Int/.

In practice, \mintinline{haskellc}/extend/ takes an ampar whose right side is a destination of type \mintinline{haskellc}/t/, with multiplicity \mintinline{haskellc}/m/. It then allocates a new hollow constructor (specified by \mintinline{haskellc}/lCtor/), consumes \mintinline{haskellc}/othFiTys/ at multiplicity \mintinline{haskellc}/m/ to fill all the fields of the new hollow constructor except the \mintinline{haskellc}/k/\textsuperscript{th}, and then returns a destination with same multiplicity \mintinline{haskellc}/m/ for that remaining field of type \mintinline{haskellc}/kthFiTy/.

Note that \mintinline{haskellc}/extend/ doesn't support constructors with 0 fields (it would make the signature of the function way to complex), as these can be plugged into the structure, like any other complete value, with \mintinline{haskellc}/extendLeaf/ anyway:

\begin{minted}[linenos,escapeinside=°°]{haskellc}
extendLeaf ⩴ ∀ s t m. t %m→ Ampar s (Dest m t) ⊸ Ampar s ()
\end{minted}

Here we've made \mintinline{haskellc}/extendLeaf/ multiplicity-polymorphic, compared to the initial version presented above. But its behavior is the same.

Because we only have one destination on the right-hand side of any ampar, that is consumed and not replaced with a new one when calling \mintinline{haskellc}/extendLeaf/, we could alternatively return the completed structure, instead of returning an \mintinline{haskellc}/Ampar s ()/:
\begin{minted}[linenos,escapeinside=°°]{haskellc}
fromAmparWithLeaf ⩴ ∀ s t m. t %m→ Ampar s (Dest m t) ⊸ s
fromAmparWithLeaf = fromAmpar' . extendLeaf
\end{minted}

Note also that above, for \mintinline{haskellc}/extend/, we assumed that the constructor in question only has linear fields\footnote{In \destcalculus{}, every data constructor has linear fields, except the exponential constructor $\expcons{[[m]]}$ which has a single field of mode $[[m]]$. In Haskell however, constructors have only linear fields by default, but can have unrestricted fields when the corresponding datatype is defined with GADT syntax and that an unrestricted arrow \mintinline{haskellc}/→/ is following the field's type. An unrestricted field is a way to hold unrestricted data without explicit need for \mintinline{haskellc}/Ur/.}, as the multiplicity \mintinline{haskellc}/m/ at which we consume the values for the fields, and at which we return the new destination, are the same as the multiplicity of the parent destination. We reflect that by the pseudo-constraint \mintinline{haskellc}/OnlyLinear lCtor t/. Ideally, we could go further and be polymorphic over the multiplicity of each field, however, to this date, we cannot get that information through GHC.Generics (GHC.Generics is only implemented for constructors having just linear fields\footnote{So the constraint \mintinline{haskellc}/OnlyLinear lCtor t/ would only be needed in practice if GHC.Generics were to provide, in the future, an instance of \mintinline{haskellc}/Generic t/ for types \mintinline{haskellc}/t/ defined with GADT syntax.}). That also means we have to build a custom version of \mintinline{haskellc}/extend/ for the \mintinline{haskellc}/Ur/ constructor:

\begin{minted}[linenos,escapeinside=°°]{haskellc}
extendUr ⩴ ∀ s t m. Ampar s (Dest m (Ur t)) ⊸ Ampar s (Dest ω t)
\end{minted}

The last function that we need, in this world is \mintinline{haskellc}/extendComp/, to plug two ampars together:
\begin{minted}[linenos,escapeinside=°°]{haskellc}
extendComp ⩴ ∀ s t u. Ampar s (Dest 1 t) ⊸ Ampar t u ⊸ Ampar s u
\end{minted}
In \mintinline{haskellc}/extendComp/, we need the destination in the parent ampar to be linear, as we fill it with an ampar, which is a linear resource\footnote{Even in a \destcalculus{}-like world, where ampars don't have to be linear, the destination used for composition using $\mathop{\triangleleft\mycirc}$ / \mintinline{haskellc}/fillComp/ / \mintinline{haskellc}/extendComp/ must be linear. The reason is that if we write the child ampar into an unrestricted destination of the parent ampar, then we would need to update the remaining destinations of this child ampar to be unrestricted too, and this is hard to express when we can have arbitrarily complex types on the right-hand side of an ampar.}.

\section{Arbitrary type on the right-hand side of ampars for linear data}\label{sec:linear-lens}

Being limited to only one destination on the right-hand side of ampars is not ideal. Indeed, we stay at the same expressivity level than existing work.

Going back to arbitrary types on the right hand-side of ampars, for instance to allow multiple destinations, as we did in \cref{chap:dest-calculus,chap:dps-haskell}, creates new challenges. Indeed, when we had only one destination for each ampar, we could operate on the destination through the ampar itself, with no choice to be made: there was only one destination that could be filled. If we have now an arbitrary type on the right-hand side of ampars, and we still want to operate on the destinations without giving direct access to them to the user (the motivations are still the same; work around the fact that \mintinline{haskellc}/updWith/ is now non-capturing, and also prevent scope escape/malicious interaction between sibling destinations), then we need a way for the user to select which destination inside the right-hand side of the ampar they want to operate on.

One idea for that is to ask the user for a linear lens. First, let's define what it is.

Lenses are a pattern for defining functional getters and setters that compose easily in an immutable functional programming language. A lens of type \mintinline{haskellc}/Lens t1 t2 u1 u2/ has two components (at least conceptually):
\begin{itemize}
    \item a getter for a value of type \mintinline{haskellc}/u1/ somewhere inside the structure of type \mintinline{haskellc}/t1/, which establishes the \emph{focus} of the lens;
    \item a way to transform a structure of type \mintinline{haskellc}/t1/ into a structure of type \mintinline{haskellc}/t2/ by replacing the (focused) value of type \mintinline{haskellc}/u1/ by a value of type \mintinline{haskellc}/u2/.
\end{itemize}

Although it isn't the most efficient and practical representation, non-linear lenses can be implemented by the following datatype:
\begin{minted}[escapeinside=°°]{haskellc}
data LensNL t1 t2 u1 u2 = ¤LensNL
  { view ⩴ t1 → u1  -- just get u1 out of t1, discard the rest
  , update ⩴ t1 → u2 → t2  -- discard the u1 inside t1 and replace it with a u2 to make a t2
  }
\end{minted}
For linear lenses, we are not allowed to use the \mintinline{haskellc}/view/ and \mintinline{haskellc}/update/ components separately; otherwise we could drop parts of the original structure of type \mintinline{haskellc}/t1/. So instead, we group the two functions into one:
\begin{minted}[escapeinside=°°]{haskellc}
newtype Lens t1 t2 u1 u2 = ¤Lens (t1 ⊸ (u1, u2 ⊸ t2))
\end{minted}
With a linear lens of type \mintinline{haskellc}/Lens t1 t2 u1 u2/, we can split a structure of type \mintinline{haskellc}/t1/ into a pair of a value of type \mintinline{haskellc}/u1/ (the focus), and a closure of type \mintinline{haskellc}/u2 ⊸ t2/ that carries all the rest of the original \mintinline{haskellc}/t1/, and is ready to produce a structure of type \mintinline{haskellc}/t2/ if we give it a \mintinline{haskellc}/u2/. Both of these have to be consumed if we want to respect linearity.

The simplest lens is the standard getter and setter, where \mintinline{haskellc}/t1 = t2/ and \mintinline{haskellc}/u1 = u2/, and thus, \mintinline{haskellc}/Lens t t u u/ becomes an alias for \mintinline{haskellc}/t ⊸ (u, u ⊸ t)/. There, the second element of the pair, of type \mintinline{haskellc}/u ⊸ t/, is really just a functional representation of a \mintinline{haskellc}/t/ missing a \mintinline{haskellc}/u/ to be complete! For example:
\begin{minted}[linenos,escapeinside=°°]{haskellc}
data Triple t1 t2 t3 = ¤Triple { first ⩴ t1, second ⩴ t2, third ⩴ t3 }

fstMono ⩴ Lens (Triple t1 t2 t3) (Triple t1 t2 t3) t1 t1
fstMono (¤Triple { first, second, third }) = ¤Lens (first, \newFirst -> Pair { newFirst, second, third })
\end{minted}

As we see, when we are operating on a polymorphic type such as \mintinline{haskellc}/Triple/, it is a bit silly to restrict our lens to the same type \mintinline{haskellc}/t1/ for both the original value at the focus, and the updated one. We gain much more flexibility by doing:
\begin{minted}[linenos,escapeinside=°°]{haskellc}
fst ⩴ Lens (Triple t1 t2 t3) (Triple t4 t2 t3) t1 t4
fst (¤Triple { first, second, third }) = ¤Lens (first, \newFirst -> Pair { newFirst, second, third })
\end{minted}

\paragraph{Lenses to select destinations to operate on}

With linear lenses, the user can communicate which destination they want to focus, and we gain a way to inject back the potential newly produced destinations at the right place on the right-hand side of the ampar:
\begin{minted}[linenos,escapeinside=°°]{haskellc}
extendFocused ⩴ ∀ lCtor u t1 t2 s m.
                (OnlyLinear lCtor u) ⇒
                Lens t1 t2 (Dest m u) (DestsOf lCtor m u) → Ampar s t1 ⊸ Ampar s t2

extendWithPairOnFirst ⩴ Ampar s (Triple (Dest m (t11, t12)) t2 t3) ⊸ Ampar s (Triple (Dest m t11, Dest m t12) t2 t3)
extendWithPairOnFirst ampar = ampar &(fst &extendFocused @'(,))
\end{minted}

\section{Limitations of this system}

The situation is still not perfectly satisfying, but we don't think that a single perfect balance between expressiveness and simplicity exists for DPS programming in Haskell, given the constraint of using an existing type system.

Here, we can have at most two usable layers of nesting for destinations. But that's enough for most use-cases, and in particular, it let us implement the breadth-first traversal of binary trees using efficient queues!

% TODO: Truc bizarre, dans dps haskell, on peut composer des structures alors que les dests sont "unrestricted"
% TODO: scope escape caché via fillComp -> possible car toAmpar est linéaire

\section{Full API and breadth-first tree traversal, updated}

\begin{listing}[t]
\figtextsize
\begin{minted}[linenos,escapeinside=°°]{haskellc}
data Token
dup ⩴ Token ⊸ (Token, Token)
drop ⩴ Token ⊸ ()
withToken ⩴ ∀ t. (Token ⊸ Ur t) ⊸ Ur t

type Region r ⩴ Constraint
inRegion ⩴ ∀ t. (∀ r. Region r ⇒ t) ⊸ t

data Ampar r s t
newAmpar ⩴ ∀ r s. Region r ⇒ Token ⊸ Ampar s (Dest r 1 s)
newAmparBesides ⩴ ∀ r1 r2 s t u. (Region r1, Region r2) ⇒ Ampar r1 s t ⊸ (Ampar r1 s t, Ampar r2 u (Dest r 1 u))
toAmpar ⩴ ∀ r s. Region r ⇒ Token ⊸ s ⊸ Ampar r s () -- now linear in s
fromAmpar  ⩴ ∀ r s t. Region r ⇒ Ampar r s (Ur t) ⊸ (s, Ur t)
fromAmpar' ⩴ ∀ r s. Region r ⇒ Ampar r s () ⊸ s
updWith ⩴ ∀ r s t u. Region r ⇒ Ampar r s t ⊸ (t ⊸ u) → Ampar r s u -- non-capturing now
updWithToken ⩴ ∀ r s t u. Region r ⇒ Ampar r s t ⊸ ((t, Token) ⊸ u) → Ampar r s u

data Dest r m t
type family DestsOf lCtor r m t -- now multiplicity-polymorphic

-- API for unrestricted destinations
fill ⩴ ∀ lCtor r t. Region r ⇒ Dest r ω t ⊸ DestsOf lCtor r ω t
fillLeaf ⩴ ∀ r t. Region r ⇒ t → Dest r ω t ⊸ ()

-- API for ampars with linear destinations

-- simplified
extend ⩴ ∀ lCtor r k t s m fiTy kthFiTy othFiTys.
          (Region r, OnlyLinear lCtor t,
           FieldTypes lCtor t ~ fiTys,
           At k fiTys ~ kthFiTy, Remove k fiTys ~ othFiTys) ⇒
          Ampar r s (Dest r m t) ⊸ othFiTys %m→ Ampar r s (Dest r m kthFiTy)
extendUr ⩴ ∀ r s t m. Region r ⇒ Ampar r s (Dest r m (Ur t)) ⊸ Ampar r s (Dest r ω t)
extendLeaf ⩴ ∀ r s t m. Region r ⇒ t %m→ Ampar r s (Dest r m t) ⊸ Ampar r s ()
extendComp ⩴ ∀ r s t u. Region r ⇒ Ampar r s (Dest r 1 t) ⊸ Ampar r t u ⊸ Ampar r s u

-- with lenses
extendFocused ⩴ ∀ lCtor r u t1 t2 s m.
                (Region r, OnlyLinear lCtor u) ⇒
                Lens t1 t2 (Dest r m u) (DestsOf lCtor r m u) ⊸ Ampar r s t1 ⊸ Ampar r s t2
extendFocusedUr ⩴ ∀ r u t1 t2 s m. (Region r) ⇒
                  Lens t1 t2 (Dest r m (Ur u)) (Dest r ω u) ⊸ Ampar r s t1 ⊸ Ampar r s t2
extendFocusedLeaf ⩴ ∀ r u t1 t2 s m. (Region r) ⇒
                    u %m→ Lens t1 t2 (Dest r m u) () ⊸ Ampar r s t1 ⊸ Ampar r s t2
                    
                    -- TODO: inverse order
extendFocusedComp ⩴ ∀ r u t1 t2 s m. (Region r) ⇒
                    Lens t1 t2 (Dest r m u) (DestsOf lCtor r m u) ⊸ Ampar r s t1 ⊸ Ampar r s t2

\end{minted}
\caption{More flexible Destination API (still using compact regions)}
\label{table:destination-api-regions-v2}
\end{listing}

% TODO: On perd en généralité car on n'a plus fillComp

% Si on ne connait pas l'âge d'une dest, mais qu'on sait qu'elle a un age fini inconnu, alors on peut la remplir avec un truc omega infini
% Se justifie via un opérateur de retard?
% Age inconnu = plus petit élément du semiring

% updWith non capturant

% Sinon on peut faire :

% ampar1 `updWith` \d1 ->
% 	ampar2 `updWith` \d2 ->
% 		(ampar3 `updWith` \d3 -> (d1, d3)) & (fst & extendFocusedLeaf d2)

