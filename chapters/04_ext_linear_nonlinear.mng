\chapter{Extending DPS support for linear data structures}\label{chap:ext-linear-nonlinear}

One problem with the approach of the previous chapter is that we are not able to build data structures hosting linear data with a destination-based approach.

This is unfortunate, because previous work, such as \cite{minamide_functional_1998}, or \cite{lorenzen_searchtree_2024} would allow for efficient queues to store linear data, without issues with scope escape.

One observation is that scope escape can only happen when we let the user have direct access to a linear destination\footnote{Starting from this point, we will call \emph{linear destination} an object of type $[[⌊ T ⌋ ˥]]$ or corresponding \mintinline{haskellc}/Dest 1 t/, that is, a destination that can host linear data. Similarly, an \emph{unrestricted destination} will be an object of type $[[⌊ T ⌋ ɷ]]$ or \mintinline{haskellc}/Dest ω t/}. That's one necessary condition for scope escape to happen.

\subsection{Restricting ampars for linear data to a single hole}\label{ssec:single-hole}

As we've seen in previous chapter, it's enough to forbid linear destinations to prevent any potential scope escape, and recover a safe system without the need for ages. But we could be more subtle, and allow linear destinations on the right-hand side of an ampar, while preventing the user from ever accessing them.

If we do so, how could the user use these destinations to build a structure? Well, we need new operators, that operate on a closed ampars, instead of a destination. In fact, that is exactly what happens in \cite{minamide_functional_1998}, or \cite{lorenzen_searchtree_2024}: they only allow incomplete structures with one hole, and extending the structure happens by manipulating the whole incomplete structure itself, not destinations (as they don't exist in these works).

If we only allow one hole, then it means we cannot have functions such that \mintinline{haskellc}/fill @'(:)/ that plugs a new hollow constructor with two new holes. The user must specify a value for all except one fields of the added constructor.
The signature of such a function would be as follows:

\begin{minted}[linenos,escapeinside=°°]{haskellc}
extend ⩴ ∀ lCtor k t s m fiTy kthFiTy othFiTys.
          (OnlyLinear lCtor t,
           FieldTypes lCtor t ~ fiTys,
           At k fiTys ~ kthFiTy, Remove k fiTys ~ othFiTys) ⇒
          Ampar s (Dest m t) ⊸ othFiTys %m→ Ampar s (Dest m kthFiTy)
\end{minted}

There's a lot to decipher here. \mintinline{haskellc}/FieldsTypes/ is a type family that returns a tuple of the types of the fields for a given constructor, specified in its type-lifted representation \mintinline{haskellc}/lCtor/ and the type \mintinline{haskellc}/t/ to which the constructor belongs. For example, \mintinline{haskellc}/FieldsTypes '(:) [Int]/ resolves to \mintinline{haskellc}/(Int, [Int])/. \mintinline{haskellc}/At k/ is a type family that returns the \mintinline{haskellc}/k/\textsuperscript{th} element (i.e. type) of a tuple type, and similarly, \mintinline{haskellc}/Remove k/ returns the same tuple type it is given, with the \mintinline{haskellc}/k/\textsuperscript{th} removed.

The symbol \mintinline{haskellc}/~/ is for type equality constraint, and can be used as above as a way to bind type variables to complex type-level expressions in a function or type class signature. Above, we say that \mintinline{haskellc}/fiTys/ represents all field types of \mintinline{haskellc}/lCtor/, \mintinline{haskellc}/kthFiTy/ is the \mintinline{haskellc}/k/\textsuperscript{th} of these, and \mintinline{haskellc}/othfiTys/ is all the other field types in a tuple except the \mintinline{haskellc}/k/\textsuperscript{th} one.

For instance, in \mintinline{haskellc}/extend @'(:) @0 @[Int]/, \mintinline{haskellc}/kthFiTy/ would be \mintinline{haskellc}/Int/, and \mintinline{haskellc}/othFiTys/ would be the one-element tuple type \mintinline{haskellc}/Solo [Int]/. Conversely, in \mintinline{haskellc}/extend @'(:) @1 @[Int]/, \mintinline{haskellc}/kthFiTy/ would be \mintinline{haskellc}/[Int]/, and \mintinline{haskellc}/othFiTys/ would be \mintinline{haskellc}/Solo Int/.

\mintinline{haskellc}/extend/ takes an ampar whose right side is a destination of type \mintinline{haskellc}/t/, with multiplicity \mintinline{haskellc}/m/. It then allocates a new hollow constructor (specified by \mintinline{haskellc}/lCtor/), consumes \mintinline{haskellc}/othFiTys/ at multiplicity \mintinline{haskellc}/m/ to fill all the fields of the new hollow constructor except the \mintinline{haskellc}/k/\textsuperscript{th}, and then returns a destination with same multiplicity \mintinline{haskellc}/m/ for that remaining field of type \mintinline{haskellc}/kthFiTy/.

Note that \mintinline{haskellc}/extend/ doesn't support constructors with 0 fields, as these can be plugged into the structure, like any other complete value, with \mintinline{haskellc}/extendLeaf/:

\begin{minted}[linenos,escapeinside=°°]{haskellc}
extendLeaf ⩴ ∀ s t m. Ampar s (Dest m t) ⊸ t %m→ Ampar s ()
\end{minted}
Because we only have one destination on the right-hand side of the ampar, that has now been consumed, we could directly return the completed structure, instead of returning an \mintinline{haskellc}/Ampar s ()/:
\begin{minted}[linenos,escapeinside=°°]{haskellc}
fromAmparWithLeaf ⩴ ∀ s t m. Ampar s (Dest m t) ⊸ t %m→ s
fromAmparWithLeaf = fromAmpar' . extendLeaf
\end{minted}

Note also that above, for \mintinline{haskellc}/extend/, we assumed that the constructor in question only has linear fields, as the multiplicity at which we consume the values for the fields, and at which we return the new destination, are the same as the multiplicity of the parent destination. We reflect that by the pseudo-constraint \mintinline{haskellc}/OnlyLinear lCtor t/. Ideally, we could go further and be polymorphic over the multiplicity of each field, however, to this date, we cannot get that information through GHC.Generics (GHC.Generics is only implemented for constructors having just linear fields). That also means we will have to build a custom version of \mintinline{haskellc}/extend/ for the \mintinline{haskellc}/Ur/ constructor:

\begin{minted}[linenos,escapeinside=°°]{haskellc}
extendUr ⩴ ∀ s t m. Ampar s (Dest m (Ur t)) ⊸ Ampar s (Dest ω t)
\end{minted}

The last function that we need, in this world is \mintinline{haskellc}/extendComp/, to plug two ampars together:
\begin{minted}[linenos,escapeinside=°°]{haskellc}
extendComp ⩴ ∀ s t u. Ampar s (Dest 1 t) ⊸ Ampar t u ⊸ Ampar s u
\end{minted}
In \mintinline{haskellc}/extendComp/, we need the destination in the parent ampar to be linear, as we fill it with an ampar, which is a linear resource\footnote{Even in a \destcalculus{}-like world, where ampars don't have to be linear, the destination used for composition using $\mathop{\triangleleft\mycirc}$ / \mintinline{haskellc}/fillComp/ / \mintinline{haskellc}/extendComp/ must be linear. The reason is that if we write the child ampar into an unrestricted destination of the parent ampar, then we would need to update the remaining destinations of that child ampar to be unrestricted too, and that is hard to do when we can have arbitrarily complex types on the right-hand side of an ampar.}.

\subsection{Arbitrary type on the right-hand side of ampars}\label{ssec:linear-lens}

Being limited to only one hole on the right-hand side of ampars is not ideal.
One idea to recover arbitrary types on the right-hand side of ampars while still preventing scope escape is to ask the user for a linear lens, to select which destination in the right-hand side they want to operate on. The idea is still the same: if we give a linear destination to the user, scope escape becomes possible, so instead we let the user select which destination they want to fill, by asking for both the ampar (that contain the destination) and a linear lens to focus that particular destination. The linear destination cannot escape its scope as we don't even let the user enter that scope themself.

Unfortunately, adding linear lens to the mix means the signature of \mintinline{haskellc}/extend/ will become even more complex. But first, let's define what a linear lens is.

Lenses are a pattern for defining functional getters and setters that compose easily in an immutable functional programming language.