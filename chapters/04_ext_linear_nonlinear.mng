\chapter{Extending DPS support in Haskell for linear data structures}\label{chap:ext-linear-nonlinear}

The main issue with the approach of the previous chapter is that we are not able to build data structures with a destination-based approach to linear data. This is the consequence of having a lot of flexibility in the way destinations can be used, without a system of ages to prevent scope escape in a fine-grained manner. So we had to use \emph{unrestrictedness} as a barrier so that destinations cannot escape their scope.

Previous works however, such as~\cite{minamide_functional_1998}, or~\cite{lorenzen_searchtree_2024}, would allow for efficient queues (see \cref{ssec:efficient-queue}) or any structure with holes to store linear data, without issues with scope escape. Mainly because they don't have a concept of destinations; in these works we can only fill holes in a structure by interacting with the incomplete structure itself (the ampar). So we ought to find a way for our Haskell implementation to be at least as expressive as these works.

\section{Challenges of destinations for linear data -- scope escape, updated}\label{sec:dps-lin-challenges}

Starting from this point, we will say \emph{linear destination} for an object of type $[[⌊ T ⌋ ˥]]$ or corresponding \mintinline{haskellc}/Dest Ⴈ t/, that is, a destination that can host linear data. Similarly, an \emph{unrestricted destination} is an object of type $[[⌊ T ⌋ ɷ]]$ or \mintinline{haskellc}/Dest ω t/. Regardless, a destination is always, itself, a resource that must be managed linearly. Finally, in the main part of this section, we omit compact region details, for clarity of exposition.

If we want to allow destinations to be filled with linear data, we have to be extremely careful about potential scope escape (see \cref{sec:scope-escape-dests}). One observation is that scope escape can only happen when we let the user fill an older linear destination in a newer scope. Because only linear destinations can be filled with another destination; and we've seen in \cref{sec:scope-escape-dests} that filling a newer destination with an older one doesn't cause scope escape; only filling an older one with a newer one does.

A potential remedy would be to not allow linear destinations to be filled using \mintinline{haskellc}/fillLeaf/ or \mintinline{haskellc}/fillComp/ functions. Instead, linear destinations could only be filled by operating on the ampar they come from, as in~\cite{minamide_functional_1998,lorenzen_searchtree_2024}. That way, we're sure we can only fill the freshest linear destinations (as destinations start to age when they are made accessible in a new scope with \mintinline{haskellc}/updWith/; so destinations still on the right side of a closed ampar are the fresher than any other destination in the context). We will use the base name \mintinline{haskellc}/extend/ for this new family of operators that operate directly on an ampar to fill its destinations. Unrestricted destinations, on the other hand, can still be used with the various \mintinline{haskellc}/fill/ functions. We should note that filling a destination with a hollow constructor cannot cause any scope escape issues, so it's safe to use \mintinline{haskellc}/fill @'Ctor/ on both linear and unrestricted destinations. Let's see what this updated API would look like:

\begin{unbreakable}
{\figtextsize
\begin{minted}[linenos,escapeinside=°°]{haskellc}
data Ampar s t
data Dest m t  -- m is the multiplicity, either Ⴈ or ω
newAmpar ⩴ Token ⊸ Ampar s (Dest Ⴈ s)
updWith ⩴ Ampar s t ⊸ (t ⊸ u) ⊸ Ampar s u

-- for unrestricted destinations
fillLeaf ⩴ t → Dest ω t → ()

-- for linear destinations
extendLeaf ⩴ t ⊸ Ampar s (Dest Ⴈ t) ⊸ Ampar s ()
\end{minted}
}
\end{unbreakable}

The idea is that \mintinline{haskellc}/extendLeaf/ is a way of opening a new scope, filling the linear destination belonging to that fresh scope, and closing it immediately afterwards, without letting the user interfere. So we are confident that the linear destination filled by \mintinline{haskellc}/extendLeaf/ is strictly younger than whatever ends up being stored into it, which prevents scope escape (recall the sane example of \cref{sec:scope-escape-dests}, where an older destination is stored into a younger one with no issues).

Except\ldots{}it doesn't work:
\begin{unbreakable}
{\figtextsize
\begin{minted}[linenos,escapeinside=°°]{haskellc}
newAmpar tok0 `updWith` \(d0 ⩴ Dest Ⴈ (Dest Ⴈ t)) →
  newAmpar tok1 `updWith` \(d1 ⩴ Dest Ⴈ t) →
    (newAmpar tok2 `updWith` \(d2 ⩴ Dest ω ()) → d2 &fillLeaf () ; d0) &extendLeaf d1
\end{minted}
}
\end{unbreakable}

In this particularly cursed but valid\footnote{It's valid in Linear Haskell, but the example would be rejected by \destcalculus{}, as \mintinline{haskellc}/d0/ would have age $[[↑^2]]$ when it is used as a variable in the innermost scope, which isn't allowed by rule \rref*{\CTyTerm\CSep\CId}.} excerpt, we hide an old destination \mintinline{haskellc}/d0/ inside the nest of a fresher one \mintinline{haskellc}/d2/ that we've just consumed. So we have an ampar \mintinline{haskellc}/(newAmpar `updWith` \d2 → d2 &fillLeaf () ; d0)/ whose right-hand side contains a destination \mintinline{haskellc}/d0/ which isn't its own, but comes from a previous scope. However, it is indistinguishable from an ampar whose right side contains only its own destinations, if we just look at the types. So we are allowed to use \mintinline{haskellc}/extendLeaf/ on the cursed ampar, which causes scope escape (as \mintinline{haskellc}/d1/ get stored in the outermost ampar)!

There seems to be an inevitable friction between having a flexible \mintinline{haskellc}/updWith/ function, and having safe linear destinations, when we don't have a proper age system to ensure there is no cheating with scopes.

\paragraph{Restricting \mintinline{haskellc}/updWith/}

If we want to prevent older destinations from hiding in newer ampars, we can ask for \mintinline{haskellc}/updWith/ to \emph{not} capture any linear resource. That way, the only destinations accessible and usable in the scope of \mintinline{haskellc}/updWith/ are the one coming immediately from the ampar being opened.

This is done by changing the signature from \mintinline{haskellc}/updWith ⩴ Ampar s t ⊸ (t ⊸ u) ⊸ Ampar s u/ to \mintinline{haskellc}/updWith ⩴ Ampar s t ⊸ (t ⊸ u) → Ampar s u/. Notice the unrestricted function arrow \mintinline{haskellc}/→/: it means the linear function supplied by the user must not capture anything linear (but still must use its argument linearly). Adding this drastic restriction has many consequences. 

First, obviously, we cannot use any linear resource coming from outer scopes inside the scope of \mintinline{haskellc}/updWith/. In particular, we cannot use a \mintinline{haskellc}/Token/ coming from the top-level linear scope (we described how convenient it is to just have one top-level linear scope in \cref{sec:linear-scopes}). Instead, we have to start a new nested linear scope (by calling \mintinline{haskellc}/withToken/) if we want to create new ampars in the body of \mintinline{haskellc}/updWith/, or tweak \mintinline{haskellc}/updWith/ to also provide a linear token to the inner scope, which gives \mintinline{haskellc}/updWithToken ⩴ Ampar s t ⊸ ((t, Token) ⊸ u) → Ampar s u/ (the ampar on which \mintinline{haskellc}/updWithToken/ operates is a linear resource on which we can base the chain of linearity that threads through the new token).

% STOPPED HERE %

Also, even with this restriction on \mintinline{haskellc}/updWith/, we still cannot fill linear destinations using a \mintinline{haskellc}/fillLeaf/ or \mintinline{haskellc}/fillComp/ function, for two main reasons. One being that we cannot bring linear resources in the scope anyway, so we wouldn't have something useful to fill into the linear destination. The second being that in addition to scope escape, we must be careful about sibling destinations from the same scope interacting with one another. Let's illustrate this issue through an example:
\begin{unbreakable}
{\figtextsize
\begin{minted}[linenos,escapeinside=°°]{haskellc}
fromAmpar' (
  newAmpar @(t, Dest Ⴈ t) tok `updWith` \(d :: Dest Ⴈ (t, Dest Ⴈ t)) →
    case (d &fill @'(,)) of (dt :: Dest Ⴈ t, ddt :: Dest Ⴈ (Dest Ⴈ t)) →
      ddt &fillLeaf dt
)
\end{minted}
}
\end{unbreakable}
Here, we create a new ampar for a pair of a \mintinline{haskellc}/t/ and a \mintinline{haskellc}/Dest Ⴈ t/. After filling the root destination \mintinline{haskellc}/d/ with a hollow pair constructor, we get two destinations, \mintinline{haskellc}/dt/ and \mintinline{haskellc}/ddt/. If we have access to a \mintinline{haskellc}/fillLeaf/ function operating with a linear destination on the left, we can actually put \mintinline{haskellc}/dt/ into \mintinline{haskellc}/ddt/. Because we've consumed the two destinations and unit is returned, it seems that the ampar is complete, while in fact we've never provided a value of type \mintinline{haskellc}/t/ for the first field of the pair! So the structure is still incomplete while we are allowed to call \mintinline{haskellc}/fromAmpar'/ on it and read it!

So far we hadn't spoke about this danger, because the mechanisms used to prevent scope escape in \cref{chap:dest-calculus,chap:dps-haskell} ---that is, either the age system, or the absence of linear destinations--- are enough to also prevent sibling destinations from interacting with one another. But here, the limitation put on \mintinline{haskellc}/updWith/ (not allowing capture of linear resources) only stops scope escape, but not this other issue, because both sibling destinations are coming from the same, freshest scope. Hence, it still wouldn't be safe to have a function \mintinline{haskellc}/fillLeaf/ or \mintinline{haskellc}/fillComp/ operating on linear destinations.

\section{\mintinline{haskellc}/extend/ functions for ampars with a single hole}\label{sec:single-hole}

We've just seen that to use linear destinations safely, we need operators that work on closed ampars directly, instead of destinations. In fact, that is exactly what happens in~\cite{minamide_functional_1998}, or~\cite{lorenzen_searchtree_2024}: they only allow incomplete structures with one hole, and extending the structure happens by manipulating the whole incomplete structure itself, not destinations (as they don't exist in these works).

Let's start by designing new operators for ampars with only one hole, so exactly one (linear) destination on their right-hand side. This restriction implies that when plugging a new hollow constructor into the existing hole, we must fill all of the new fields of the hollow constructor except one, so that only one new hole remains in the structure.

In other terms, we don't want a function working like \mintinline{haskellc}/fill @'(:)/, that returns two new destinations; instead, we must design a function that takes a value as an input, to be filled directly into one of the fields of the pair, so that only one new destination is created\footnote{It's still possible to use \mintinline{haskellc}/updWith/ to access a linear destination, then use \mintinline{haskellc}/fill @'(:)/ on it, creating two new linear destinations. But then we can't use the \mintinline{haskellc}/extendLeaf/ function teased above to fill these destinations with complete values, because \mintinline{haskellc}/extendLeaf/ only works on an ampar with just a single destination on the right-hand side, and \mintinline{haskellc}/fillLeaf/ only works on unrestricted destinations.}. Designing such a function in a generic way is a bit cumbersome, as shown by the signature of \mintinline{haskellc}/extend/ below:
\begin{unbreakable}
{\figtextsize
\begin{minted}[linenos,escapeinside=°°]{haskellc}
extend ⩴ ∀ lCtor k t m s fiTys kthFiTy othFiTys.
           (OnlyLinear lCtor t,
           FieldTypes lCtor t ~ fiTys,
           At k fiTys ~ kthFiTy, Remove k fiTys ~ othFiTys) ⇒
           othFiTys %m→ Ampar s (Dest m t) ⊸ Ampar s (Dest m kthFiTy)
\end{minted}
}
\end{unbreakable}

There's a lot to decipher here. \mintinline{haskellc}/FieldsTypes/ is a type family that returns the types of the fields for a given constructor (specified \mintinline{haskellc}/lCtor/ and the type \mintinline{haskellc}/t/ to which the constructor belongs). For example, \mintinline{haskellc}/FieldsTypes '(:) [Int]/ resolves to \mintinline{haskellc}/(Int, [Int])/. \mintinline{haskellc}/At k/ is a type family that returns the \mintinline{haskellc}/k/\textsuperscript{th} element (i.e. type) of a tuple type, and similarly, \mintinline{haskellc}/Remove k/ returns the same tuple type it is given, with the \mintinline{haskellc}/k/\textsuperscript{th} removed.

The symbol \mintinline{haskellc}/~/ is for type equality constraint, and can be used as above as a way to bind type variables to complex type-level expressions in a function or type class signature. Above, we say that \mintinline{haskellc}/fiTys/ represents all field types of \mintinline{haskellc}/lCtor/, \mintinline{haskellc}/kthFiTy/ is the \mintinline{haskellc}/k/\textsuperscript{th} of these, and \mintinline{haskellc}/othFiTys/ is all the remaining field types except the \mintinline{haskellc}/k/\textsuperscript{th} one, in a tuple if there are more than one remaining type.

For instance, in \mintinline{haskellc}/extend @'(:) @0 @[Int]/, \mintinline{haskellc}/kthFiTy/ is \mintinline{haskellc}/Int/, and \mintinline{haskellc}/othFiTys/ is \mintinline{haskellc}/[Int]/ (not in tuple form because there is only one remaining type). Conversely, in \mintinline{haskellc}/extend @'(:) @1 @[Int]/, \mintinline{haskellc}/kthFiTy/ is \mintinline{haskellc}/[Int]/, and \mintinline{haskellc}/othFiTys/ is just \mintinline{haskellc}/Int/.

In practice, such a signature means that \mintinline{haskellc}/extend/ takes an ampar whose right side is a destination of type \mintinline{haskellc}/t/, with multiplicity \mintinline{haskellc}/m/ (so that we can account for both linear and unrestricted destinations, even though unrestricted destinations can be manipulated in a more flexible fashion through the \mintinline{haskellc}/fill/ family functions). It then allocates a new hollow constructor (specified by \mintinline{haskellc}/lCtor/), consumes \mintinline{haskellc}/othFiTys/ at multiplicity \mintinline{haskellc}/m/ to fill all the fields of the new hollow constructor except the \mintinline{haskellc}/k/\textsuperscript{th} one, and then returns a destination with same multiplicity \mintinline{haskellc}/m/ for that remaining field of type \mintinline{haskellc}/kthFiTy/.

For example, the \mintinline{haskellc}/append ⩴ DList t ⊸ t ⊸ DList t/ function on difference lists can be expressed directly with \mintinline{haskellc}/extend/. So far, \mintinline{haskellc}/DList/ could only store unrestricted elements, but now, we can use difference lists to carry linear elements!

\begin{unbreakable}
{\figtextsize
\begin{minted}[linenos,escapeinside=°°]{haskellc}
type DList t = Ampar [t] (Dest Ⴈ [t])

append ⩴ DList t ⊸ t ⊸ DList t
dlist `append` x = dlist &extend @'(:) @1 x
\end{minted}
}
\end{unbreakable}

We can also use \mintinline{haskellc}/extend/ to define and use \emph{zipper} trees (in the light of~\cite{huet_zipper_1997,lorenzen_searchtree_2024}) that can hold linear data:
\begin{unbreakable}
{\figtextsize
\begin{minted}[linenos,escapeinside=°°]{haskellc}
data Tree t = ¤Nil | ¤Node (Tree t) t (Tree t)
type ZipperTree t = Ampar (Tree t) (Dest Ⴈ (Tree t))

nodeL ⩴ ZipperTree t ⊸ t ⊸ Tree t ⊸ ZipperTree t
nodeL parent x rtree = parent &extend @'Node @0 (x, rtree)

nodeR ⩴ ZipperTree t ⊸ Tree t ⊸ t ⊸ ZipperTree t
nodeR parent ltree x = parent &extend @'Node @2 (ltree, x)
\end{minted}
}
\end{unbreakable}

Note that \mintinline{haskellc}/extend/ doesn't support constructors with 0 fields (it would make the signature of the function way to complex). But 0-ary constructors can be written to the structure like any other complete value anyway, with \mintinline{haskellc}/extendLeaf/:

\begin{unbreakable}
{\figtextsize
\begin{minted}[linenos,escapeinside=°°]{haskellc}
extendLeaf ⩴ ∀ s t m. t %m→ Ampar s (Dest m t) ⊸ Ampar s ()
\end{minted}
}
\end{unbreakable}

Here we've also made \mintinline{haskellc}/extendLeaf/ multiplicity-polymorphic, compared to the initial version presented in \cref{sec:dps-lin-challenges}, but its behavior is the same.

It is a bit pointless in fact to return an \mintinline{haskellc}/Ampar s ()/ to the user from a call to \mintinline{haskellc}/extendLeaf/; it's better to directly extract the completed structure of type \mintinline{haskellc}/s/:
\begin{unbreakable}
{\figtextsize
\begin{minted}[linenos,escapeinside=°°]{haskellc}
fromAmparWithLeaf ⩴ ∀ s t m. t %m→ Ampar s (Dest m t) ⊸ s
fromAmparWithLeaf = fromAmpar' . extendLeaf

-- we use it to implement the remaining operator for zipper trees
done ⩴ ZipperTree t ⊸ Tree t
done parent = parent &fromAmparWithLeaf ¤Nil
\end{minted}
}
\end{unbreakable}

\paragraph{Multiplicity of fields of a constructor and \mintinline{haskellc}/extendUr/}

Above, in the definition of \mintinline{haskellc}/extend/, we considered that the constructor represented by \mintinline{haskellc}/lCtor/ had only linear fields, as reflected by the constraint \mintinline{haskellc}/OnlyLinear lCtor t/. Indeed, the multiplicity \mintinline{haskellc}/m/ at which we consume the values for the other fields, and at which we return the new destination, are the same as the multiplicity of the parent destination.

In \destcalculus{}, every data constructor has linear fields, except the exponential constructor $\expcons{[[m]]}$ which has a single field of mode $[[m]]$. In Haskell however, constructors have only linear fields by default, but can have unrestricted fields when the corresponding datatype is defined with GADT syntax and that an unrestricted arrow \mintinline{haskellc}/→/ is following the field's type. An unrestricted field is a way to hold unrestricted data without needing an explicit \mintinline{haskellc}/Ur/ layer.

Ideally, we should thus refine the \mintinline{haskellc}/extend/ function further, and be polymorphic over the multiplicity of each field. However, to this date, we cannot get the information about field multiplicities through \mintinline{haskellc}/GHC.Generics/, that we use in our practical implementation. More than that actually, we cannot derive a \mintinline{haskellc}/Generic/ instance for types having constructors defined in GADT form.

Hence, for now, it doesn't seem worth it to modify the \mintinline{haskellc}/extend/ function even more for arbitrary multiplicity support on fields. But there is also another consequence: it means we have to add a dedicated version of \mintinline{haskellc}/extend/ for the \mintinline{haskellc}/¤Ur/ constructor, as it doesn't have a \mintinline{haskellc}/Generic/ instance:

\begin{unbreakable}
{\figtextsize
\begin{minted}[linenos,escapeinside=°°]{haskellc}
extendUr ⩴ ∀ s t m. Ampar s (Dest m (Ur t)) ⊸ Ampar s (Dest ω t)
\end{minted}
}
\end{unbreakable}

Given that \mintinline{haskellc}/m/$\ottstype{\pmb{\cdot}}$\mintinline{haskellc}/ω/$ = $\mintinline{haskellc}/ω/ for any \mintinline{haskellc}/m/, the \mintinline{haskellc}/extendUr/ function can operate on an ampar with either a linear or unrestricted destination, but always returns an ampar with an unrestricted destination.

Using \mintinline{haskellc}/extendUr/ is the primary way, in this world, to obtain an initial unrestricted destination \mintinline{haskellc}/Dest ω t/, as \mintinline{haskellc}/newAmpar/ initially spawns an ampar with just a linear destination on the right.

\paragraph{Composition of incomplete structures with \mintinline{haskellc}/extendComp/}

The last function that we need, in this setting, is \mintinline{haskellc}/extendComp/, to plug two ampars together:
\begin{unbreakable}
{\figtextsize
\begin{minted}[linenos,escapeinside=°°]{haskellc}
extendComp ⩴ ∀ s t u. Ampar t u ⊸ Ampar s (Dest Ⴈ t) ⊸ Ampar s u
\end{minted}
}
\end{unbreakable}
In \mintinline{haskellc}/extendComp/, we need the destination in the parent ampar to be a linear destination, for two reasons. First, we fill the destination from the parent ampar with the child ampar \mintinline{haskellc}/Ampar t u/, which is itself a linear resource. Secondly, even in a world where ampars wouldn't have to be linear ---like in the theoretical presentation of \destcalculus{}--- the destination used for composition using $\mathop{\triangleleft\mycirc}$ / \mintinline{haskellc}/fillComp/ / \mintinline{haskellc}/extendComp/ should still be linear. Indeed, the ampar resulting from the composition inherits whatever was on the right of the child ampar (represented by \mintinline{haskellc}/u/ here), which in particular contains the remaining destination(s) from the child ampar. If we were to write the child ampar into an unrestricted destination of the parent ampar, then we would need to update the multiplicity of the remaining destinations of this child ampar, inside \mintinline{haskellc}/u/, to be unrestricted too, and this is not easily expressible.

% STOPPED HERE%

\section{Arbitrary type on the right-hand side of ampars storing linear data}\label{sec:linear-lens}

Being limited to only one destination on the right-hand side of ampars is not ideal. Indeed, we stay at the same expressivity level as existing work, and we loose part of the flexibility that made \destcalculus{} innovative in the first place.

Supporting multiple linear destinations on the right-hand side of ampars introduces significant complexity however. In the previous section, with only one destination per ampar, we avoided scope escape by requiring the user to interact with the ampar directly, rather than with the destination itself. This was straightforward, as there was no ambiguity ---the single destination was the only possible target of the \mintinline{haskellc}/extend/ operation. By contrast, if we now allow arbitrary types on the right-hand side, but still aim to restrict direct user access to destinations (for the same reasons as above; \mintinline{haskellc}/updWith/ is now non-capturing, and we want to prevent scope escape and malicious interaction between sibling destinations), we must introduce a mechanism for users to indicate which specific destination they intend to operate on.

One idea for that is to ask the user for a linear lens. First, let's define what a lens is.

Lenses are a pattern for defining functional getters and setters that compose easily in an immutable functional programming language. A lens of type \mintinline{haskellc}/Lens t1 t2 u1 u2/ has two components (at least conceptually):
\begin{itemize}
    \item a getter function to access a value of type \mintinline{haskellc}/u1/ somewhere inside a structure of type \mintinline{haskellc}/t1/, which establishes the \emph{focus} of the lens;
    \item a function to transform a structure of type \mintinline{haskellc}/t1/ into a structure of type \mintinline{haskellc}/t2/ by replacing the focused value of type \mintinline{haskellc}/u1/ by a value of type \mintinline{haskellc}/u2/. In particular, when \mintinline{haskellc}/u1/$ = $\mintinline{haskellc}/u2/, then \mintinline{haskellc}/t1/$ = $\mintinline{haskellc}/t2/, and thus this function acts as an (immutable) setter for the focused value.
\end{itemize}

Although it isn't the most efficient representation, non-linear lenses can be implemented by the following datatype:
\begin{unbreakable}
{\figtextsize
\begin{minted}[escapeinside=°°]{haskellc}
data LensNL t1 t2 u1 u2 = ¤LensNL
  { view ⩴ t1 → u1  -- just get u1 out of t1, discard the rest
  , update ⩴ t1 → u2 → t2  -- discard the u1 inside t1 and replace it with a u2 to make a t2
  }
\end{minted}
}
\end{unbreakable}

Given a data structure \mintinline{haskellc}/Triple/ with 3 fields, let's create a lens to focus on the first field:
\begin{unbreakable}
{\figtextsize
\begin{minted}[linenos,escapeinside=°°]{haskellc}
data Triple s t u = ¤Triple { first ⩴ s, second ⩴ t, third ⩴ u }

fstNL ⩴ LensNL (Triple s t u) (Triple s' t u) s s'
fstNL = ¤LensNL { view ⩴ \(¤Triple x y z) → x
                    , update ⩴ \(¤Triple x y z) → x' → ¤Triple x' y z }
\end{minted}
}
\end{unbreakable}

With a non-linear lens \mintinline{haskellc}/LensNL/ such as above, if we use the \mintinline{haskellc}/view/ component, then we consume a value of type \mintinline{haskellc}/t1/ but discard most of it except the part of type \mintinline{haskellc}/u1/. If we use the \mintinline{haskellc}/update/ component, it's the opposite; we discard the part of type \mintinline{haskellc}/u1/ but keep all the rest of the original \mintinline{haskellc}/t1/.

For linear lenses, that we'll introduce now, we are not allowed to use the \mintinline{haskellc}/view/ and \mintinline{haskellc}/update/ components separately; otherwise we could drop parts of the original structure of type \mintinline{haskellc}/t1/, as we've just seen. So instead, we group the two functions \mintinline{haskellc}/view/ and \mintinline{haskellc}/update/ into a single one:

\begin{unbreakable}
{\figtextsize
\begin{minted}[escapeinside=°°]{haskellc}
newtype Lens t1 t2 u1 u2 = ¤Lens (t1 ⊸ (u1, u2 ⊸ t2))
\end{minted}
}
\end{unbreakable}

With a linear lens of type \mintinline{haskellc}/Lens t1 t2 u1 u2/, we can split a structure of type \mintinline{haskellc}/t1/ into a pair of a value of type \mintinline{haskellc}/u1/ (the focus), and a closure of type \mintinline{haskellc}/u2 ⊸ t2/ that carries all the rest of the original \mintinline{haskellc}/t1/, and is ready to produce a structure of type \mintinline{haskellc}/t2/ if we give it a \mintinline{haskellc}/u2/. In other terms, this second component of type \mintinline{haskellc}/u2 ⊸ t2/ is really just a functional representation of a \mintinline{haskellc}/t2/ missing a \mintinline{haskellc}/u2/ to be complete. Both of the components of the pair have to be consumed if we want to respect linearity.

It's fairly immediate to update our \mintinline{haskellc}/Triple/ exemple for linear lenses:

\begin{unbreakable}
{\figtextsize
\begin{minted}[linenos,escapeinside=°°]{haskellc}
fst ⩴ Lens (Triple s t u) (Triple s' t u) s s'
fst = ¤Lens (\(¤Triple x y z) → (x, \x' → ¤Triple x' y z))
--                     captures x ↗          ↖ captures y and z
\end{minted}
}
\end{unbreakable}

\paragraph{Lenses to select destinations to operate on}

With linear lenses that we just introduced, the user can specify which destination to operate on when using the new family of \mintinline{haskellc}/extendFocused/ functions. We also get, at the same time, a way to reinsert the newly produced destinations (for fields of the new hollow constructor), or the byproduct of the filling operation, at the exact position that was previously occupied by the destination we just consumed, on the right-hand side of the ampar (thanks to the dual nature of lenses, acting both as a form of getter and setter):

\begin{unbreakable}
{\figtextsize
\begin{minted}[linenos,escapeinside=°°]{haskellc}
extendFocused ⩴ ∀ lCtor u t1 t2 s m.
                (OnlyLinear lCtor u) ⇒
                Lens t1 t2 (Dest m u) (DestsOf lCtor m u) → Ampar s t1 ⊸ Ampar s t2

extendWithNodeOnFst ⩴ Ampar s (Triple (Dest m (Tree t1)) t2 t3)
                        ⊸ Ampar s (Triple (Dest m (Tree t1), Dest m t1, Dest m (Tree t1)) t2 t3)
extendWithNodeOnFst ampar = ampar &(fst &extendFocused @'Node)
\end{minted}
}
\end{unbreakable}

Here, \mintinline{haskellc}/extendFocused/ takes a lens of type \mintinline{haskellc}/Lens t1 t2 (Dest m u) (DestsOf lCtor m u)/, i.e., a lens that focuses on a \mintinline{haskellc}/Dest m u/ inside the right-hand side of type \mintinline{haskellc}/t1/ of the ampar, and let us build a new right-hand side of type \mintinline{haskellc}/t2/ for the resulting ampar, where the destination of type \mintinline{haskellc}/Dest m u/ is replaced by a value of type \mintinline{haskellc}/DestsOf lCtor m u/ (that is, a tuple with the new potential destinations).

The lens is taken as a non-linear argument by \mintinline{haskellc}/extendFocused/ (as indicated by the non-linear arrow \mintinline{haskellc}/→/), so that it cannot capture any linear resource. So the lens is forced to be just a purely structural operation that can be applied as many times as we want on various values of type \mintinline{haskellc}/t1/.

Nonetheless, we could have implemented \mintinline{haskellc}/extendWithNodeOnFst/ in terms of \mintinline{haskellc}/updWith/ and \mintinline{haskellc}/fill @'Node/\footnote{As said previously, \mintinline{haskellc}/fill @'Ctor/ cannot cause scope escape and thus is safe to use for both linear and unrestricted destinations}. In fact, the added value of linear lenses becomes clear when designing the \mintinline{haskellc}/extendFocusedLeaf/ function, which for the first time ever (in the Haskell implementation), enables us to fill a linear destination with a value when the said destination is located within an arbitrary structure on the right-hand side of an ampar:

\begin{unbreakable}
{\figtextsize
\begin{minted}[linenos,escapeinside=°°]{haskellc}
extendFocusedLeaf ⩴ ∀ u t1 t2 s m. u %m→ Lens t1 t2 (Dest m u) () → Ampar s t1 ⊸ Ampar s t2

extendWithValOnFst ⩴ t1 ⊸ Ampar s (Triple (Dest Ⴈ t1) t2 t3) ⊸ Ampar s (Triple () t2 t3)
extendWithValOnFst x ampar = ampar &(fst &extendFocusedLeaf x)
\end{minted}
}
\end{unbreakable}

No scope escape can happen here. As \mintinline{haskellc}/updWith/ is non-capturing, we're sure that the destinations on the right-hand side of an ampar are the ones pointing to the holes on its left-hand side (eliminating the issue presented at the end of \cref{sec:dps-lin-challenges}). So like \mintinline{haskellc}/extendLeaf/, the \mintinline{haskellc}/extendFocusedLeaf/ function can only be used to fill a newer destination with existing (thus, older) values. Likewise, we cannot have sibling destinations interacting with one another. Which means, we've reached our goal for this chapter!

For completeness, we finally define \mintinline{haskellc}/extendFocusedUr/ and \mintinline{haskellc}/extendFocusedComp/, following the same pattern as for \mintinline{haskellc}/extendFocusedLeaf/:

\begin{unbreakable}
{\figtextsize
\begin{minted}[linenos,escapeinside=°°]{haskellc}
extendFocusedUr ⩴ ∀ u t1 t2 s m.
                       Lens t1 t2 (Dest m (Ur u)) (Dest ω u) → Ampar s t1 ⊸ Ampar s t2
extendFocusedComp ⩴ ∀ u t1 t2 s u1 u2.
                          Ampar u1 u2 ⊸ Lens t1 t2 (Dest Ⴈ u1) u2 → Ampar s t1 ⊸ Ampar s t2
\end{minted}
}
\end{unbreakable}

Both of these functions are very similar to their respective one-hole versions \mintinline{haskellc}/extendUr/ and \mintinline{haskellc}/extendComp/. In \mintinline{haskellc}/extendFocusedUr/, we consume a destination of type \mintinline{haskellc}/Dest m (Ur u)/ and replace it with a destination of type \mintinline{haskellc}/Dest ω u/. In \mintinline{haskellc}/extendFocusedComp/, we consume a destination of type \mintinline{haskellc}/Dest Ⴈ u1/, to which we write the left-hand side (of type \mintinline{haskellc}/u1/) of the child ampar, and we replace this consumed destination with whatever was on the right-hand side (of type \mintinline{haskellc}/u2/) of the child ampar. The only difference, between the \mintinline{haskellc}/extend/ and the corresponding \mintinline{haskellc}/extendFocused/ functions, is that the filling operation in the latter happens at a focused location on the right-hand side of an ampar instead of being made on the single destination at top level as in the former.

\section{Breadth-first tree traversal, updated, and final API}\label{sec:bf-api-final}

The family of \mintinline{haskellc}/extendFocused/ functions, based on linear lenses, addresses the core challenge of safely filling destinations with linear data. Although the resulting interface is not entirely satisfactory ---particularly from an ergonomic standpoint--- it still strikes a reasonable compromise between expressiveness and complexity of the interface (given the constraint of working with the existing Haskell type system).

For instance, the DPS system supports two usable levels of nesting for destinations, allowing us to construct and use linear destinations of destinations (type \mintinline{haskellc}/Dest Ⴈ (Dest m t)/). This is in fact perfectly sufficient to implement non-trivial examples, such as the breadth-first traversal of a tree, but this time using the efficient, destination-based queues in Haskell! Let's revisit these examples one last time. For the final part of this chapter, we also take compact region considerations into account (this mostly consists in adding \mintinline{haskellc}/r/ and \mintinline{haskellc}/Region r/ all over the function's signatures). The code of efficient queues (and difference lists for linear data, that they are made of) is presented in \cref{table:eff-queue-lin}, and the code for updated breadth-first tree traversal is given in \cref{table:impl-bfs-tree-traversal-v2}.

\begin{listing}[p]
\figtextsize
\begin{minted}[linenos]{haskellc}
type DList r t = Ampar r [t] (Dest r 1 [t])

newDList :: Region r ⇒ Token ⊸ DList r t
newDList = newAmpar @[t]

dListToList :: Region r ⇒ DList r t ⊸ [t]
dListToList dlist = fromAmpar' (dlist &extendLeaf [])

append :: Region r ⇒ DList r t ⊸ t ⊸ DList r t
append dlist x = dlist &extend @'(:) @1 x

-------------------------------------------------------------------------------

data EffQueue r t = ¤EffQueue [t] (DList r t)

newEffQueue :: Region r ⇒ Token ⊸ EffQueue r t
newEffQueue tok = ¤EffQueue [] (newDList tok)

singleton :: Region r ⇒ Token ⊸ t ⊸ EffQueue r t
singleton tok x = ¤EffQueue [x] (newDList tok)

queueToList :: Region r ⇒ EffQueue r t ⊸ [t]
queueToList (¤EffQueue front back) = front ++ dListToList back

enqueue :: Region r ⇒ EffQueue r t ⊸ t ⊸ EffQueue r t
enqueue (¤EffQueue front back) x = ¤EffQueue front (back `append` x)

dequeue :: Region r ⇒ EffQueue r t ⊸ Maybe (t, EffQueue r t)
dequeue (¤EffQueue front back) = case front of
  [] → case tokenBesides back of (back, tok) → case (toList back) of
    [] → drop tok ; Nothing
    (x : xs) → Just (x, (¤EffQueue xs (newDList tok)))
  (x : xs) → Just (x, (¤EffQueue xs back))
\end{minted}
\caption{Efficient queue for linear data}
\label{table:eff-queue-lin}
\end{listing}

\begin{listing}[p]
\figtextsize
\begin{minted}[linenos]{haskellc}
data Tree t = ¤Nil | ¤Node t (Tree t) (Tree t)

relabelDps ⩴ Region r ⇒ Token ⊸ Tree t → Tree Int
relabelDps tree = fst (macAccumBfs (\st _ → (st + 1, st)) 1 tree)

macAccumBfs ⩴ ∀ r s t u. Region r ⇒ Token ⊸ (s → t → (s, u)) → s → Tree t → (Tree u, s)
macAccumBfs tok f s0 tree =
  case fromAmpar (newAmpar @(Ur (Tree u)) tok `updWith` \du → go s0 (singleton (¤Ur tree, du &fillUr)))
  of (¤Ur outTree, ¤Ur st) → (outTree, st)
  where
    go ⩴ s → EffQueue r (Ur (Tree t), Dest r ω (Tree u)) ⊸ Ur s
    go st q = case dequeue q of
      ¤Nothing → ¤Ur st
      ¤Just ((utree, dtree), q') → case utree of
        ¤Ur ¤Nil → dtree &fill @'Nil ; go st q'
        ¤Ur (¤Node x tl tr) → case (dtree &fill @'Node) of
          (dy, dtl, dtr) →
            let q'' = q' `enqueue` (¤Ur tl, dtl) `enqueue` (¤Ur tr, dtr)
                (st', y) = f st x
              in dy &fillLeaf y ; go st' q''
\end{minted}
\caption{Breadth-first tree traversal revisited, with efficient queue for storing destinations}
\label{table:impl-bfs-tree-traversal-v2}
\end{listing}

There is no real surprise in these implementations; they derive directly from the various iterations and improvements we've made over the different lists, efficient queues and breadth-first traversal examples all along this document.

The only notable thing, maybe, it that we reuse the implementation of difference lists presented in \cref{sec:single-hole}, for which we don't need the flexibility brought by \mintinline{haskellc}/updWith/, and instead rely on the \mintinline{haskellc}/extend/ functions so that we can store linear data in the difference lists (very similarly to what is presented in~\cite{minamide_functional_1998,lorenzen_searchtree_2024}).

The implementation of efficient queues displayed here, on the other hand, is very similar to the one described ealier in \cref{ssec:efficient-queue,sec:api}, except that we are using \mintinline{haskellc}/Ampar/ instead of \mintinline{haskellc}/UAmpar/ to reflect the fact that we can now store linear elements inside the queue.

\paragraph{Full, final API for DPS Haskell with linear destination support}

In \cref{table:destination-api-regions-v2}, we sum up all the functions we've encountered in this chapter, that are needed to create an Haskell API as flexible as possible, while still being safe, to perform destination passing.

At the time of writing the thesis, we have not implemented this whole API yet, but we envision that there shouldn't be any particular technical issue to do so. Indeed, the behavior of the \mintinline{haskellc}/extend/ operators derives directly from the corresponding \mintinline{haskellc}/fill/ functions, that already have a concrete implementation in~\cite{linear_dest}.

\begin{listing}[t]
\figtextsize
\begin{minted}[linenos,escapeinside=°°]{haskellc}
data Token
dup ⩴ Token ⊸ (Token, Token)
drop ⩴ Token ⊸ ()
withToken ⩴ ∀ t. (Token ⊸ Ur t) ⊸ Ur t

type Region r ⩴ Constraint
inRegion ⩴ ∀ t. (∀ r. Region r ⇒ t) ⊸ t

data Ampar r s t
newAmpar ⩴ ∀ r s. Region r ⇒ Token ⊸ Ampar s (Dest r Ⴈ s)
tokenBesides ⩴ ∀ r s t. Region r ⇒ Ampar r s t ⊸ (Ampar r s t, Token)
toAmpar ⩴ ∀ r s. Region r ⇒ Token ⊸ s ⊸ Ampar r s () -- now linear in s
fromAmpar  ⩴ ∀ r s t. Region r ⇒ Ampar r s (Ur t) ⊸ (s, Ur t)
fromAmpar' ⩴ ∀ r s. Region r ⇒ Ampar r s () ⊸ s
updWith ⩴ ∀ r s t u. Region r ⇒ Ampar r s t ⊸ (t ⊸ u) → Ampar r s u -- non-capturing now
updWithToken ⩴ ∀ r s t u. Region r ⇒ Ampar r s t ⊸ ((t, Token) ⊸ u) → Ampar r s u

data Dest r m t
type family DestsOf lCtor r m t -- now multiplicity-polymorphic

-- === API for unrestricted destinations only ===
fillLeaf ⩴ ∀ r t. Region r ⇒ t → Dest r ω t ⊸ ()
-- we can no longer have fillComp for unrestricted destinations

-- === API for ampars with linear or unrestricted destinations ===
fill ⩴ ∀ lCtor r m t. (Region r, OnlyLinear lCtor t) ⇒ Dest r m t ⊸ DestsOf lCtor r m t
fillUr ⩴ ∀ r m t. Region r ⇒ Dest r m (Ur t) ⊸ Dest r ω t

-- only one destination on the right (simplified but less expressive)
extend ⩴ ∀ lCtor r k t m s fiTys kthFiTy othFiTys.
           (Region r, OnlyLinear lCtor t,
           FieldTypes lCtor t ~ fiTys,
           At k fiTys ~ kthFiTy, Remove k fiTys ~ othFiTys) ⇒
           othFiTys %m→ Ampar r s (Dest r m t) ⊸ Ampar r s (Dest r m kthFiTy)
extendUr ⩴ ∀ r s t m. Region r ⇒ Ampar r s (Dest r m (Ur t)) ⊸ Ampar r s (Dest r ω t)
extendLeaf ⩴ ∀ r s t m. Region r ⇒ t %m→ Ampar r s (Dest r m t) ⊸ Ampar r s ()
extendComp ⩴ ∀ r s t u. Region r ⇒ Ampar r t u ⊸ Ampar r s (Dest r Ⴈ t) ⊸ Ampar r s u

-- with arbitrary type on the right; destination focused with a linear lens
extendFocused ⩴ ∀ lCtor r u t1 t2 s m.
                    (Region r, OnlyLinear lCtor u) ⇒
                    Lens t1 t2 (Dest r m u) (DestsOf lCtor r m u) → Ampar r s t1 ⊸ Ampar r s t2
extendFocusedUr ⩴ ∀ r u t1 t2 s m. (Region r) ⇒
                       Lens t1 t2 (Dest r m (Ur u)) (Dest r ω u) → Ampar r s t1 ⊸ Ampar r s t2
extendFocusedLeaf ⩴ ∀ r u t1 t2 s m. (Region r) ⇒
                          u %m→ Lens t1 t2 (Dest r m u) () → Ampar r s t1 ⊸ Ampar r s t2
extendFocusedComp ⩴ ∀ r u t1 t2 s u1 u2. (Region r) ⇒
                          Ampar r u1 u2 ⊸ Lens t1 t2 (Dest r Ⴈ u1) u2 → Ampar r s t1 ⊸ Ampar r s t2

\end{minted}
\caption{Destination-passing API for Haskell with support for linear destinations}
\label{table:destination-api-regions-v2}
\end{listing}

% TODO: On perd en généralité car on n'a plus fillComp

% Si on ne connait pas l'âge d'une dest, mais qu'on sait qu'elle a un age fini inconnu, alors on peut la remplir avec un truc omega infini
% Se justifie via un opérateur de retard?
% Age inconnu = plus petit élément du semiring

% updWith non capturant

% Sinon on peut faire :

% ampar1 `updWith` \d1 →
% 	ampar2 `updWith` \d2 →
% 		(ampar3 `updWith` \d3 → (d1, d3)) & (fst & extendFocusedLeaf d2)

\section{Conclusion}

In this chapter we took time to explore what happens when we relax the drastic restriction we had imposed in \cref{chap:dps-haskell}, namely, that destinations could only be filled with non-linear data (which, consequently, meant that ampars could only be used to store non-linear data).

In several careful steps, avoiding scope escape and similar dangers at every corner, we refined our DPS Haskell API to lift this limitation. First, by allowing the user to build ampars to store linear data, but only if they have only one hole each, in the light of the foundational works~\cite{minamide_functional_1998,lorenzen_searchtree_2024}. This gave birth to the family of \mintinline{haskellc}/extend/ functions, that operate on ampars directly instead of destinations.

In a second time, we released yet another set of functions, denoted by \mintinline{haskellc}/extendFocused/, that let the user fill ampars of arbitrary shapes, with no limit on the number of holes or destinations, with linear data. These functions also operate directly on an ampar, and let the user select the destination they want to focus on, inside the ampar, with a \emph{linear lens} ---that is, a convenient object that acts as both a getter and setter for immutable functional data structures.

In the end, we recover a system that is as close as possible to \destcalculus{} (\cref{chap:dest-calculus}), in terms of flexibility and expressiveness, while still conforming itself to the existing type system of Haskell. Of course, the ergonomics for filling linear destinations are not as smooth as in \destcalculus{}, but our newly gained flexibility let us implemented a revised version of breadth-first tree traversal in Haskell, that this time, uses exactly the same algorithm and underlying data structures as the initial version provided for \destcalculus{} in \cref{sec:bft}.

The final API we obtain, after all these refinements, has not been implemented yet in Haskell, though we don't think that it will be particularly challenging, as most of the hard work for low-level operations has already been done in \cref{sec:implementation}.

Finally, should time be available to devote to this topic in the future, it would be worth exploring how we can leverage the theoretical framework developed in \cref{chap:dest-calculus} to formally prove that our proposed Hakell API in \cref{sec:bf-api-final} is indeed safe.
