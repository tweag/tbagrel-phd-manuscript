\chapter{Extending DPS support for linear data structures}\label{chap:ext-linear-nonlinear}

One issue with the approach of the previous chapter is that we are not able to build data structures hosting linear data with a destination-based approach. This is the consequence of having a lot of flexibility in the handling of destinations, without a system of ages to prevent scope escape in a fine-grained manner.

Previous work however, such as \cite{minamide_functional_1998}, or \cite{lorenzen_searchtree_2024}, would allow for efficient queues (see \cref{ssec:efficient-queue}) to store linear data, without issues with scope escape. So we ought to find a way for our Haskell implementation to be at least as expressive as these works.

If we now allow destinations to be filled with linear data\footnote{Starting from this point, we will call \emph{linear destination} an object of type $[[⌊ T ⌋ ˥]]$ or corresponding \mintinline{haskellc}/Dest 1 t/, that is, a destination that can host linear data. Similarly, an \emph{unrestricted destination} will be an object of type $[[⌊ T ⌋ ɷ]]$ or \mintinline{haskellc}/Dest ω t/}, we have to be extremely careful about potential scope escape. One observation is that scope escape can only happen when we let the user fill an older linear destination in a newer scope.

A potential remedy would be to not allow older linear destinations to be filled using a \mintinline{haskellc}/fill/-like function. Instead, linear destinations could only be filled by operating on the ampar they belong to, as in \cite{minamide_functional_1998} and \cite{lorenzen_searchtree_2024}. Unrestricted destinations, on the other hand, could still be used with \mintinline{haskellc}/fill/-like functions:

\begin{minted}[linenos,escapeinside=°°]{haskellc}
data Ampar s t
newAmpar ⩴ Token ⊸ Ampar s (Dest 1 s)

-- for unrestricted destinations
fillLeaf ⩴ t → Dest ω t → ()

-- for linear destinations
extendLeaf ⩴ t ⊸ Ampar s (Dest 1 t) ⊸ Ampar s ()
\end{minted}

The idea is that \mintinline{haskellc}/extendLeaf/ is a way of opening a new scope, and filling the linear destination, belonging to that fresh scope, immediately, without letting the user interfering. So we are sure that the linear destination filled by \mintinline{haskellc}/extendLeaf/ is strictly younger than whatever ends up stored into it, which prevents scope escape (recall the sane example of \cref{sec:scope-escape-dests}, where an older destination is stored into a younger one with no issues).

Except\ldots{}it still isn't safe:

\begin{minted}[linenos,escapeinside=°°]{haskellc}
newAmpar tok0 `updWith` \d0 ->
  newAmpar tok1 `updWith` \d1 ->
    (newAmpar tok2 `updWith` \d2 -> d2 &fillLeaf () ; d0) &extendLeaf d1
\end{minted}

In this particularly cursed excerpt, we hide an old destination \mintinline{haskellc}/d0/ inside the nest of a fresher one \mintinline{haskellc}/d2/ that we've just consumed. So we have an ampar \mintinline{haskellc}/(newAmpar `updWith` \d2 -> d2 &fillLeaf () ; d0)/ whose right-hand side contains a destination which isn't its own; and we can use that together with \mintinline{haskellc}/extendLeaf/ to cause scope escape!

There seems to be an inevitable friction between having a flexible \mintinline{haskellc}/updWith/ function, and having linear destinations, when we don't have a proper age system to ensure there is no cheating with scopes.

\paragraph{}

A simple remedy for that is to forbid older destinations from being captured in newer scopes. We cannot exactly do that, but we can be more brutal and force \mintinline{haskellc}/updWith/ to \emph{not} capture any linear resource. That way, the only destinations accessible and usable in the scope of \mintinline{haskellc}/updWith/ are the one coming immediately from the ampar being opened.

% TODO: doesn't stop same-level siblings filling

Of course, an issue remains: we can fill destinations with most types of linear data, except destinations, because we cannot 



\section{Restricting ampars for linear data to a single hole}\label{sec:single-hole}

As we've seen in previous chapter, it's enough to forbid linear destinations to prevent any potential scope escape, and recover a safe system without the need for ages. But we could be more subtle, and allow linear destinations on the right-hand side of an ampar, while preventing the user from ever accessing them.

If we do so, how could the user use these destinations to build a structure? Well, we need new operators, that operate on a closed ampars, instead of a destination. In fact, that is exactly what happens in \cite{minamide_functional_1998}, or \cite{lorenzen_searchtree_2024}: they only allow incomplete structures with one hole, and extending the structure happens by manipulating the whole incomplete structure itself, not destinations (as they don't exist in these works).

If we only allow one hole, then it means we cannot have functions such that \mintinline{haskellc}/fill @'(:)/ that plugs a new hollow constructor with two new holes. The user must specify a value for all except one fields of the added constructor.
The signature of such a function would be as follows:

\begin{minted}[linenos,escapeinside=°°]{haskellc}
extend ⩴ ∀ lCtor k t s m fiTy kthFiTy othFiTys.
          (OnlyLinear lCtor t,
           FieldTypes lCtor t ~ fiTys,
           At k fiTys ~ kthFiTy, Remove k fiTys ~ othFiTys) ⇒
          Ampar s (Dest m t) ⊸ othFiTys %m→ Ampar s (Dest m kthFiTy)
\end{minted}

There's a lot to decipher here. \mintinline{haskellc}/FieldsTypes/ is a type family that returns a tuple of the types of the fields for a given constructor, specified in its type-lifted representation \mintinline{haskellc}/lCtor/ and the type \mintinline{haskellc}/t/ to which the constructor belongs. For example, \mintinline{haskellc}/FieldsTypes '(:) [Int]/ resolves to \mintinline{haskellc}/(Int, [Int])/. \mintinline{haskellc}/At k/ is a type family that returns the \mintinline{haskellc}/k/\textsuperscript{th} element (i.e. type) of a tuple type, and similarly, \mintinline{haskellc}/Remove k/ returns the same tuple type it is given, with the \mintinline{haskellc}/k/\textsuperscript{th} removed.

The symbol \mintinline{haskellc}/~/ is for type equality constraint, and can be used as above as a way to bind type variables to complex type-level expressions in a function or type class signature. Above, we say that \mintinline{haskellc}/fiTys/ represents all field types of \mintinline{haskellc}/lCtor/, \mintinline{haskellc}/kthFiTy/ is the \mintinline{haskellc}/k/\textsuperscript{th} of these, and \mintinline{haskellc}/othfiTys/ is all the other field types in a tuple except the \mintinline{haskellc}/k/\textsuperscript{th} one.

For instance, in \mintinline{haskellc}/extend @'(:) @0 @[Int]/, \mintinline{haskellc}/kthFiTy/ would be \mintinline{haskellc}/Int/, and \mintinline{haskellc}/othFiTys/ would be the one-element tuple type \mintinline{haskellc}/Solo [Int]/. Conversely, in \mintinline{haskellc}/extend @'(:) @1 @[Int]/, \mintinline{haskellc}/kthFiTy/ would be \mintinline{haskellc}/[Int]/, and \mintinline{haskellc}/othFiTys/ would be \mintinline{haskellc}/Solo Int/.

\mintinline{haskellc}/extend/ takes an ampar whose right side is a destination of type \mintinline{haskellc}/t/, with multiplicity \mintinline{haskellc}/m/. It then allocates a new hollow constructor (specified by \mintinline{haskellc}/lCtor/), consumes \mintinline{haskellc}/othFiTys/ at multiplicity \mintinline{haskellc}/m/ to fill all the fields of the new hollow constructor except the \mintinline{haskellc}/k/\textsuperscript{th}, and then returns a destination with same multiplicity \mintinline{haskellc}/m/ for that remaining field of type \mintinline{haskellc}/kthFiTy/.

Note that \mintinline{haskellc}/extend/ doesn't support constructors with 0 fields, as these can be plugged into the structure, like any other complete value, with \mintinline{haskellc}/extendLeaf/:

\begin{minted}[linenos,escapeinside=°°]{haskellc}
extendLeaf ⩴ ∀ s t m. t %m→ Ampar s (Dest m t) ⊸ Ampar s ()
\end{minted}
Because we only have one destination on the right-hand side of the ampar, that has now been consumed, we could directly return the completed structure, instead of returning an \mintinline{haskellc}/Ampar s ()/:
\begin{minted}[linenos,escapeinside=°°]{haskellc}
fromAmparWithLeaf ⩴ ∀ s t m. t %m→ Ampar s (Dest m t) ⊸ s
fromAmparWithLeaf = fromAmpar' . extendLeaf
\end{minted}

Note also that above, for \mintinline{haskellc}/extend/, we assumed that the constructor in question only has linear fields, as the multiplicity at which we consume the values for the fields, and at which we return the new destination, are the same as the multiplicity of the parent destination. We reflect that by the pseudo-constraint \mintinline{haskellc}/OnlyLinear lCtor t/. Ideally, we could go further and be polymorphic over the multiplicity of each field, however, to this date, we cannot get that information through GHC.Generics (GHC.Generics is only implemented for constructors having just linear fields). That also means we will have to build a custom version of \mintinline{haskellc}/extend/ for the \mintinline{haskellc}/Ur/ constructor:

\begin{minted}[linenos,escapeinside=°°]{haskellc}
extendUr ⩴ ∀ s t m. Ampar s (Dest m (Ur t)) ⊸ Ampar s (Dest ω t)
\end{minted}

The last function that we need, in this world is \mintinline{haskellc}/extendComp/, to plug two ampars together:
\begin{minted}[linenos,escapeinside=°°]{haskellc}
extendComp ⩴ ∀ s t u. Ampar s (Dest 1 t) ⊸ Ampar t u ⊸ Ampar s u
\end{minted}
In \mintinline{haskellc}/extendComp/, we need the destination in the parent ampar to be linear, as we fill it with an ampar, which is a linear resource\footnote{Even in a \destcalculus{}-like world, where ampars don't have to be linear, the destination used for composition using $\mathop{\triangleleft\mycirc}$ / \mintinline{haskellc}/fillComp/ / \mintinline{haskellc}/extendComp/ must be linear. The reason is that if we write the child ampar into an unrestricted destination of the parent ampar, then we would need to update the remaining destinations of that child ampar to be unrestricted too, and that is hard to do when we can have arbitrarily complex types on the right-hand side of an ampar.}.

\section{Arbitrary type on the right-hand side of ampars}\label{sec:linear-lens}

Being limited to only one destination on the right-hand side of ampars is not ideal. Indeed, we stay at the same expressivity level than existing work.

Going back to arbitrary types on the right hand-side of ampars, for instance to allow multiple destinations, as we did in \cref{chap:dest-calculus,chap:dps-haskell}, creates new challenges. Indeed, when we had only one destination for each ampar, we could operate on the destination through the ampar itself, with no choice to be made: there was only one destination that could be filled. If we have now an arbitrary type on the right-hand side of ampars, and we still want to operate on the destinations without giving direct access to them to the user (the motivation is still the same: if we give a linear destination to the user, scope escape becomes possible), then we need a way for the user to select which destination inside the right-hand side of the ampar they want to operate on. 

One idea for that is to ask the user for a linear lens. First, let's define what a linear lens is.

Lenses are a pattern for defining functional getters and setters that compose easily in an immutable functional programming language. A lens of type \mintinline{haskellc}/Lens t1 t2 u1 u2/ has two components (at least conceptually):
\begin{itemize}
    \item a getter for a value of type \mintinline{haskellc}/u1/ somewhere inside the structure of type \mintinline{haskellc}/t1/, which establishes the \emph{focus} of the lens;
    \item a way to transform a structure of type \mintinline{haskellc}/t1/ into a structure of type \mintinline{haskellc}/t2/ by replacing the (focused) value of type \mintinline{haskellc}/u1/ by a value of type \mintinline{haskellc}/u2/.
\end{itemize}

Although it isn't the most efficient and practical representation, non-linear lenses can be implemented by the following datatype:
\begin{minted}[escapeinside=°°]{haskellc}
data LensNL t1 t2 u1 u2 = ¤LensNL
  { view ⩴ t1 → u1  -- just get u1 out of t1, discard the rest
  , update ⩴ t1 → u2 → t2  -- discard the u1 inside t1 and replace it with a u2 to make a t2
  }
\end{minted}
For linear lenses, we are not allowed to use the \mintinline{haskellc}/view/ and \mintinline{haskellc}/update/ components separately; otherwise we could drop parts of the original structure of type \mintinline{haskellc}/t1/. So instead, we group the two functions into one:
\begin{minted}[escapeinside=°°]{haskellc}
newtype Lens t1 t2 u1 u2 = ¤Lens (t1 ⊸ (u1, u2 ⊸ t2))
\end{minted}
With a linear lens of type \mintinline{haskellc}/Lens t1 t2 u1 u2/, we can split a structure of type \mintinline{haskellc}/t1/ into a pair of a value of type \mintinline{haskellc}/u1/ (the focus), and a closure of type \mintinline{haskellc}/u2 ⊸ t2/ that carries all the rest of the original \mintinline{haskellc}/t1/, and is ready to produce a structure of type \mintinline{haskellc}/t2/ if we give it a \mintinline{haskellc}/u2/. Both of these have to be consumed if we want to respect linearity.

The simplest lens is the standard getter and setter, where \mintinline{haskellc}/t1 = t2/ and \mintinline{haskellc}/u1 = u2/, and thus, \mintinline{haskellc}/Lens t t u u/ becomes an alias for \mintinline{haskellc}/t ⊸ (u, u ⊸ t)/. There, the second element of the pair, of type \mintinline{haskellc}/u ⊸ t/, is really just a functional representation of a \mintinline{haskellc}/t/ missing a \mintinline{haskellc}/u/ to be complete! For example:
\begin{minted}[linenos,escapeinside=°°]{haskellc}
data Triple t1 t2 t3 = ¤Triple { first ⩴ t1, second ⩴ t2, third ⩴ t3 }

fstMono ⩴ Lens (Triple t1 t2 t3) (Triple t1 t2 t3) t1 t1
fstMono (¤Triple { first, second, third }) = (first, \newFirst -> Pair { newFirst, second, third })
\end{minted}

As we see, when we are operating on a polymorphic type such as \mintinline{haskellc}/Triple/, it is a bit silly to restrict our lens to the same type \mintinline{haskellc}/t1/ for both the original value at the focus, and the updated one. We gain much more flexibility by doing:
\begin{minted}[linenos,escapeinside=°°]{haskellc}
fst ⩴ Lens (Triple t1 t2 t3) (Triple t4 t2 t3) t1 t4
fst (¤Triple { first, second, third }) = (first, \newFirst -> Pair { newFirst, second, third })
\end{minted}

\paragraph{Lenses to select destinations to operate on}

With linear lenses, the user can communicate which destination they want to focus, and we gain a way to inject back the potential newly produced destinations at the right place on the right-hand side of the ampar:
\begin{minted}[linenos,escapeinside=°°]{haskellc}
extendFocused ⩴ ∀ lCtor u t1 t2 s m.
                (OnlyLinear lCtor u) ⇒
                Lens t1 t2 (Dest m u) (DestsOf lCtor m u) ⊸ Ampar s t1 ⊸ Ampar s t2

extendWithPairOnFirst ⩴ Ampar s (Triple (Dest m (t11, t12)) t2 t3) ⊸ Ampar s (Triple (Dest m t11, Dest m t12) t2 t3)
extendWithPairOnFirst ampar = ampar &(fst &extendFocused @'(,))
\end{minted}

\paragraph{Limitations of lenses}

% TODO: in fact, that's not true!

Thanks to lenses, we now have a way to operate on linear destinations in arbitrary position on the right-hand side of ampars, but we cannot reorder them or move them around, so we cannot do breadth-first traversal on a linear tree, for example. I don't think there is a way to make destination handling less restricted, without reintroducing potential scope escape.

Still, the situation is quite satisfying. We still can't store linear destinations into linear destinations, but we can store unrestricted destinations into linear destinations. As a result, we can implement breadth-first traversal (for an unrestricted tree), in which we store the unrestricted destinations of the output tree inside an efficient queue, which is made with difference list having linear destinations !

In other terms, we can have at most two usable layers of nesting for destinations. Unrestricted destinations \mintinline{haskellc}/Dest ω t/ for the parent scope, that can be stored (temporarily) inside structures built in a more inner scope using linear destinations \mintinline{haskellc}/Dest 1 (Dest ω t)/. A destination of type \mintinline{haskellc}/Dest ω (Dest m t)/, whatever \mintinline{haskellc}/m/ is, wouldn't be able to be filled because destinations are always a linear resource, and a destination of type \mintinline{haskellc}/Dest 1 (Dest 1 t)/ wouldn't be able to be filled either because the user cannot ever have access to a linear destination as a variable thanks to the restriction we put in place.

% TODO: Truc bizarre, dans dps haskell, on peut composer des structures alors que les dests sont "unrestricted"
% TODO: scope escape caché via fillComp -> possible car toAmpar est linéaire

\begin{listing}[t]
\figtextsize
\begin{minted}[linenos,escapeinside=°°]{haskellc}
data Token
dup ⩴ Token ⊸ (Token, Token)
drop ⩴ Token ⊸ ()
withToken ⩴ ∀ t. (Token ⊸ Ur t) ⊸ Ur t

type Region r ⩴ Constraint
inRegion ⩴ ∀ t. (∀ r. Region r ⇒ t) ⊸ t

data Ampar r s t
newAmpar ⩴ ∀ r s. Region r ⇒ Token ⊸ Ampar s (Dest r 1 s)
newAmparBesides ⩴ ∀ r1 r2 s t u. (Region r1, Region r2) ⇒ Ampar r1 s t ⊸ (Ampar r1 s t, Ampar r2 u (Dest r 1 u))
toAmpar ⩴ ∀ r s. Region r ⇒ Token ⊸ s ⊸ Ampar r s () -- now linear
fromAmpar  ⩴ ∀ r s t. Region r ⇒ Ampar r s (Ur t) ⊸ (s, Ur t)
fromAmpar' ⩴ ∀ r s. Region r ⇒ Ampar r s () ⊸ s
updWith ⩴ ∀ r s t u. Region r ⇒ Ampar r s t ⊸ (t ⊸ u) ⊸ Ampar r s u
<
data Dest r m t
type family DestsOf lCtor r m t -- returns dests associated to fields of constructor

-- API for unrestricted destinations
fill ⩴ ∀ lCtor r t. Region r ⇒ Dest r ω t ⊸ DestsOf lCtor r ω t
fillLeaf ⩴ ∀ r t. Region r ⇒ t → Dest r ω t ⊸ ()

-- API for ampars with linear destinations

-- simplified
extend ⩴ ∀ lCtor r k t s m fiTy kthFiTy othFiTys.
          (Region r, OnlyLinear lCtor t,
           FieldTypes lCtor t ~ fiTys,
           At k fiTys ~ kthFiTy, Remove k fiTys ~ othFiTys) ⇒
          Ampar r s (Dest r m t) ⊸ othFiTys %m→ Ampar r s (Dest r m kthFiTy)
extendUr ⩴ ∀ r s t m. Region r ⇒ Ampar r s (Dest r m (Ur t)) ⊸ Ampar r s (Dest r ω t)
extendLeaf ⩴ ∀ r s t m. Region r ⇒ t %m→ Ampar r s (Dest r m t) ⊸ Ampar r s ()
extendComp ⩴ ∀ r s t u. Region r ⇒ Ampar r s (Dest r 1 t) ⊸ Ampar r t u ⊸ Ampar r s u

-- with lenses
extendFocused ⩴ ∀ lCtor r u t1 t2 s m.
                (Region r, OnlyLinear lCtor u) ⇒
                Lens t1 t2 (Dest r m u) (DestsOf lCtor r m u) ⊸ Ampar r s t1 ⊸ Ampar r s t2
extendFocusedUr ⩴ ∀ r u t1 t2 s m. (Region r) ⇒
                  Lens t1 t2 (Dest r m (Ur u)) (Dest r ω u) ⊸ Ampar r s t1 ⊸ Ampar r s t2
extendFocusedLeaf ⩴ ∀ r u t1 t2 s m. (Region r) ⇒
                    u %m→ Lens t1 t2 (Dest r m u) () ⊸ Ampar r s t1 ⊸ Ampar r s t2
                    
                    -- TODO: inverse order
extendFocusedComp ⩴ ∀ r u t1 t2 s m. (Region r) ⇒
                    Lens t1 t2 (Dest r m u) (DestsOf lCtor r m u) ⊸ Ampar r s t1 ⊸ Ampar r s t2

\end{minted}
\caption{More flexible Destination API (still using compact regions)}
\label{table:destination-api-regions-v2}
\end{listing}

% TODO: On perd en généralité car on n'a plus fillComp

% Si on ne connait pas l'âge d'une dest, mais qu'on sait qu'elle a un age fini inconnu, alors on peut la remplir avec un truc omega infini
% Se justifie via un opérateur de retard?
% Age inconnu = plus petit élément du semiring

% updWith non capturant

% Sinon on peut faire :

% ampar1 `updWith` \d1 ->
% 	ampar2 `updWith` \d2 ->
% 		(ampar3 `updWith` \d3 -> (d1, d3)) & (fst & extendFocusedLeaf d2)

