\chapter{Extending DPS support for linear data structures}\label{chap:ext-linear-nonlinear}

One problem with the approach of the previous chapter is that we are not able to build data structures hosting linear data with a destination-based approach.

This is unfortunate, because previous work, such as \cite{minamide_functional_1998}, or \cite{lorenzen_searchtree_2024} would allow for efficient queues to store linear data, without issues with scope escape.

One observation is that scope escape can only happen when we let the user have direct access to a linear destination\footnote{Starting from this point, we will call \emph{linear destination} an object of type $[[⌊ T ⌋ ˥]]$ or corresponding \mintinline{haskellc}/Dest 1 t/, that is, a destination that can host linear data. Similarly, an \emph{unrestricted destination} will be an object of type $[[⌊ T ⌋ ɷ]]$ or \mintinline{haskellc}/Dest ω t/}. That's one necessary condition for scope escape to happen.

As we've seen in previous chapter, it's enough to forbid linear destinations to prevent any potential scope escape, and recover a safe system without the need for ages. But we could be more subtle, and allow linear destinations on the right-hand side of an ampar, while preventing the user from ever accessing them.

If we do so, how could the user use these destinations to build a structure? Well, we need new operators, that operate on a closed ampars, instead of a destination. In fact, that is exactly what happens in \cite{minamide_functional_1998}, or \cite{lorenzen_searchtree_2024}: they only allow incomplete structures with one hole, and extending the structure happens by manipulating the whole incomplete structure itself, not destinations (as they don't exist in these works).

If we only allow one hole, then it means we cannot have functions such that \mintinline{haskellc}/fill @'(:)/ that plugs a new hollow constructor with two new holes. The user must specify a value for all except one fields of the added constructor.
The signature of such a function would be as follows:

\begin{minted}[linenos,escapeinside=°°]{haskellc}
extend ⩴ forall lCtor k t s m fiTy kthFiTy othFiTys. (OnlyLinear lCtor t, FieldTypes lCtor t ~ fiTys, At k fiTys ~ kthFiTy, Remove k fiTys ~ othFiTys) ⇒ Ampar s (Dest m t) ⊸ othFiTys %m -> Ampar s (Dest m kthFiTy)
\end{minted}

There's a lot to decipher here. \mintinline{haskellc}/FieldsTypes/ is a type family that returns a tuple of the types of the fields for a given constructor, specified in its type-lifted representation \mintinline{haskellc}/lCtor/ and the type \mintinline{haskellc}/t/ to which the constructor belongs. For example, \mintinline{haskellc}/FieldsTypes '(:) [Int]/ resolves to \mintinline{haskellc}/(Int, [Int])/. \mintinline{haskellc}/At k/ is a type family that returns the \mintinline{haskellc}/k/\textsuperscript{th} element (i.e. type) of a tuple type, and similarly, \mintinline{haskellc}/Remove k/ returns the same tuple type it is given, with the \mintinline{haskellc}/k/\textsuperscript{th} removed.

The symbol \mintinline{haskellc}/~/ is for type equality constraint, and can be used as above as a way to bind type variables to complex type-level expressions in a function or type class signature. Above, we say that \mintinline{haskellc}/fiTys/ represents all field types of \mintinline{haskellc}/lCtor/, \mintinline{haskellc}/kthFiTy/ is the \mintinline{haskellc}/k/\textsuperscript{th} of these, and \mintinline{haskellc}/othfiTys/ is all the other field types in a tuple except the \mintinline{haskellc}/k/\textsuperscript{th} one.

For instance, in \mintinline{haskellc}/extend @'(:) @0 @[Int]/, \mintinline{haskellc}/kthFiTy/ would be \mintinline{haskellc}/Int/, and \mintinline{haskellc}/othFiTys/ would be the one-element tuple type \mintinline{haskellc}/Solo [Int]/. Conversely, in \mintinline{haskellc}/extend @'(:) @1 @[Int]/, \mintinline{haskellc}/kthFiTy/ would be \mintinline{haskellc}/[Int]/, and \mintinline{haskellc}/othFiTys/ would be \mintinline{haskellc}/Solo Int/.

\mintinline{haskellc}/extend/ takes an ampar whose right side is a destination of type \mintinline{haskellc}/t/, with multiplicity \mintinline{haskellc}/m/. It then allocates a new hollow constructor (specified by \mintinline{haskellc}/lCtor/), consumes \mintinline{haskellc}/othFiTys/ at multiplicity \mintinline{haskellc}/m/ to fill all the fields of the new hollow constructor except the \mintinline{haskellc}/k/\textsuperscript{th}, and then returns a destination with same multiplicity \mintinline{haskellc}/m/ for that remaining field of type \mintinline{haskellc}/kthFiTy/.

Here, we assume that the constructor in question only has linear fields, as the multiplicity at which we consume the values for the fields, and at which we return the new destination, are the same as the multiplicity of the parent destination. We reflect that by the pseudo-constraint \mintinline{haskellc}/OnlyLinear lCtor t/. Ideally, we could go further and be polymorphic over the multiplicity of each field, however, to this date, we cannot get that information through GHC.Generics (GHC.Generics is only implemented for constructors having just linear fields). That also means we will have to build a custom version of \mintinline{haskellc}/extend/ for the \mintinline{haskellc}/Ur/ constructor.
