\chapter{Extending DPS support for linear data structures}\label{chap:ext-linear-nonlinear}

One problem with the approach of the previous chapter is that we are not able to build data structures hosting linear data with a destination-based approach.

This is unfortunate, because previous work, such as \cite{minamide_functional_1998}, or \cite{lorenzen_searchtree_2024} would allow for efficient queues to store linear data, without issues with scope escape.

One observation is that scope escape can only happen when we let the user have direct access to a linear destination\footnote{Starting from this point, we will call \emph{linear destination} an object of type $[[⌊ T ⌋ ˥]]$ or corresponding \mintinline{haskellc}/Dest 1 t/, that is, a destination that can host linear data. Similarly, an \emph{unrestricted destination} will be an object of type $[[⌊ T ⌋ ɷ]]$ or \mintinline{haskellc}/Dest ω t/}. That's one necessary condition for scope escape to happen.

\subsection{Restricting ampars for linear data to a single hole}\label{ssec:single-hole}

As we've seen in previous chapter, it's enough to forbid linear destinations to prevent any potential scope escape, and recover a safe system without the need for ages. But we could be more subtle, and allow linear destinations on the right-hand side of an ampar, while preventing the user from ever accessing them.

If we do so, how could the user use these destinations to build a structure? Well, we need new operators, that operate on a closed ampars, instead of a destination. In fact, that is exactly what happens in \cite{minamide_functional_1998}, or \cite{lorenzen_searchtree_2024}: they only allow incomplete structures with one hole, and extending the structure happens by manipulating the whole incomplete structure itself, not destinations (as they don't exist in these works).

If we only allow one hole, then it means we cannot have functions such that \mintinline{haskellc}/fill @'(:)/ that plugs a new hollow constructor with two new holes. The user must specify a value for all except one fields of the added constructor.
The signature of such a function would be as follows:

\begin{minted}[linenos,escapeinside=°°]{haskellc}
extend ⩴ ∀ lCtor k t s m fiTy kthFiTy othFiTys.
          (OnlyLinear lCtor t,
           FieldTypes lCtor t ~ fiTys,
           At k fiTys ~ kthFiTy, Remove k fiTys ~ othFiTys) ⇒
          Ampar s (Dest m t) ⊸ othFiTys %m→ Ampar s (Dest m kthFiTy)
\end{minted}

There's a lot to decipher here. \mintinline{haskellc}/FieldsTypes/ is a type family that returns a tuple of the types of the fields for a given constructor, specified in its type-lifted representation \mintinline{haskellc}/lCtor/ and the type \mintinline{haskellc}/t/ to which the constructor belongs. For example, \mintinline{haskellc}/FieldsTypes '(:) [Int]/ resolves to \mintinline{haskellc}/(Int, [Int])/. \mintinline{haskellc}/At k/ is a type family that returns the \mintinline{haskellc}/k/\textsuperscript{th} element (i.e. type) of a tuple type, and similarly, \mintinline{haskellc}/Remove k/ returns the same tuple type it is given, with the \mintinline{haskellc}/k/\textsuperscript{th} removed.

The symbol \mintinline{haskellc}/~/ is for type equality constraint, and can be used as above as a way to bind type variables to complex type-level expressions in a function or type class signature. Above, we say that \mintinline{haskellc}/fiTys/ represents all field types of \mintinline{haskellc}/lCtor/, \mintinline{haskellc}/kthFiTy/ is the \mintinline{haskellc}/k/\textsuperscript{th} of these, and \mintinline{haskellc}/othfiTys/ is all the other field types in a tuple except the \mintinline{haskellc}/k/\textsuperscript{th} one.

For instance, in \mintinline{haskellc}/extend @'(:) @0 @[Int]/, \mintinline{haskellc}/kthFiTy/ would be \mintinline{haskellc}/Int/, and \mintinline{haskellc}/othFiTys/ would be the one-element tuple type \mintinline{haskellc}/Solo [Int]/. Conversely, in \mintinline{haskellc}/extend @'(:) @1 @[Int]/, \mintinline{haskellc}/kthFiTy/ would be \mintinline{haskellc}/[Int]/, and \mintinline{haskellc}/othFiTys/ would be \mintinline{haskellc}/Solo Int/.

\mintinline{haskellc}/extend/ takes an ampar whose right side is a destination of type \mintinline{haskellc}/t/, with multiplicity \mintinline{haskellc}/m/. It then allocates a new hollow constructor (specified by \mintinline{haskellc}/lCtor/), consumes \mintinline{haskellc}/othFiTys/ at multiplicity \mintinline{haskellc}/m/ to fill all the fields of the new hollow constructor except the \mintinline{haskellc}/k/\textsuperscript{th}, and then returns a destination with same multiplicity \mintinline{haskellc}/m/ for that remaining field of type \mintinline{haskellc}/kthFiTy/.

Note that \mintinline{haskellc}/extend/ doesn't support constructors with 0 fields, as these can be plugged into the structure, like any other complete value, with \mintinline{haskellc}/extendLeaf/:

\begin{minted}[linenos,escapeinside=°°]{haskellc}
extendLeaf ⩴ ∀ s t m. Ampar s (Dest m t) ⊸ t %m→ Ampar s ()
\end{minted}
Because we only have one destination on the right-hand side of the ampar, that has now been consumed, we could directly return the completed structure, instead of returning an \mintinline{haskellc}/Ampar s ()/:
\begin{minted}[linenos,escapeinside=°°]{haskellc}
fromAmparWithLeaf ⩴ ∀ s t m. Ampar s (Dest m t) ⊸ t %m→ s
fromAmparWithLeaf = fromAmpar' . extendLeaf
\end{minted}

Note also that above, for \mintinline{haskellc}/extend/, we assumed that the constructor in question only has linear fields, as the multiplicity at which we consume the values for the fields, and at which we return the new destination, are the same as the multiplicity of the parent destination. We reflect that by the pseudo-constraint \mintinline{haskellc}/OnlyLinear lCtor t/. Ideally, we could go further and be polymorphic over the multiplicity of each field, however, to this date, we cannot get that information through GHC.Generics (GHC.Generics is only implemented for constructors having just linear fields). That also means we will have to build a custom version of \mintinline{haskellc}/extend/ for the \mintinline{haskellc}/Ur/ constructor:

\begin{minted}[linenos,escapeinside=°°]{haskellc}
extendUr ⩴ ∀ s t m. Ampar s (Dest m (Ur t)) ⊸ Ampar s (Dest ω t)
\end{minted}

The last function that we need, in this world is \mintinline{haskellc}/extendComp/, to plug two ampars together:
\begin{minted}[linenos,escapeinside=°°]{haskellc}
extendComp ⩴ ∀ s t u. Ampar s (Dest 1 t) ⊸ Ampar t u ⊸ Ampar s u
\end{minted}
In \mintinline{haskellc}/extendComp/, we need the destination in the parent ampar to be linear, as we fill it with an ampar, which is a linear resource\footnote{Even in a \destcalculus{}-like world, where ampars don't have to be linear, the destination used for composition using $\mathop{\triangleleft\mycirc}$ / \mintinline{haskellc}/fillComp/ / \mintinline{haskellc}/extendComp/ must be linear. The reason is that if we write the child ampar into an unrestricted destination of the parent ampar, then we would need to update the remaining destinations of that child ampar to be unrestricted too, and that is hard to do when we can have arbitrarily complex types on the right-hand side of an ampar.}.

\subsection{Arbitrary type on the right-hand side of ampars}\label{ssec:linear-lens}

Being limited to only one hole on the right-hand side of ampars is not ideal. Indeed, we stay at the same expressivity level than existing work.
One idea to recover arbitrary types on the right-hand side of ampars while still preventing scope escape is to ask the user for a linear lens, to select which destination in the right-hand side they want to operate on. The idea is still the same: if we give a linear destination to the user, scope escape becomes possible, so instead we let the user select which destination they want to fill, by asking for both the ampar (that contain the destination) and a linear lens to focus that particular destination. The linear destination cannot escape its scope as we don't even let the user enter that scope themself.

Unfortunately, adding linear lens to the mix means the signature of \mintinline{haskellc}/extend/ will become even more complex. But first, let's define what a linear lens is.

Lenses are a pattern for defining functional getters and setters that compose easily in an immutable functional programming language. A lens of type \mintinline{haskellc}/Lens t1 t2 u1 u2/ has two components (at least conceptually):
\begin{itemize}
    \item a getter for a value of type \mintinline{haskellc}/u1/ somewhere inside the structure of type \mintinline{haskellc}/t1/, which establishes the \emph{focus} of the lens;
    \item a way to transform a structure of type \mintinline{haskellc}/t1/ into a structure of type \mintinline{haskellc}/t2/ by replacing the (focused) value of type \mintinline{haskellc}/u1/ by a value of type \mintinline{haskellc}/u2/.
\end{itemize}

Although it isn't the most efficient and practical representation, non-linear lenses can be implemented by the following datatype:
\begin{minted}[escapeinside=°°]{haskellc}
data LensNL t1 t2 u1 u2 = ¤LensNL
  { view ⩴ t1 → u1  -- just get u1 out of t1, discard the rest
  , update ⩴ t1 → u2 → t2  -- discard the u1 inside t1 and replace it with a u2 to make a t2
  }
\end{minted}
For linear lenses, we are not allowed to use the \mintinline{haskellc}/view/ and \mintinline{haskellc}/update/ components separately; otherwise we could drop parts of the original structure of type \mintinline{haskellc}/t1/. So instead, we group the two functions into one:
\begin{minted}[escapeinside=°°]{haskellc}
newtype Lens t1 t2 u1 u2 = ¤Lens (t1 ⊸ (u1, u2 ⊸ t2))
\end{minted}
With a linear lens of type \mintinline{haskellc}/Lens t1 t2 u1 u2/, we can split a structure of type \mintinline{haskellc}/t1/ into a pair of a value of type \mintinline{haskellc}/u1/ (the focus), and a closure of type \mintinline{haskellc}/u2 ⊸ t2/ that carries all the rest of the original \mintinline{haskellc}/t1/, and is ready to produce a structure of type \mintinline{haskellc}/t2/ if we give it a \mintinline{haskellc}/u2/. Both of these have to be consumed if we want to respect linearity.

The simplest lens is the standard getter and setter, where \mintinline{haskellc}/t1 = t2/ and \mintinline{haskellc}/u1 = u2/, and thus, \mintinline{haskellc}/Lens t t u u/ becomes an alias for \mintinline{haskellc}/t ⊸ (u, u ⊸ t)/. There, the second element of the pair, of type \mintinline{haskellc}/u ⊸ t/, is really just a functional representation of a \mintinline{haskellc}/t/ missing a \mintinline{haskellc}/u/ to be complete! For example:
\begin{minted}[linenos,escapeinside=°°]{haskellc}
data Triple t1 t2 t3 = ¤Triple { first ⩴ t1, second ⩴ t2, third ⩴ t3 }

fstMono ⩴ Lens (Triple t1 t2 t3) (Triple t1 t2 t3) t1 t1
fstMono (¤Triple { first, second, third }) = (first, \newFirst -> Pair { newFirst, second, third })
\end{minted}

As we see, when we are operating on a polymorphic type such as \mintinline{haskellc}/Triple/, it is a bit silly to restrict our lens to the same type \mintinline{haskellc}/t1/ for both the original value at the focus, and the updated one. We gain much more flexibility by doing:
\begin{minted}[linenos,escapeinside=°°]{haskellc}
fst ⩴ Lens (Triple t1 t2 t3) (Triple t4 t2 t3) t1 t4
fst (¤Triple { first, second, third }) = (first, \newFirst -> Pair { newFirst, second, third })
\end{minted}

\paragraph{Lenses to select destinations to operate on}

If we allow more than one linear destination on the right-hand side of ampars, and still disallow the user from using them directly (with fill-like functions), then we need to let them indicate which destination they want to operate on (it was obvious with \mintinline{haskellc}/extend/ in the previous section, as there was only one possible choice).

For that, linear lenses appear to be the perfect solution. With them, the user can communicate which destination they want to focus, and we gain a way to inject back the newly produced destinations at the right place on the right-hand side of the ampar:
\begin{minted}[linenos,escapeinside=°°]{haskellc}
extendFocused ⩴ ∀ lCtor u t1 t2 s m.
                (OnlyLinear lCtor u) ⇒
                Lens t1 t2 (Dest m u) (DestsOf lCtor m u) ⊸ Ampar s t1 ⊸ Ampar s t2

extendWithPairOnFirst ⩴ Ampar s (Triple (Dest m (t11, t12)) t2 t3) ⊸ Ampar s (Triple (Dest m t11, Dest m t12) t2 t3)
extendWithPairOnFirst ampar = ampar &(fst &extendFocused @'(,))
\end{minted}

\paragraph{Limitations of lenses}

Thanks to lenses, we now have a way to operate on linear destinations in arbitrary position on the right-hand side of ampars, but we cannot reorder them or move them around, so we cannot do breadth-first traversal on a linear tree, for example. I don't think there is a way to make destination handling less restricted, without reintroducing potential scope escape.

Still, the situation is quite satisfying. We still can't store linear destinations into linear destinations, but we can store unrestricted destinations into linear destinations. As a result, we can implement breadth-first traversal (for an unrestricted tree), in which we store the unrestricted destinations of the output tree inside an efficient queue, which is made with difference list having linear destinations !

In other terms, we can have at most two usable layers of nesting for destinations. Unrestricted destinations \mintinline{haskellc}/Dest ω t/ for the parent scope, that can be stored (temporarily) inside structures built in a more inner scope using linear destinations \mintinline{haskellc}/Dest 1 (Dest ω t)/. A destination of type \mintinline{haskellc}/Dest ω (Dest m t)/, whatever \mintinline{haskellc}/m/ is, wouldn't be able to be filled because destinations are always a linear resource, and a destination of type \mintinline{haskellc}/Dest 1 (Dest 1 t)/ wouldn't be able to be filled either because the user cannot ever have access to a linear destination as a variable thanks to the restriction we put in place.