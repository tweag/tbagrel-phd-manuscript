\chapter{Extending DPS Haskell to support linear data structures}\label{chap:ext-linear-nonlinear}

% \emph{This chapter builds directly on the contents of the previous one and presupposes a detailed understanding of the concepts and results established therein.}

The main issue with the approach of our DPS Haskell API developed in \cref{chap:dps-haskell} is that data structures built using destination filling cannot store linear data. This is the consequence of having a lot of flexibility in the way destinations can be used, without a system of ages to prevent scope escape in a fine-grained manner. Thus we had to use \emph{unrestrictedness} as a barrier so that destinations cannot escape their scope.

Previous works however, such as~\cite{minamide_functional_1998}, or~\cite{lorenzen_searchtree_2024}, would allow for efficient queues (see \cref{ssec:efficient-queue}) or any structure with holes to store linear data, without issues with scope escape. This happens mainly because they don't have a concept of destinations; in these works we can only fill holes in a structure by interacting with the incomplete structure itself (the ampar). So we ought to find a way for our Haskell implementation to be at least as expressive as these works.

\section{Challenges of destinations for linear data: scope escape, updated}\label{sec:dps-lin-challenges}

Starting from this point, we will say \emph{linear destination} for an object of type $[[⌊ T ⌋ ˥]]$ or corresponding \mintinline{haskellc}/Dest Ⴈ t/, that is, a destination that can host linear data. Similarly, an \emph{unrestricted destination} is an object of type $[[⌊ T ⌋ ɷ]]$ or \mintinline{haskellc}/Dest ω t/. Regardless, a destination is always, itself, a resource that must be managed linearly. Finally, for most of this chapter, we omit compact region details, for clarity of exposition.

If we want to allow destinations to be filled with linear data, we have to be extremely careful about potential scope escape (see \cref{sec:scope-escape-dests}). Scope escape can only occur when a \emph{linear} destination from an older scope is filled within a newer one. This is because only linear destinations can themselves be filled with other destinations. As discussed in \cref{sec:scope-escape-dests}, filling a newer destination with a strictly older one is safe; it is the reverse---filling an older destination with a newer one (or one of the same age)---that causes issues.

A potential remedy would be to not allow linear destinations to be filled using \mintinline{haskellc}/fillLeaf/ or \mintinline{haskellc}/fillComp/ functions. Instead, linear destinations could only be filled by operating on the ampar they come from, as in~\cite{minamide_functional_1998,lorenzen_searchtree_2024}. That way, we're sure we can only fill the freshest linear destinations (as destinations start to age when they are made accessible in a new scope with \mintinline{haskellc}/updWith/; so destinations still on the right side of a closed ampar are fresher than any other destination in the context). We will use the base name \mintinline{haskellc}/extend/ for this new family of operators that operate directly on an ampar to fill its destinations. Unrestricted destinations, on the other hand, can still be used with the various \mintinline{haskellc}/fill/ functions. We should note that filling a destination with a hollow constructor cannot cause any scope escape issues, so it's safe to use \mintinline{haskellc}/fill @'Ctor/ on both linear and unrestricted destinations. Let's see what this updated API would look like:

\begin{unbreakable}
{\figtextsize
\begin{minted}[linenos,escapeinside=°°]{haskellc}
data Ampar s t
data Dest m t  -- m is the multiplicity, either Ⴈ or ω
newAmpar ⩴ Token ⊸ Ampar s (Dest Ⴈ s)
updWith ⩴ Ampar s t ⊸ (t ⊸ u) ⊸ Ampar s u

-- for unrestricted destinations
fillLeaf ⩴ t → Dest ω t → ()

-- for linear destinations
extendLeaf ⩴ t ⊸ Ampar s (Dest Ⴈ t) ⊸ Ampar s ()
\end{minted}
}
\end{unbreakable}

The idea is that \mintinline{haskellc}/extendLeaf/ is a way of opening a new scope, filling the linear destination belonging to that fresh scope, and closing it immediately afterwards, without letting the user interfere. So we could think that in \mintinline{haskellc}/extendLeaf (¤Ampar struct d) val/, the linear destination \mintinline{haskellc}/d/ which gets filled by \mintinline{haskellc}/extendLeaf/ would be always strictly younger than \mintinline{haskellc}/val/ which gets stored into it, preventing scope escape (recall the sane example of \cref{sec:scope-escape-dests}, where an older destination is stored into a younger one with no issues).

Except\ldots{}it doesn't work:
\begin{unbreakable}
{\figtextsize
\begin{minted}[linenos,escapeinside=°°]{haskellc}
newAmpar tok0 `updWith` \(d0 ⩴ Dest Ⴈ (Dest Ⴈ t)) →
  newAmpar tok1 `updWith` \(d1 ⩴ Dest Ⴈ t) →
    (newAmpar tok2 `updWith` \(d2 ⩴ Dest ω ()) → d2 &fillLeaf () ; d0) &extendLeaf d1
\end{minted}
}
\end{unbreakable}

In this particularly convoluted example---which nonetheless typechecks given the API described above\footnote{It would, however, be rejected by \destcalculus{}, as \mintinline{haskellc}/d0/ would have age $[[↑^2]]$ when used as a variable in the innermost scope, which is disallowed by rule \rref*{\CTyTerm\CSep\CId}.}--- an old destination \mintinline{haskellc}/d0/ is hidden inside the nest of a fresher one \mintinline{haskellc}/d2/ that we've just consumed. So we have an ampar \mintinline{haskellc}/(newAmpar tok2 `updWith` \d2 → d2 &fillLeaf () ; d0)/ whose right-hand side contains a destination \mintinline{haskellc}/d0/ which isn't its own, but comes from a previous scope. However, it is indistinguishable from an ampar whose right-hand side contains only its own destinations, if we just look at the types. So we are allowed to use \mintinline{haskellc}/extendLeaf/ on the cursed ampar, which causes scope escape (as \mintinline{haskellc}/d1/ gets stored in the outermost ampar)!

There seems to be an inevitable friction between having a capturing \mintinline{haskellc}/updWith/ function, and having safe linear destinations, when we don't have a proper age system to ensure there is no cheating with scopes.

\paragraph{A non-capturing \texttt{updWith} function}

If we want to prevent older destinations from hiding in newer ampars, we can ask for \mintinline{haskellc}/updWith/ to \emph{not} capture any linear resource. This way, the only destinations accessible and usable in the scope of \mintinline{haskellc}/updWith/ are the ones coming immediately from the ampar being opened.

This is done by changing the signature from \mintinline{haskellc}/updWith ⩴ Ampar s t ⊸ (t ⊸ u) ⊸ Ampar s u/ to \mintinline{haskellc}/updWith ⩴ Ampar s t ⊸ (t ⊸ u) → Ampar s u/. Notice the unrestricted function arrow \mintinline{haskellc}/→/: it means the linear function supplied by the user must not capture anything linear (but still must use its argument linearly). Adding this drastic restriction has many consequences. 

First, obviously, we cannot use any linear resource coming from outer scopes inside the scope of \mintinline{haskellc}/updWith/. In particular, we cannot use a \mintinline{haskellc}/Token/ coming from the top-level linear scope (we described how convenient it is to just have one top-level linear scope in \cref{sec:linear-scopes}). Instead, we have to start a new nested linear scope (by calling \mintinline{haskellc}/withToken/) if we want to create new ampars in the body of \mintinline{haskellc}/updWith/, or tweak \mintinline{haskellc}/updWith/ to also provide a linear token to the inner scope, which gives \mintinline{haskellc}/updWithToken ⩴ Ampar s t ⊸ ((t, Token) ⊸ u) → Ampar s u/ (the ampar on which \mintinline{haskellc}/updWithToken/ operates is a linear resource on which we can base the chain of linearity that threads through the new token).

% STOPPED HERE %

As a side note, even with the restriction on \mintinline{haskellc}/updWith/, we still cannot fill linear destinations using a \mintinline{haskellc}/fillLeaf/ or \mintinline{haskellc}/fillComp/ function, for two main reasons. First, we cannot bring linear resources into scope in the first place, so we rarely have anything useful to fill into a linear destination. Second, allowing \mintinline{haskellc}/fillLeaf/ to operate on linear destinations could enable interactions between sibling destinations originating from the same scope, as described in \cref{sec:scope-escape-dests}. In earlier chapters, the restrictions put in place to prevent proper scope escape also happened to prevent such interaction between sibling destinations; but this is not the case here. Let's see this with an example:

\begin{unbreakable}
{\figtextsize
\begin{minted}[linenos,escapeinside=°°]{haskellc}
fromAmpar' (
  newAmpar @(t, Dest Ⴈ t) tok `updWith` \(d :: Dest Ⴈ (t, Dest Ⴈ t)) →
    case (d &fill @'(,)) of (dt :: Dest Ⴈ t, ddt :: Dest Ⴈ (Dest Ⴈ t)) →
      ddt &fillLeaf dt
)
\end{minted}
}
\end{unbreakable}
Here, we create a new ampar for a pair of a \mintinline{haskellc}/t/ and a \mintinline{haskellc}/Dest Ⴈ t/. After filling the root destination \mintinline{haskellc}/d/ with a hollow pair constructor, we get two destinations, \mintinline{haskellc}/dt/ and \mintinline{haskellc}/ddt/. If we have access to a \mintinline{haskellc}/fillLeaf/ function operating with a linear destination on the left, we can actually put \mintinline{haskellc}/dt/ into \mintinline{haskellc}/ddt/. Because we've consumed the two destinations and unit is returned, it seems that the ampar is complete, while in fact we've never provided a value of type \mintinline{haskellc}/t/ for the first field of the pair! So the structure is still incomplete while we are allowed to call \mintinline{haskellc}/fromAmpar'/ on it and read it!

This demonstrates that even with the restriction on \mintinline{haskellc}/updWith/ (which prevents capturing linear resources), allowing \mintinline{haskellc}/fillLeaf/ or \mintinline{haskellc}/fillComp/ to operate on linear destinations would still be unsafe.

\section{Completing the family of operators for ampars with a single hole}\label{sec:single-hole}

We've just seen that to use linear destinations safely, we need operators that work on closed ampars directly, instead of destinations. In fact, that is exactly what happens in~\cite{minamide_functional_1998}, or~\cite{lorenzen_searchtree_2024}: they only allow incomplete structures with one hole, and extending the structure happens by manipulating the whole incomplete structure itself, not destinations (as they don't exist in these works).

So as we just did with \mintinline{haskellc}/extendLeaf/ above, we'll be designing new operators for ampars with only one hole, so exactly one destination on their right-hand side.

\paragraph{The generic \mintinline{haskellc}/extend/ function}

Similarly to the \mintinline{haskellc}/fill @'Ctor/ function (see \cref{ssec:fill-functions-v0,ssec:impl-generics}), we would like an \mintinline{haskellc}/extend @'Ctor/ function that let us extend an ampar having only one hole with a new arbitrary hollow constructor. However, unlike \mintinline{haskellc}/fill @'Ctor/ that can return a variable number of destinations (e.g. \mintinline{haskellc}/fill @'(:)/ returns two new destinations), we must design a function \mintinline{haskellc}/extend @'Ctor/ that takes several values as an input to fill directly into all except one of the fields of the hollow constructor, so that only one new hole remains, and only one new destination is created\footnote{Alternatively, it's still possible to use \mintinline{haskellc}/updWith/ to access a linear destination, then use \mintinline{haskellc}/fill @'(:)/ on it, creating two new linear destinations. But then we can't use the \mintinline{haskellc}/extendLeaf/ function teased above to fill these destinations with complete values, because \mintinline{haskellc}/extendLeaf/ only works on an ampar with just a single destination on the right-hand side, and \mintinline{haskellc}/fillLeaf/ only works on unrestricted destinations.}. The signature of such a function becomes a bit cumbersome to account for its genericity, as shown below:
\begin{unbreakable}
{\figtextsize
\begin{minted}[linenos,escapeinside=°°]{haskellc}
extend ⩴ ∀ lCtor k t m s fiTys kthFiTy othFiTys.
           (OnlyLinear lCtor t,
           FieldTypes lCtor t ~ fiTys,
           At k fiTys ~ kthFiTy, Remove k fiTys ~ othFiTys) ⇒
           othFiTys %m→ Ampar s (Dest m t) ⊸ Ampar s (Dest m kthFiTy)
\end{minted}
}
\end{unbreakable}

There's a lot to decipher here. \mintinline{haskellc}/OnlyLinear lCtor t/ is a constraint that asks for the chosen data constructor to only have linear fields (more about that in a moment). \mintinline{haskellc}/FieldsTypes/ is a type family that returns the types of the fields for a given constructor (specified \mintinline{haskellc}/lCtor/ and the type \mintinline{haskellc}/t/ to which the constructor belongs). For example, \mintinline{haskellc}/FieldsTypes '(:) [Int]/ resolves to \mintinline{haskellc}/(Int, [Int])/. \mintinline{haskellc}/At k/ is a type family that returns the \mintinline{haskellc}/k/\textsuperscript{th} element (i.e. type) of a tuple type, and similarly, \mintinline{haskellc}/Remove k/ returns the same tuple type it is given, with the \mintinline{haskellc}/k/\textsuperscript{th} removed.

The symbol \mintinline{haskellc}/~/ is for type equality constraint, and can be used as above as a way to bind type variables to complex type-level expressions in a function or type class signature. Above, we say that \mintinline{haskellc}/fiTys/ represents all field types of \mintinline{haskellc}/lCtor/, \mintinline{haskellc}/kthFiTy/ is the \mintinline{haskellc}/k/\textsuperscript{th} of these, and \mintinline{haskellc}/othFiTys/ is all the remaining field types except the \mintinline{haskellc}/k/\textsuperscript{th} one, in a tuple if there are more than one remaining type.

For instance, in \mintinline{haskellc}/extend @'(:) @0 @[Int]/, \mintinline{haskellc}/kthFiTy/ is \mintinline{haskellc}/Int/, and \mintinline{haskellc}/othFiTys/ is \mintinline{haskellc}/[Int]/ (not in tuple form because there is only one remaining type). Conversely, in \mintinline{haskellc}/extend @'(:) @1 @[Int]/, \mintinline{haskellc}/kthFiTy/ is \mintinline{haskellc}/[Int]/, and \mintinline{haskellc}/othFiTys/ is just \mintinline{haskellc}/Int/.

In practice, such a signature means that \mintinline{haskellc}/extend/ takes an ampar whose right side is a destination of type \mintinline{haskellc}/t/, with multiplicity \mintinline{haskellc}/m/\footnote{That way, we can use \mintinline{haskellc}/extend/ on an ampar with either a linear or unrestricted destination on the right, even though unrestricted destinations can be manipulated directly in a more flexible fashion by using the functions from the \mintinline{haskellc}/fill/ family.}. It then allocates a new hollow constructor (specified by \mintinline{haskellc}/lCtor/), consumes \mintinline{haskellc}/othFiTys/ at multiplicity \mintinline{haskellc}/m/ to fill all the fields of the new hollow constructor except the \mintinline{haskellc}/k/\textsuperscript{th} one, and then returns a destination with same multiplicity \mintinline{haskellc}/m/ for that remaining field of type \mintinline{haskellc}/kthFiTy/.

For example, the \mintinline{haskellc}/append ⩴ DList t ⊸ t ⊸ DList t/ function on difference lists can be expressed directly with \mintinline{haskellc}/extend/. So far, \mintinline{haskellc}/DList/ could only store unrestricted elements, but now, we can use difference lists to carry linear elements!

\begin{unbreakable}
{\figtextsize
\begin{minted}[linenos,escapeinside=°°]{haskellc}
type DList t = Ampar [t] (Dest Ⴈ [t])

append ⩴ DList t ⊸ t ⊸ DList t
dlist `append` x = dlist &extend @'(:) @1 x
\end{minted}
}
\end{unbreakable}

We can also use \mintinline{haskellc}/extend/ to define and use \emph{zipper} trees (in the light of~\cite{huet_zipper_1997,lorenzen_searchtree_2024}) that can hold linear data:
\begin{unbreakable}
{\figtextsize
\begin{minted}[linenos,escapeinside=°°]{haskellc}
data Tree t = ¤Nil | ¤Node (Tree t) t (Tree t)
type ZipperTree t = Ampar (Tree t) (Dest Ⴈ (Tree t))

nodeL ⩴ ZipperTree t ⊸ t ⊸ Tree t ⊸ ZipperTree t
nodeL parent x rtree = parent &extend @'Node @0 (x, rtree)

nodeR ⩴ ZipperTree t ⊸ Tree t ⊸ t ⊸ ZipperTree t
nodeR parent ltree x = parent &extend @'Node @2 (ltree, x)
\end{minted}
}
\end{unbreakable}

Note that \mintinline{haskellc}/extend/ doesn't support constructors with 0 fields (it would make the signature of the function way too complex). But 0-ary constructors can be written to the structure like any other complete value anyway, with \mintinline{haskellc}/extendLeaf/:

\begin{unbreakable}
{\figtextsize
\begin{minted}[linenos,escapeinside=°°]{haskellc}
extendLeaf ⩴ ∀ s t m. t %m→ Ampar s (Dest m t) ⊸ Ampar s ()
\end{minted}
}
\end{unbreakable}

Here we've also made \mintinline{haskellc}/extendLeaf/ multiplicity-polymorphic, compared to the initial version presented in \cref{sec:dps-lin-challenges}, but its behavior stays the same.

It is a bit pointless in fact to return an \mintinline{haskellc}/Ampar s ()/ to the user from a call to \mintinline{haskellc}/extendLeaf/; it's better to directly extract the completed structure of type \mintinline{haskellc}/s/:
\begin{unbreakable}
{\figtextsize
\begin{minted}[linenos,escapeinside=°°]{haskellc}
fromAmparWithLeaf ⩴ ∀ s t m. t %m→ Ampar s (Dest m t) ⊸ s
fromAmparWithLeaf = fromAmpar' . extendLeaf

-- we use it to implement the remaining operator for zipper trees
done ⩴ ZipperTree t ⊸ Tree t
done parent = parent &fromAmparWithLeaf ¤Nil
\end{minted}
}
\end{unbreakable}

\paragraph{Multiplicity of fields of a constructor and \mintinline{haskellc}/extendUr/}

Above, in the definition of \mintinline{haskellc}/extend/, we considered that the constructor represented by \mintinline{haskellc}/lCtor/ had only linear fields, as indicated by the constraint \mintinline{haskellc}/OnlyLinear lCtor t/. Indeed, the multiplicity \mintinline{haskellc}/m/ at which we consume the values for the other fields, and at which we return the new destination, are the same as the multiplicity of the parent destination.

In \destcalculus{}, every data constructor has linear fields, except the exponential constructor $\expcons{[[m]]}$ which has a single field of mode $[[m]]$. In Haskell however, constructors have only linear fields by default, but can have unrestricted fields when the corresponding datatype is defined with GADT syntax and that an unrestricted arrow \mintinline{haskellc}/→/ is following the field's type. An unrestricted field is a way to hold unrestricted data without needing an explicit \mintinline{haskellc}/Ur/ layer.

Ideally, we should thus refine the \mintinline{haskellc}/extend/ function further, and be polymorphic over the multiplicity of each field. However, to this date, we cannot get the information about field multiplicities with \mintinline{haskellc}/GHC.Generics/---and this what we use to make DPS Haskell usable with user-defined types. So, for now, it doesn't seem easy to modify the \mintinline{haskellc}/extend/ function even more to account for arbitrary multiplicity on fields. But there is also another consequence: it means we have to add a dedicated version of \mintinline{haskellc}/extend/ for the \mintinline{haskellc}/¤Ur/ constructor:

\begin{unbreakable}
{\figtextsize
\begin{minted}[linenos,escapeinside=°°]{haskellc}
extendUr ⩴ ∀ s t m. Ampar s (Dest m (Ur t)) ⊸ Ampar s (Dest ω t)
\end{minted}
}
\end{unbreakable}

Given that \mintinline{haskellc}/m/$\ottstype{\pmb{\cdot}}$\mintinline{haskellc}/ω/$ = $\mintinline{haskellc}/ω/ for any \mintinline{haskellc}/m/, the \mintinline{haskellc}/extendUr/ function can operate on an ampar with either a linear or unrestricted destination, but always returns an ampar with an unrestricted destination.

Using \mintinline{haskellc}/extendUr/ is the primary way, in this world, to obtain an initial unrestricted destination \mintinline{haskellc}/Dest ω t/, as \mintinline{haskellc}/newAmpar/ initially spawns an ampar with just a linear destination on the right.

\paragraph{Composition of incomplete structures with \mintinline{haskellc}/extendComp/}

The last function we need in this setting is \mintinline{haskellc}/extendComp/, which plugs two ampars together:
\begin{unbreakable}
{\figtextsize
\begin{minted}[linenos,escapeinside=°°]{haskellc}
extendComp ⩴ ∀ s t u. Ampar t u ⊸ Ampar s (Dest Ⴈ t) ⊸ Ampar s u
\end{minted}
}
\end{unbreakable}
In \mintinline{haskellc}/extendComp/, the destination in the parent ampar must be linear, as we already mentioned in \cref{ssec:ty-term}. Otherwise, the following exploit becomes possible:
\begin{unbreakable}
{\figtextsize
\begin{minted}[linenos,escapeinside=°°]{haskellc}
extendCompFaulty ⩴ ∀ s t u m. Ampar t u ⊸ Ampar s (Dest m t) ⊸ Ampar s u

parentAmpar :: Ampar (Ur t) (Dest ω t) = newAmpar tok1 &extendUr
-- resolves to ¤Ampar (¤Ur °$\ottshname{\fbox{$\ottshname{h}$}}$°) (¤Dest °$\ottshname{\to{}\!\!h}$°)

childAmpar :: Ampar Int (Dest Ⴈ Int) = newAmpar tok2
-- resolves to ¤Ampar (°$\ottshname{\fbox{$\ottshname{h'}$}}$°) (¤Dest °$\ottshname{\to{}\!\!h'}$°)

resAmpar :: Ampar (Ur t) (Dest Ⴈ t) = parentAmpar &extendCompFaulty freshAmpar
-- resolves to ¤Ampar (¤Ur °$\ottshname{\fbox{$\ottshname{h'}$}}$°) (¤Dest °$\ottshname{\to{}\!\!h'}$°)

let Ur (linearRes') = resAmpar &fromAmparWithLeaf linearResourceDoNotDuplicate in
  (linearRes', linearRes')
\end{minted}
}
\end{unbreakable}

With the code above, we create an ampar \mintinline{haskellc}/resAmpar/ with a linear destination pointing to an unrestricted hole. This happens because the ampar resulting from a composition inherits whatever was on the right of the child ampar (here a linear destination \mintinline[escapeinside=°°]{haskellc}/¤Dest °$\ottshname{\to h'}$° :: Dest Ⴈ Int/). But the left side of the child ampar has been grafted into the unrestricted hole $
\ottshname{\fbox{h}}$ of the parent ampar. As a result, $\ottshname{\fbox{h'}}$ becomes transitively unrestricted, while its corresponding destination remains linear. This enables the duplication of linear resources, as shown in the last line, so we must prevent it. For the same reason, we cannot define a function \mintinline{haskellc}/fillComp ⩴ Ampar t u ⊸ Dest ω t ⊸ u/ in this setting.\footnote{Recall that we already ruled out defining \mintinline{haskellc}/fill/-like functions for linear destinations since the first section of this chapter.} In \cref{chap:dps-haskell}, this issue did not arise because all destinations were unrestricted by design.

What we can do, however, is define alternative versions of \mintinline{haskellc}/extendComp/ and \mintinline{haskellc}/fillComp/ that operate on unrestricted destinations, with a slightly modified signature, that makes them safe this time:

\begin{minted}[linenos,escapeinside=°°]{haskellc}
extendUComp ⩴ ∀ s t u. Ampar (Ur t) u ⊸ Ampar s (Dest ω t) ⊸ Ampar s u
fillUComp ⩴ ∀ t u. Ampar (Ur t) u ⊸ Dest ω t ⊸ u
\end{minted}

Here, the child ampar is required to be an unrestricted structure (as indicated by the leading \mintinline{haskellc}/Ur/). This ensures that any destination appearing in \mintinline{haskellc}/u/ is already unrestricted. As a result, we eliminate the linearity exploit and recover the same composition behavior we had in \cref{chap:dps-haskell} for \mintinline{haskellc}/UAmpar/s.

% STOPPED HERE%

\section{Ampars with several holes, storing linear data}\label{sec:linear-lens}

Being limited to only one destination on the right-hand side of ampars is not ideal. Indeed, we stay at the same expressivity level as existing work, and we loose part of the flexibility that made \destcalculus{} innovative in the first place.

Supporting multiple linear destinations on the right-hand side of ampars introduces significant complexity however. In the previous section, with only one destination per ampar, we avoided scope escape by requiring the user to interact with the ampar directly, rather than with the destination itself. This was straightforward, as there was no ambiguity---the single destination was the only possible target of the \mintinline{haskellc}/extend/ operation. By contrast, if we now allow arbitrary types on the right-hand side, but still aim to restrict direct user access to destinations (for the same reasons as above; \mintinline{haskellc}/updWith/ is now non-capturing, and we want to prevent scope escape and malicious interaction between sibling destinations), we must introduce a mechanism for users to indicate which specific destination they intend to operate on. One idea is to ask the user for a linear lens. First, let's define what a lens is.

Lenses are pairs of getters and setters that enable convenient handling of immutable data structures in functional programming languages. A lens of type \mintinline{haskellc}/Lens t1 t2 u1 u2/ has two components (at least conceptually):
\begin{itemize}
    \item a getter function to access a value of type \mintinline{haskellc}/u1/ somewhere inside a structure of type \mintinline{haskellc}/t1/, which establishes the \emph{focus} of the lens;
    \item a function to transform a structure of type \mintinline{haskellc}/t1/ into a structure of type \mintinline{haskellc}/t2/ by replacing the focused value of type \mintinline{haskellc}/u1/ by a value of type \mintinline{haskellc}/u2/. In particular, when \mintinline{haskellc}/u1/$ = $\mintinline{haskellc}/u2/, then \mintinline{haskellc}/t1/$ = $\mintinline{haskellc}/t2/, and thus this function acts as an setter for the focused value.
\end{itemize}

In their simplest expressions, non-linear lenses are represented by the following datatype:
\begin{unbreakable}
{\figtextsize
\begin{minted}[escapeinside=°°]{haskellc}
data LensNL t1 t2 u1 u2 = ¤LensNL
  { view ⩴ t1 → u1  -- just get u1 out of t1, discard the rest
  , update ⩴ t1 → u2 → t2  -- discard the u1 inside t1 and replace it with a u2 to make a t2
  }
\end{minted}
}
\end{unbreakable}

Given a data structure \mintinline{haskellc}/Triple/ with 3 fields, let's create a lens to focus on the first field:
\begin{unbreakable}
{\figtextsize
\begin{minted}[linenos,escapeinside=°°]{haskellc}
data Triple s t u = ¤Triple { first ⩴ s, second ⩴ t, third ⩴ u }

fstNL ⩴ LensNL (Triple s t u) (Triple s' t u) s s'
fstNL = ¤LensNL { view = \(¤Triple x y z) → x
                    , update = \(¤Triple x y z) → x' → ¤Triple x' y z }
\end{minted}
}
\end{unbreakable}

With a non-linear lens \mintinline{haskellc}/LensNL/ such as above, if we use the \mintinline{haskellc}/view/ component, then we consume a value of type \mintinline{haskellc}/t1/ but discard most of it except the part of type \mintinline{haskellc}/u1/. If we use the \mintinline{haskellc}/update/ component, it's the opposite; we discard the part of type \mintinline{haskellc}/u1/ but keep all the rest of the original \mintinline{haskellc}/t1/.

For linear lenses, that we'll introduce now, we are not allowed to use the \mintinline{haskellc}/view/ and \mintinline{haskellc}/update/ components separately; otherwise we could drop parts of the original structure of type \mintinline{haskellc}/t1/, as we've just seen. So instead, we group the two functions \mintinline{haskellc}/view/ and \mintinline{haskellc}/update/ into a single one:

\begin{unbreakable}
{\figtextsize
\begin{minted}[escapeinside=°°]{haskellc}
newtype Lens t1 t2 u1 u2 = ¤Lens (t1 ⊸ (u1, u2 ⊸ t2))
\end{minted}
}
\end{unbreakable}

With a linear lens of type \mintinline{haskellc}/Lens t1 t2 u1 u2/, we can split a structure of type \mintinline{haskellc}/t1/ into a pair of a value of type \mintinline{haskellc}/u1/ (the focus), and a closure of type \mintinline{haskellc}/u2 ⊸ t2/ that carries all the rest of the original \mintinline{haskellc}/t1/, and is ready to produce a structure of type \mintinline{haskellc}/t2/ if we give it a \mintinline{haskellc}/u2/. In other terms, this second component of type \mintinline{haskellc}/u2 ⊸ t2/ is really just a functional representation of a \mintinline{haskellc}/t2/ missing a \mintinline{haskellc}/u2/ to be complete. Both of the components of the pair have to be consumed if we want to respect linearity.

It's fairly immediate to update our \mintinline{haskellc}/Triple/ exemple for linear lenses:

\begin{unbreakable}
{\figtextsize
\begin{minted}[linenos,escapeinside=°°]{haskellc}
fst ⩴ Lens (Triple s t u) (Triple s' t u) s s'
fst = ¤Lens (\(¤Triple x y z) → (x, \x' → ¤Triple x' y z))
--                     captures x ↗          ↖ captures y and z
\end{minted}
}
\end{unbreakable}

\paragraph{Lenses to select destinations to operate on}

We now introduce a new family of functions, with base name \mintinline{haskellc}/extendFocused/, that can work on ampars with several holes (thus several destinations), using linear lenses. These linear lenses serve a dual purpose: not only do they let the user select the destination to operate on, but they also give us a way to reinsert the newly created destinations (from the fields of the new hollow constructor) or the byproduct of the filling operation at the exact position previously occupied by the consumed destination, on the right-hand side of the ampar. This is made possible by the bidirectional nature of lenses, acting both as getters and setters. We begin with the generic \mintinline{haskellc}/extendFocused @'Ctor/ function:

\begin{unbreakable}
{\figtextsize
\begin{minted}[linenos,escapeinside=°°]{haskellc}
extendFocused ⩴ ∀ lCtor u t1 t2 s m.
                (OnlyLinear lCtor u) ⇒
                Lens t1 t2 (Dest m u) (DestsOf lCtor m u) → Ampar s t1 ⊸ Ampar s t2

extendWithNodeOnFst ⩴ Ampar s (Triple (Dest m (Tree t1)) t2 t3)
                        ⊸ Ampar s (Triple (Dest m (Tree t1), Dest m t1, Dest m (Tree t1)) t2 t3)
extendWithNodeOnFst ampar = ampar & fst extendFocused fst @'Node
\end{minted}
}
\end{unbreakable}

Here, \mintinline{haskellc}/extendFocused/ takes a lens of type \mintinline{haskellc}/Lens t1 t2 (Dest m u) (DestsOf lCtor m u)/, i.e. a lens that focuses on a \mintinline{haskellc}/Dest m u/ inside the right-hand side of type \mintinline{haskellc}/t1/ of the ampar, and lets us build a new right-hand side of type \mintinline{haskellc}/t2/ for the resulting ampar, where the destination of type \mintinline{haskellc}/Dest m u/ is replaced by a value of type \mintinline{haskellc}/DestsOf lCtor m u/ (that is, a tuple with the new potential destinations).

The lens is taken as a non-linear argument by \mintinline{haskellc}/extendFocused/ (as indicated by the non-linear arrow \mintinline{haskellc}/→/), so that it cannot capture any linear resource. So the lens is forced to be just a purely structural operation that can be applied as many times as we want on various values of type \mintinline{haskellc}/t1/.

Nonetheless, we could have implemented \mintinline{haskellc}/extendWithNodeOnFst/ in terms of \mintinline{haskellc}/updWith/ and \mintinline{haskellc}/fill @'Node/\footnote{As said previously, \mintinline{haskellc}/fill @'Ctor/ cannot cause scope escape and thus is safe to use for both linear and unrestricted destinations}. In fact, the added value of linear lenses becomes clear when designing the \mintinline{haskellc}/extendFocusedLeaf/ function, which for the first time (in the Haskell implementation), enables us to fill a linear destination with a value when the said destination is located within an arbitrary structure on the right-hand side of an ampar:

\begin{unbreakable}
{\figtextsize
\begin{minted}[linenos,escapeinside=°°]{haskellc}
extendFocusedLeaf ⩴ ∀ u t1 t2 s m. u %m→ Lens t1 t2 (Dest m u) () → Ampar s t1 ⊸ Ampar s t2

extendWithValOnFst ⩴ t1 ⊸ Ampar s (Triple (Dest Ⴈ t1) t2 t3) ⊸ Ampar s (Triple () t2 t3)
extendWithValOnFst x ampar = ampar &extendFocusedLeaf fst x
\end{minted}
}
\end{unbreakable}

No scope escape can happen here. As \mintinline{haskellc}/updWith/ is non-capturing, we're sure that the destinations on the right-hand side of an ampar are the ones pointing to the holes on its left-hand side (eliminating the issue presented at the end of \cref{sec:dps-lin-challenges}). So like \mintinline{haskellc}/extendLeaf/, the \mintinline{haskellc}/extendFocusedLeaf/ function can only be used to fill a newer destination with existing (thus, older) values. Likewise, we cannot have sibling destinations interacting with one another. Which means, we've reached the goal stated at the beginning of this chapter: we can build structures having several linear holes in a safe manner in DPS Haskell!

For completeness, we finally define \mintinline{haskellc}/extendFocusedUr/, \mintinline{haskellc}/extendFocusedComp/ and \mintinline{haskellc}/extendFocusedUComp/, following the same pattern as for \mintinline{haskellc}/extendFocusedLeaf/:

\begin{unbreakable}
{\figtextsize
\begin{minted}[linenos,escapeinside=°°]{haskellc}
extendFocusedUr ⩴ ∀ u t1 t2 s m.
                       Lens t1 t2 (Dest m (Ur u)) (Dest ω u) → Ampar s t1 ⊸ Ampar s t2
extendFocusedComp ⩴ ∀ u t1 t2 s u1 u2.
                          Ampar u1 u2 ⊸ Lens t1 t2 (Dest Ⴈ u1) u2 → Ampar s t1 ⊸ Ampar s t2
extendFocusedUComp ⩴ ∀ u t1 t2 s u1 u2.
                           Ampar (Ur u1) u2 ⊸ Lens t1 t2 (Dest ω u1) u2 → Ampar s t1 ⊸ Ampar s t2
\end{minted}
}
\end{unbreakable}

Both of these functions are very similar to their respective one-hole versions \mintinline{haskellc}/extendUr/ and \mintinline{haskellc}/extendComp/. In \mintinline{haskellc}/extendFocusedUr/, we consume a destination of type \mintinline{haskellc}/Dest m (Ur u)/ and replace it with a destination of type \mintinline{haskellc}/Dest ω u/. In \mintinline{haskellc}/extendFocusedComp/, we consume a destination of type \mintinline{haskellc}/Dest Ⴈ u1/, to which we write the left-hand side (of type \mintinline{haskellc}/u1/) of the child ampar, and we replace this consumed destination with whatever was on the right-hand side (of type \mintinline{haskellc}/u2/) of the child ampar. The only difference, between the \mintinline{haskellc}/extend/ and the corresponding \mintinline{haskellc}/extendFocused/ functions, is that the filling operation in the latter happens at a focused location on the right-hand side of an ampar instead of being made on the single destination at top level as in the former.

\section{Final API and breadth-first tree traversal, updated}\label{sec:bf-api-final}

The family of \mintinline{haskellc}/extendFocused/ functions, based on linear lenses, addresses the core challenge of safely filling destinations with linear data. Although the resulting interface is not entirely satisfactory---particularly from an ergonomic standpoint---it still strikes a reasonable compromise between expressiveness and complexity of the interface (given the constraint of working with the existing Haskell type system).

For instance, the DPS system supports two usable levels of nesting for destinations, allowing us to construct and use linear destinations of destinations (type \mintinline{haskellc}/Dest Ⴈ (Dest m t)/). This is in fact perfectly sufficient to implement non-trivial examples, such as the breadth-first traversal of a tree, but this time using the efficient, destination-based queues in Haskell! Let's revisit these examples one last time. For the final part of this chapter, we also take compact region considerations into account (this mostly consists in adding \mintinline{haskellc}/r/ and \mintinline{haskellc}/Region r/ all over the function's signatures). The code of efficient queues (and difference lists for linear data, that they are made of) is presented in \cref{table:eff-queue-lin}, and the code for updated breadth-first tree traversal is given in \cref{table:impl-bfs-tree-traversal-v2}.

\begin{listing}[p]
\figtextsize
\begin{minted}[linenos]{haskellc}
type DList r t = Ampar r [t] (Dest r 1 [t])

newDList :: Region r ⇒ Token ⊸ DList r t
newDList = newAmpar @[t]

dListToList :: Region r ⇒ DList r t ⊸ [t]
dListToList dlist = fromAmpar' (dlist &extendLeaf [])

append :: Region r ⇒ DList r t ⊸ t ⊸ DList r t
append dlist x = dlist &extend @'(:) @1 x

-------------------------------------------------------------------------------

data EffQueue r t = ¤EffQueue [t] (DList r t)

newEffQueue :: Region r ⇒ Token ⊸ EffQueue r t
newEffQueue tok = ¤EffQueue [] (newDList tok)

singleton :: Region r ⇒ Token ⊸ t ⊸ EffQueue r t
singleton tok x = ¤EffQueue [x] (newDList tok)

queueToList :: Region r ⇒ EffQueue r t ⊸ [t]
queueToList (¤EffQueue front back) = front ++ dListToList back

enqueue :: Region r ⇒ EffQueue r t ⊸ t ⊸ EffQueue r t
enqueue (¤EffQueue front back) x = ¤EffQueue front (back `append` x)

dequeue :: Region r ⇒ EffQueue r t ⊸ Maybe (t, EffQueue r t)
dequeue (¤EffQueue front back) = case front of
  [] → case tokenBesides back of (back, tok) → case (toList back) of
    [] → drop tok ; Nothing
    (x : xs) → Just (x, (¤EffQueue xs (newDList tok)))
  (x : xs) → Just (x, (¤EffQueue xs back))
\end{minted}
\caption{Efficient queue for linear data in extended DPS Haskell}
\label{table:eff-queue-lin}
\end{listing}

\begin{listing}[p]
\figtextsize
\begin{minted}[linenos]{haskellc}
data Tree t = ¤Nil | ¤Node t (Tree t) (Tree t)

relabelDps ⩴ Region r ⇒ Token ⊸ Tree t → Tree Int
relabelDps tree = fst (mapAccumBfs (\st _ → (st + 1, st)) 1 tree)

mapAccumBfs ⩴ ∀ r s t u. Region r ⇒ Token ⊸ (s → t → (s, u)) → s → Tree t → (Tree u, s)
mapAccumBfs tok f s0 tree =
  case fromAmpar (newAmpar @(Ur (Tree u)) tok `updWith` \du → go s0 (singleton (¤Ur tree, du &fillUr)))
  of (¤Ur outTree, ¤Ur st) → (outTree, st)
  where
    go ⩴ s → EffQueue r (Ur (Tree t), Dest r ω (Tree u)) ⊸ Ur s
    go st q = case dequeue q of
      ¤Nothing → ¤Ur st
      ¤Just ((utree, dtree), q') → case utree of
        ¤Ur ¤Nil → dtree &fill @'Nil ; go st q'
        ¤Ur (¤Node x tl tr) → case (dtree &fill @'Node) of
          (dy, dtl, dtr) →
            let q'' = q' `enqueue` (¤Ur tl, dtl) `enqueue` (¤Ur tr, dtr)
                (st', y) = f st x
              in dy &fillLeaf y ; go st' q''
\end{minted}
\caption{Breadth-first tree traversal using efficient queues in extended DPS Haskell}
\label{table:impl-bfs-tree-traversal-v2}
\end{listing}

These implementations derive directly from the various iterations and improvements we've made over the different lists, efficient queues and breadth-first traversal examples all along this document.

Notably though, we leverage both the \mintinline{haskellc}/fill/ and the \mintinline{haskellc}/extend/ families of functions in these examples. For instance, we reuse the implementation of difference lists presented in \cref{sec:single-hole}, for which we don't need the flexibility brought by \mintinline{haskellc}/updWith/, and instead rely on the \mintinline{haskellc}/extend/ functions so that we can store linear data in the difference lists (very similarly to what is presented in~\cite{minamide_functional_1998,lorenzen_searchtree_2024}). On the other hand, the breadth-first tree traversal is still implemented using \mintinline{haskellc}/updWith/ and \mintinline{haskellc}/fill/-like functions, which are essential for operating on the destinations stored in the queue.\footnote{It would not be possible to implement the breadth-first traversal using only \mintinline{haskellc}/extend/ functions with lens support. If it is possible at all, it would require more powerful \emph{optics} (the broader family of abstractions that includes lenses), and the resulting code would likely be much more verbose.}

\paragraph{Full, final API for DPS Haskell with linear destination support}

In \cref{table:destination-api-regions-v2}, we sum up all the functions we've encountered in this chapter, that are needed to create an Haskell API as flexible as possible, while still being safe, to perform destination passing.

At the time of writing the thesis, we have not implemented this whole API yet, but we envision that there shouldn't be any particular technical issue to do so. Indeed, the behavior of the \mintinline{haskellc}/extend/ operators derives directly from the corresponding \mintinline{haskellc}/fill/ functions, that already have a concrete implementation in~\cite{linear_dest}.

\begin{listing}[t]
\figtextsize
\begin{minted}[linenos,escapeinside=°°]{haskellc}
data Token
dup ⩴ Token ⊸ (Token, Token)
drop ⩴ Token ⊸ ()
withToken ⩴ ∀ t. (Token ⊸ Ur t) ⊸ Ur t

type Region r ⩴ Constraint
inRegion ⩴ ∀ t. (∀ r. Region r ⇒ t) ⊸ t

data Ampar r s t
newAmpar ⩴ ∀ r s. Region r ⇒ Token ⊸ Ampar s (Dest r Ⴈ s)
tokenBesides ⩴ ∀ r s t. Region r ⇒ Ampar r s t ⊸ (Ampar r s t, Token)
toAmpar ⩴ ∀ r s. Region r ⇒ Token ⊸ s ⊸ Ampar r s () -- now linear in s
fromAmpar  ⩴ ∀ r s t. Region r ⇒ Ampar r s (Ur t) ⊸ (s, Ur t)
fromAmpar' ⩴ ∀ r s. Region r ⇒ Ampar r s () ⊸ s
updWith ⩴ ∀ r s t u. Region r ⇒ Ampar r s t ⊸ (t ⊸ u) → Ampar r s u -- non-capturing now
updWithToken ⩴ ∀ r s t u. Region r ⇒ Ampar r s t ⊸ ((t, Token) ⊸ u) → Ampar r s u

data Dest r m t
type family DestsOf lCtor r m t -- now multiplicity-polymorphic

-- === API for unrestricted destinations only ===
fillLeaf ⩴ ∀ r t. Region r ⇒ t → Dest r ω t ⊸ ()
fillUComp ⩴ ∀ r t u. Region r ⇒ Ampar r (Ur t) u ⊸ Dest r ω t ⊸ u

-- === API for ampars with linear or unrestricted destinations ===
fill ⩴ ∀ lCtor r m t. (Region r, OnlyLinear lCtor t) ⇒ Dest r m t ⊸ DestsOf lCtor r m t
fillUr ⩴ ∀ r m t. Region r ⇒ Dest r m (Ur t) ⊸ Dest r ω t

-- only one destination on the right (simplified but less expressive)
extend ⩴ ∀ lCtor r k t m s fiTys kthFiTy othFiTys.
           (Region r, OnlyLinear lCtor t,
           FieldTypes lCtor t ~ fiTys,
           At k fiTys ~ kthFiTy, Remove k fiTys ~ othFiTys) ⇒
           othFiTys %m→ Ampar r s (Dest r m t) ⊸ Ampar r s (Dest r m kthFiTy)
extendUr ⩴ ∀ r s t m. Region r ⇒ Ampar r s (Dest r m (Ur t)) ⊸ Ampar r s (Dest r ω t)
extendLeaf ⩴ ∀ r s t m. Region r ⇒ t %m→ Ampar r s (Dest r m t) ⊸ Ampar r s ()
extendComp ⩴ ∀ r s t u. Region r ⇒ Ampar r t u ⊸ Ampar r s (Dest r Ⴈ t) ⊸ Ampar r s u
extendUComp ⩴ ∀ r s t u. Region r ⇒ Ampar r (Ur t) u ⊸ Ampar r s (Dest r ω t) ⊸ Ampar r s u

-- with arbitrary type on the right; destination focused with a linear lens
extendFocused ⩴ ∀ lCtor r u t1 t2 s m.
                    (Region r, OnlyLinear lCtor u) ⇒
                    Lens t1 t2 (Dest r m u) (DestsOf lCtor r m u) → Ampar r s t1 ⊸ Ampar r s t2
extendFocusedUr ⩴ ∀ r u t1 t2 s m. (Region r) ⇒
                       Lens t1 t2 (Dest r m (Ur u)) (Dest r ω u) → Ampar r s t1 ⊸ Ampar r s t2
extendFocusedLeaf ⩴ ∀ r u t1 t2 s m. (Region r) ⇒
                          u %m→ Lens t1 t2 (Dest r m u) () → Ampar r s t1 ⊸ Ampar r s t2
extendFocusedComp ⩴ ∀ r u t1 t2 s u1 u2. (Region r) ⇒
                          Ampar r u1 u2 ⊸ Lens t1 t2 (Dest r Ⴈ u1) u2 → Ampar r s t1 ⊸ Ampar r s t2
extendFocusedUComp ⩴ ∀ r u t1 t2 s u1 u2. (Region r) ⇒
                           Ampar r (Ur u1) u2 ⊸ Lens t1 t2 (Dest r ω u1) u2 → Ampar r s t1 ⊸ Ampar r s t2

\end{minted}
\caption{Extended DPS Haskell API with support for linear destinations}
\label{table:destination-api-regions-v2}
\end{listing}

% TODO: On perd en généralité car on n'a plus fillComp

% Si on ne connait pas l'âge d'une dest, mais qu'on sait qu'elle a un age fini inconnu, alors on peut la remplir avec un truc omega infini
% Se justifie via un opérateur de retard?
% Age inconnu = plus petit élément du semiring

% updWith non capturant

% Sinon on peut faire :

% ampar1 `updWith` \d1 →
% 	ampar2 `updWith` \d2 →
% 		(ampar3 `updWith` \d3 → (d1, d3)) & (fst & extendFocusedLeaf d2)

\section{Conclusion}

In this chapter we took time to explore what happens when we relax the restriction we had imposed in \cref{chap:dps-haskell}, namely, that destinations could only be filled with non-linear data (which, consequently, meant that ampars could only be used to store non-linear data).

In several careful steps, avoiding scope escape and similar dangers at every corner, we refined our DPS Haskell API to lift this limitation. First, by allowing the user to build ampars to store linear data, but only if they have only one hole each, in the light of the foundational works~\cite{minamide_functional_1998,lorenzen_searchtree_2024}. This gave birth to the family of \mintinline{haskellc}/extend/ functions, that operate on ampars directly instead of destinations.

In a second step, we proposed yet another set of functions, denoted by \mintinline{haskellc}/extendFocused/, that let the user fill ampars of arbitrary shapes, with no limit on the number of holes or destinations, with linear data. These functions also operate directly on an ampar, and let the user select the destination they want to focus on, inside the ampar, with a \emph{linear lens}---that is, a convenient object that acts as both a getter and setter for immutable functional data structures.

In the end, we recover a system that is as close to \destcalculus{} (\cref{chap:dest-calculus}) as we could safely design within the existing type system of Haskell, with expressivity improvements over the initial DPS Haskell API. Of course, the ergonomics for filling linear destinations are not as smooth as in \destcalculus{}, but our newly gained flexibility let us implement a revised version of breadth-first tree traversal that, this time, used exactly the same algorithm and underlying data structures as the initial version proposed in \cref{sec:bft}.

The final API we obtain, after all these refinements, has not been implemented yet in Haskell, though we don't think that it will be particularly challenging, as most of the hard work for low-level operations has already been done in \cref{sec:implementation}.

% Finally, should time be available to devote to this topic in the future, it would be worth exploring how we can leverage the theoretical framework developed in \cref{chap:dest-calculus} to formally prove that our proposed Hakell API in \cref{sec:bf-api-final} is indeed safe.
